From 782a8998365e740c1ba4712a20a4f043b43e2026 Mon Sep 17 00:00:00 2001
From: Melissa Stone <melissa@puppetlabs.com>
Date: Thu, 11 Jun 2015 12:14:32 -0700
Subject: [PATCH] [PATCH] Update rubygems to 2.4.8 to mitigate CVE-2015-4020

---
 jruby/lib/ruby/shared/gauntlet_rubygems.rb         |   2 +-
 jruby/lib/ruby/shared/rubygems.rb                  | 246 ++++---
 jruby/lib/ruby/shared/rubygems/available_set.rb    |   9 +-
 .../ruby/shared/rubygems/basic_specification.rb    | 170 ++++-
 jruby/lib/ruby/shared/rubygems/command.rb          |   5 +-
 jruby/lib/ruby/shared/rubygems/command_manager.rb  |   3 +-
 .../ruby/shared/rubygems/commands/cert_command.rb  |  24 +-
 .../shared/rubygems/commands/cleanup_command.rb    |   4 +-
 .../shared/rubygems/commands/contents_command.rb   |  34 +-
 .../shared/rubygems/commands/dependency_command.rb |   4 +-
 .../rubygems/commands/environment_command.rb       |   7 +-
 .../rubygems/commands/generate_index_command.rb    |   2 +-
 .../ruby/shared/rubygems/commands/help_command.rb  | 219 +++++-
 .../shared/rubygems/commands/install_command.rb    | 145 +++-
 .../ruby/shared/rubygems/commands/list_command.rb  |  12 +-
 .../shared/rubygems/commands/mirror_command.rb     |  32 +-
 .../ruby/shared/rubygems/commands/open_command.rb  |  76 ++
 .../shared/rubygems/commands/outdated_command.rb   |   2 +-
 .../ruby/shared/rubygems/commands/owner_command.rb |   4 +-
 .../shared/rubygems/commands/pristine_command.rb   |  31 +-
 .../ruby/shared/rubygems/commands/push_command.rb  |  13 +-
 .../ruby/shared/rubygems/commands/query_command.rb |  50 +-
 .../shared/rubygems/commands/search_command.rb     |  16 +-
 .../ruby/shared/rubygems/commands/setup_command.rb |  18 +-
 .../rubygems/commands/specification_command.rb     |   2 +-
 .../shared/rubygems/commands/uninstall_command.rb  |  16 +-
 .../shared/rubygems/commands/unpack_command.rb     |   2 +-
 .../shared/rubygems/commands/update_command.rb     |  39 +-
 .../ruby/shared/rubygems/commands/which_command.rb |  13 +-
 .../ruby/shared/rubygems/commands/yank_command.rb  |  23 +-
 jruby/lib/ruby/shared/rubygems/compatibility.rb    |  10 +-
 jruby/lib/ruby/shared/rubygems/config_file.rb      |  22 +-
 .../ruby/shared/rubygems/core_ext/kernel_gem.rb    |  24 +-
 .../shared/rubygems/core_ext/kernel_require.rb     |  36 +-
 jruby/lib/ruby/shared/rubygems/defaults.rb         |  63 +-
 jruby/lib/ruby/shared/rubygems/dependency.rb       |  59 +-
 .../ruby/shared/rubygems/dependency_installer.rb   | 113 ++-
 jruby/lib/ruby/shared/rubygems/dependency_list.rb  |   6 +-
 .../ruby/shared/rubygems/dependency_resolver.rb    | 254 -------
 .../dependency_resolver/activation_request.rb      | 109 ---
 .../shared/rubygems/dependency_resolver/api_set.rb |  65 --
 .../dependency_resolver/api_specification.rb       |  39 -
 .../rubygems/dependency_resolver/composed_set.rb   |  18 -
 .../rubygems/dependency_resolver/current_set.rb    |  16 -
 .../dependency_resolver/dependency_conflict.rb     |  85 ---
 .../dependency_resolver/dependency_request.rb      |  51 --
 .../rubygems/dependency_resolver/index_set.rb      |  64 --
 .../dependency_resolver/index_specification.rb     |  60 --
 .../dependency_resolver/installed_specification.rb |  42 --
 .../rubygems/dependency_resolver/installer_set.rb  | 154 ----
 jruby/lib/ruby/shared/rubygems/deprecate.rb        |   2 +-
 jruby/lib/ruby/shared/rubygems/doctor.rb           |  28 +-
 jruby/lib/ruby/shared/rubygems/errors.rb           |  54 +-
 jruby/lib/ruby/shared/rubygems/exceptions.rb       |  94 ++-
 jruby/lib/ruby/shared/rubygems/ext.rb              |   3 +-
 jruby/lib/ruby/shared/rubygems/ext/build_error.rb  |   6 +
 jruby/lib/ruby/shared/rubygems/ext/builder.rb      |  69 +-
 .../lib/ruby/shared/rubygems/ext/cmake_builder.rb  |   4 +-
 .../ruby/shared/rubygems/ext/configure_builder.rb  |   4 +-
 .../ruby/shared/rubygems/ext/ext_conf_builder.rb   |  42 +-
 jruby/lib/ruby/shared/rubygems/ext/rake_builder.rb |   7 +-
 .../ruby/shared/rubygems/gemcutter_utilities.rb    |  11 +-
 jruby/lib/ruby/shared/rubygems/indexer.rb          |   2 +-
 .../ruby/shared/rubygems/install_update_options.rb |  17 +
 jruby/lib/ruby/shared/rubygems/installer.rb        | 102 ++-
 .../ruby/shared/rubygems/installer_test_case.rb    |   7 +-
 .../ruby/shared/rubygems/local_remote_options.rb   |   4 +-
 jruby/lib/ruby/shared/rubygems/name_tuple.rb       |   6 +-
 jruby/lib/ruby/shared/rubygems/package.rb          |  57 +-
 .../ruby/shared/rubygems/package/file_source.rb    |  33 +
 .../lib/ruby/shared/rubygems/package/io_source.rb  |  45 ++
 jruby/lib/ruby/shared/rubygems/package/old.rb      |  14 +-
 jruby/lib/ruby/shared/rubygems/package/source.rb   |   3 +
 .../lib/ruby/shared/rubygems/package/tar_header.rb |   2 +-
 .../shared/rubygems/package/tar_reader/entry.rb    |   2 +
 .../lib/ruby/shared/rubygems/package/tar_writer.rb |  12 +-
 jruby/lib/ruby/shared/rubygems/path_support.rb     |   7 -
 jruby/lib/ruby/shared/rubygems/platform.rb         |  13 +-
 jruby/lib/ruby/shared/rubygems/psych_additions.rb  |   4 +-
 jruby/lib/ruby/shared/rubygems/rdoc.rb             |   7 +-
 jruby/lib/ruby/shared/rubygems/remote_fetcher.rb   | 127 +++-
 jruby/lib/ruby/shared/rubygems/request.rb          | 170 ++---
 .../shared/rubygems/request/connection_pools.rb    |  83 +++
 .../lib/ruby/shared/rubygems/request/http_pool.rb  |  47 ++
 .../lib/ruby/shared/rubygems/request/https_pool.rb |  10 +
 jruby/lib/ruby/shared/rubygems/request_set.rb      | 350 +++++++--
 .../rubygems/request_set/gem_dependency_api.rb     | 784 ++++++++++++++++++++-
 .../ruby/shared/rubygems/request_set/lockfile.rb   | 238 +++++++
 .../shared/rubygems/request_set/lockfile/parser.rb | 334 +++++++++
 .../rubygems/request_set/lockfile/tokenizer.rb     | 108 +++
 jruby/lib/ruby/shared/rubygems/requirement.rb      | 104 ++-
 jruby/lib/ruby/shared/rubygems/resolver.rb         | 485 +++++++++++++
 .../shared/rubygems/resolver/activation_request.rb | 172 +++++
 jruby/lib/ruby/shared/rubygems/resolver/api_set.rb | 125 ++++
 .../shared/rubygems/resolver/api_specification.rb  |  85 +++
 .../lib/ruby/shared/rubygems/resolver/best_set.rb  |  78 ++
 .../ruby/shared/rubygems/resolver/composed_set.rb  |  66 ++
 .../lib/ruby/shared/rubygems/resolver/conflict.rb  | 160 +++++
 .../ruby/shared/rubygems/resolver/current_set.rb   |  13 +
 .../shared/rubygems/resolver/dependency_request.rb | 116 +++
 jruby/lib/ruby/shared/rubygems/resolver/git_set.rb | 122 ++++
 .../shared/rubygems/resolver/git_specification.rb  |  59 ++
 .../lib/ruby/shared/rubygems/resolver/index_set.rb |  80 +++
 .../rubygems/resolver/index_specification.rb       |  69 ++
 .../rubygems/resolver/installed_specification.rb   |  58 ++
 .../ruby/shared/rubygems/resolver/installer_set.rb | 224 ++++++
 .../rubygems/resolver/local_specification.rb       |  41 ++
 .../lib/ruby/shared/rubygems/resolver/lock_set.rb  |  84 +++
 .../shared/rubygems/resolver/lock_specification.rb |  84 +++
 .../shared/rubygems/resolver/requirement_list.rb   |  81 +++
 jruby/lib/ruby/shared/rubygems/resolver/set.rb     |  56 ++
 .../shared/rubygems/resolver/spec_specification.rb |  56 ++
 .../ruby/shared/rubygems/resolver/specification.rb | 110 +++
 jruby/lib/ruby/shared/rubygems/resolver/stats.rb   |  44 ++
 .../ruby/shared/rubygems/resolver/vendor_set.rb    |  87 +++
 .../rubygems/resolver/vendor_specification.rb      |  24 +
 jruby/lib/ruby/shared/rubygems/security.rb         |   6 +-
 jruby/lib/ruby/shared/rubygems/security/policy.rb  |   1 +
 jruby/lib/ruby/shared/rubygems/security/signer.rb  |   2 +-
 .../lib/ruby/shared/rubygems/security/trust_dir.rb |  18 +-
 jruby/lib/ruby/shared/rubygems/server.rb           |  55 +-
 jruby/lib/ruby/shared/rubygems/source.rb           | 112 ++-
 jruby/lib/ruby/shared/rubygems/source/git.rb       | 240 +++++++
 jruby/lib/ruby/shared/rubygems/source/installed.rb |  14 +-
 jruby/lib/ruby/shared/rubygems/source/local.rb     |  22 +-
 jruby/lib/ruby/shared/rubygems/source/lock.rb      |  48 ++
 .../ruby/shared/rubygems/source/specific_file.rb   |  24 +-
 jruby/lib/ruby/shared/rubygems/source/vendor.rb    |  27 +
 jruby/lib/ruby/shared/rubygems/source_list.rb      |  86 ++-
 jruby/lib/ruby/shared/rubygems/spec_fetcher.rb     |  66 +-
 jruby/lib/ruby/shared/rubygems/specification.rb    | 546 +++++++++-----
 .../ssl_certs/AddTrustExternalCARoot-2048.pem      |  25 +
 .../rubygems/ssl_certs/AddTrustExternalCARoot.pem  | 118 +---
 .../ssl_certs/DigiCertHighAssuranceEVRootCA.pem    |  23 +
 .../lib/ruby/shared/rubygems/stub_specification.rb |  82 ++-
 jruby/lib/ruby/shared/rubygems/syck_hack.rb        |   6 +-
 jruby/lib/ruby/shared/rubygems/test_case.rb        | 393 +++++++++--
 jruby/lib/ruby/shared/rubygems/test_utilities.rb   | 200 ++++++
 jruby/lib/ruby/shared/rubygems/text.rb             |  20 +-
 jruby/lib/ruby/shared/rubygems/uninstaller.rb      |  39 +-
 jruby/lib/ruby/shared/rubygems/uri_formatter.rb    |  20 +
 jruby/lib/ruby/shared/rubygems/user_interaction.rb | 291 +++++---
 jruby/lib/ruby/shared/rubygems/util.rb             | 134 ++++
 jruby/lib/ruby/shared/rubygems/util/list.rb        |   4 +
 jruby/lib/ruby/shared/rubygems/util/stringio.rb    |  34 +
 jruby/lib/ruby/shared/rubygems/validator.rb        |   8 +-
 jruby/lib/ruby/shared/rubygems/version.rb          |  46 +-
 147 files changed, 8558 insertions(+), 2260 deletions(-)
 create mode 100644 jruby/lib/ruby/shared/rubygems/commands/open_command.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/activation_request.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/api_set.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/api_specification.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/composed_set.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/current_set.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_conflict.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_request.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/index_set.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/index_specification.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/installed_specification.rb
 delete mode 100644 jruby/lib/ruby/shared/rubygems/dependency_resolver/installer_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/ext/build_error.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/package/file_source.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/package/io_source.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/package/source.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/request/connection_pools.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/request/http_pool.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/request/https_pool.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/request_set/lockfile.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/request_set/lockfile/parser.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/request_set/lockfile/tokenizer.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/activation_request.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/api_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/api_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/best_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/composed_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/conflict.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/current_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/dependency_request.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/git_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/git_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/index_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/index_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/installed_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/installer_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/local_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/lock_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/lock_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/requirement_list.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/spec_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/stats.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/vendor_set.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/resolver/vendor_specification.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/source/git.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/source/lock.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/source/vendor.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot-2048.pem
 create mode 100644 jruby/lib/ruby/shared/rubygems/ssl_certs/DigiCertHighAssuranceEVRootCA.pem
 create mode 100644 jruby/lib/ruby/shared/rubygems/util.rb
 create mode 100644 jruby/lib/ruby/shared/rubygems/util/stringio.rb

diff --git a/jruby/lib/ruby/shared/gauntlet_rubygems.rb b/jruby/lib/ruby/shared/gauntlet_rubygems.rb
index f6c4827..246c920 100644
--- a/jruby/lib/ruby/shared/gauntlet_rubygems.rb
+++ b/jruby/lib/ruby/shared/gauntlet_rubygems.rb
@@ -16,7 +16,7 @@ require 'gauntlet'
 # rvsh-0.4.5           : No such file or directory - bin/rvsh
 # xen-0.1.2.1          : authors must be Array of Strings
 
-class GemGauntlet < Gauntlet
+class GemGauntlet < Gauntlet # :nodoc:
   def run(name)
     warn name
 
diff --git a/jruby/lib/ruby/shared/rubygems.rb b/jruby/lib/ruby/shared/rubygems.rb
index 8298421..f3d1de5 100644
--- a/jruby/lib/ruby/shared/rubygems.rb
+++ b/jruby/lib/ruby/shared/rubygems.rb
@@ -6,9 +6,10 @@
 #++
 
 require 'rbconfig'
+require 'thread'
 
 module Gem
-  VERSION = '2.1.9'
+  VERSION = '2.4.8'
 end
 
 # Must be first since it unloads the prelude from 1.9.2
@@ -56,8 +57,8 @@ require 'rubygems/errors'
 # RubyGems defaults are stored in rubygems/defaults.rb.  If you're packaging
 # RubyGems or implementing Ruby you can change RubyGems' defaults.
 #
-# For RubyGems packagers, provide lib/rubygems/operating_system.rb and
-# override any defaults from lib/rubygems/defaults.rb.
+# For RubyGems packagers, provide lib/rubygems/defaults/operating_system.rb
+# and override any defaults from lib/rubygems/defaults.rb.
 #
 # For Ruby implementers, provide lib/rubygems/defaults/#{RUBY_ENGINE}.rb and
 # override any defaults from lib/rubygems/defaults.rb.
@@ -83,7 +84,7 @@ require 'rubygems/errors'
 # * Chad Fowler  -- chad(at)chadfowler.com
 # * David Black  -- dblack(at)wobblini.net
 # * Paul Brannan -- paul(at)atdesk.com
-# * Jim Weirch   -- jim(at)weirichhouse.org
+# * Jim Weirich   -- jim(at)weirichhouse.org
 #
 # Contributors:
 #
@@ -139,6 +140,7 @@ module Gem
     build_info
     cache
     doc
+    extensions
     gems
     specifications
   ]
@@ -155,9 +157,11 @@ module Gem
 
   @configuration = nil
   @loaded_specs = {}
+  LOADED_SPECS_MUTEX = Mutex.new
   @path_to_default_spec_map = {}
   @platforms = []
   @ruby = nil
+  @ruby_api_version = nil
   @sources = nil
 
   @post_build_hooks     ||= []
@@ -176,8 +180,8 @@ module Gem
   def self.try_activate path
     # finds the _latest_ version... regardless of loaded specs and their deps
     # if another gem had a requirement that would mean we shouldn't
-    # activate the latest version, then either it would alreaby be activated
-    # or if it was ambigious (and thus unresolved) the code in our custom
+    # activate the latest version, then either it would already be activated
+    # or if it was ambiguous (and thus unresolved) the code in our custom
     # require will try to activate the more specific version.
 
     spec = Gem::Specification.find_inactive_by_path path
@@ -213,50 +217,6 @@ module Gem
     end
   end
 
-  def self.detect_gemdeps
-    if path = ENV['RUBYGEMS_GEMDEPS']
-      path = path.dup.untaint
-
-      if path == "-"
-        here = Dir.pwd.untaint
-        start = here
-
-        begin
-          while true
-            path = GEM_DEP_FILES.find { |f| File.file?(f) }
-
-            if path
-              path = File.join here, path
-              break
-            end
-
-            Dir.chdir ".."
-
-            # If we're at a toplevel, stop.
-            return if Dir.pwd == here
-
-            here = Dir.pwd
-          end
-        ensure
-          Dir.chdir start
-        end
-      end
-
-      path.untaint
-
-      return unless File.file? path
-
-      rs = Gem::RequestSet.new
-      rs.load_gemdeps path
-
-      rs.resolve_current.map do |s|
-        sp = s.full_spec
-        sp.activate
-        sp
-      end
-    end
-  end
-
   ##
   # Find the full path to the executable for gem +name+.  If the +exec_name+
   # is not given, the gem's default_executable is chosen, otherwise the
@@ -272,7 +232,13 @@ module Gem
     requirements = Gem::Requirement.default if
       requirements.empty?
 
-    specs = Gem::Dependency.new(name, requirements).matching_specs(true)
+    dep = Gem::Dependency.new name, requirements
+
+    loaded = Gem.loaded_specs[name]
+
+    return loaded.bin_file exec_name if loaded && dep.matches_spec?(loaded)
+
+    specs = dep.matching_specs(true)
 
     raise Gem::GemNotFoundException,
           "can't find gem #{name} (#{requirements})" if specs.empty?
@@ -300,7 +266,6 @@ module Gem
   # The path where gem executables are to be installed.
 
   def self.bindir(install_dir=Gem.dir)
-    # TODO: move to Gem::Dirs
     return File.join install_dir, 'bin' unless
       install_dir.to_s == Gem.default_dir.to_s
     Gem.default_bindir
@@ -341,7 +306,7 @@ module Gem
   end
 
   ##
-  # The path the the data directory specified by the gem name.  If the
+  # The path to the data directory specified by the gem name.  If the
   # package is not available as a gem, return nil.
 
   def self.datadir(gem_name)
@@ -360,16 +325,21 @@ module Gem
     Zlib::Deflate.deflate data
   end
 
-  # DOC: needs doc'd or :nodoc'd
+  # Retrieve the PathSupport object that RubyGems uses to
+  # lookup files.
+
   def self.paths
     @paths ||= Gem::PathSupport.new
   end
 
-  # DOC: needs doc'd or :nodoc'd
+  # Initialize the filesystem paths to use from +env+.
+  # +env+ is a hash-like object (typically ENV) that
+  # is queried for 'GEM_HOME', 'GEM_PATH', and 'GEM_SPEC_CACHE'
+
   def self.paths=(env)
     clear_paths
     @paths = Gem::PathSupport.new env
-    Gem::Specification.dirs = @paths.path # FIX: home is at end
+    Gem::Specification.dirs = @paths.path
   end
 
   ##
@@ -378,12 +348,10 @@ module Gem
   # FIXME deprecate these once everything else has been done -ebh
 
   def self.dir
-    # TODO: raise "no"
     paths.home
   end
 
   def self.path
-    # TODO: raise "no"
     paths.path
   end
 
@@ -437,6 +405,18 @@ module Gem
   end
 
   ##
+  # The extension API version of ruby.  This includes the static vs non-static
+  # distinction as extensions cannot be shared between the two.
+
+  def self.extension_api_version # :nodoc:
+    if 'no' == RbConfig::CONFIG['ENABLE_SHARED'] then
+      "#{ruby_api_version}-static"
+    else
+      ruby_api_version
+    end
+  end
+
+  ##
   # Returns a list of paths matching +glob+ that can be used by a gem to pick
   # up features from other gems.  For example:
   #
@@ -538,42 +518,30 @@ module Gem
 
   private_class_method :find_home
 
+  # FIXME deprecate these in 3.0
+
   ##
   # Zlib::GzipReader wrapper that unzips +data+.
 
   def self.gunzip(data)
-    # TODO: move to utils
-    require 'stringio'
-    require 'zlib'
-    data = StringIO.new data
-
-    unzipped = Zlib::GzipReader.new(data).read
-    unzipped.force_encoding Encoding::BINARY if Object.const_defined? :Encoding
-    unzipped
+    require 'rubygems/util'
+    Gem::Util.gunzip data
   end
 
   ##
   # Zlib::GzipWriter wrapper that zips +data+.
 
   def self.gzip(data)
-    # TODO: move to utils
-    require 'stringio'
-    require 'zlib'
-    zipped = StringIO.new
-    zipped.set_encoding Encoding::BINARY if Object.const_defined? :Encoding
-
-    Zlib::GzipWriter.wrap zipped do |io| io.write data end
-
-    zipped.string
+    require 'rubygems/util'
+    Gem::Util.gzip data
   end
 
   ##
   # A Zlib::Inflate#inflate wrapper
 
   def self.inflate(data)
-    # TODO: move to utils
-    require 'zlib'
-    Zlib::Inflate.inflate data
+    require 'rubygems/util'
+    Gem::Util.inflate data
   end
 
   ##
@@ -584,9 +552,9 @@ module Gem
   #   Fetching: minitest-3.0.1.gem (100%)
   #   => [#<Gem::Specification:0x1013b4528 @name="minitest", ...>]
 
-  def self.install name, version = Gem::Requirement.default
+  def self.install name, version = Gem::Requirement.default, *options
     require "rubygems/dependency_installer"
-    inst = Gem::DependencyInstaller.new
+    inst = Gem::DependencyInstaller.new(*options)
     inst.install name, version
     inst.installed_gems
   end
@@ -608,14 +576,11 @@ module Gem
   end
 
   ##
-  # The index to insert activated gem paths into the $LOAD_PATH.
-  #
-  # Defaults to the site lib directory unless gem_prelude.rb has loaded paths,
-  # then it inserts the activated gem's paths before the gem_prelude.rb paths
-  # so you can override the gem_prelude.rb default $LOAD_PATH paths.
+  # The index to insert activated gem paths into the $LOAD_PATH. The activated
+  # gem's paths are inserted before site lib directory by default.
 
   def self.load_path_insert_index
-    index = $LOAD_PATH.index ConfigMap[:sitelibdir]
+    index = $LOAD_PATH.index RbConfig::CONFIG['sitelibdir']
 
     index
   end
@@ -633,7 +598,7 @@ module Gem
 
     unless test_syck
       begin
-        gem 'psych', '~> 1.2', '>= 1.2.1'
+        gem 'psych', '>= 1.2.1'
       rescue Gem::LoadError
         # It's OK if the user does not have the psych gem installed.  We will
         # attempt to require the stdlib version
@@ -679,7 +644,6 @@ module Gem
     file = $1
     lineno = $2.to_i
 
-    # TODO: it is ALWAYS joined! STUPID!
     [file, lineno]
   end
 
@@ -787,8 +751,8 @@ module Gem
   def self.prefix
     prefix = File.dirname RUBYGEMS_DIR
 
-    if prefix != File.expand_path(ConfigMap[:sitelibdir]) and
-       prefix != File.expand_path(ConfigMap[:libdir]) and
+    if prefix != File.expand_path(RbConfig::CONFIG['sitelibdir']) and
+       prefix != File.expand_path(RbConfig::CONFIG['libdir']) and
        'lib' == File.basename(RUBYGEMS_DIR) then
       prefix
     end
@@ -805,7 +769,14 @@ module Gem
   # Safely read a file in binary mode on all platforms.
 
   def self.read_binary(path)
-    File.open path, binary_mode do |f| f.read end
+    open path, 'rb+' do |f|
+      f.flock(File::LOCK_EX)
+      f.read
+    end
+  rescue Errno::EACCES
+    open path, 'rb' do |f|
+      f.read
+    end
   end
 
   ##
@@ -813,8 +784,8 @@ module Gem
 
   def self.ruby
     if @ruby.nil? then
-      @ruby = File.join(ConfigMap[:bindir],
-                        "#{ConfigMap[:ruby_install_name]}#{ConfigMap[:EXEEXT]}")
+      @ruby = File.join(RbConfig::CONFIG['bindir'],
+                        "#{RbConfig::CONFIG['ruby_install_name']}#{RbConfig::CONFIG['EXEEXT']}")
 
       @ruby = "\"#{@ruby}\"" if @ruby =~ /\s/
     end
@@ -823,6 +794,13 @@ module Gem
   end
 
   ##
+  # Returns a String containing the API compatibility version of Ruby
+
+  def self.ruby_api_version
+    @ruby_api_version ||= RbConfig::CONFIG['ruby_version'].dup
+  end
+
+  ##
   # Returns the latest release-version specification for the gem +name+.
 
   def self.latest_spec_for name
@@ -952,7 +930,6 @@ module Gem
     paths = nil if paths == [nil]
     paths = paths.first if Array === Array(paths).first
     self.paths = { "GEM_HOME" => home, "GEM_PATH" => paths }
-    # TODO: self.paths = home, paths
   end
 
   ##
@@ -1025,6 +1002,76 @@ module Gem
     load_plugin_files files
   end
 
+  ##
+  # Looks for a gem dependency file at +path+ and activates the gems in the
+  # file if found.  If the file is not found an ArgumentError is raised.
+  #
+  # If +path+ is not given the RUBYGEMS_GEMDEPS environment variable is used,
+  # but if no file is found no exception is raised.
+  #
+  # If '-' is given for +path+ RubyGems searches up from the current working
+  # directory for gem dependency files (gem.deps.rb, Gemfile, Isolate) and
+  # activates the gems in the first one found.
+  #
+  # You can run this automatically when rubygems starts.  To enable, set
+  # the <code>RUBYGEMS_GEMDEPS</code> environment variable to either the path
+  # of your gem dependencies file or "-" to auto-discover in parent
+  # directories.
+  #
+  # NOTE: Enabling automatic discovery on multiuser systems can lead to
+  # execution of arbitrary code when used from directories outside your
+  # control.
+
+  def self.use_gemdeps path = nil
+    raise_exception = path
+
+    path ||= ENV['RUBYGEMS_GEMDEPS']
+    return unless path
+
+    path = path.dup
+
+    if path == "-" then
+      require 'rubygems/util'
+
+      Gem::Util.traverse_parents Dir.pwd do |directory|
+        dep_file = GEM_DEP_FILES.find { |f| File.file?(f) }
+
+        next unless dep_file
+
+        path = File.join directory, dep_file
+        break
+      end
+    end
+
+    path.untaint
+
+    unless File.file? path then
+      return unless raise_exception
+
+      raise ArgumentError, "Unable to find gem dependencies file at #{path}"
+    end
+
+    rs = Gem::RequestSet.new
+    rs.load_gemdeps path
+
+    rs.resolve_current.map do |s|
+      sp = s.full_spec
+      sp.activate
+      sp
+    end
+  rescue Gem::LoadError, Gem::UnsatisfiableDependencyError => e
+    warn e.message
+    warn "You may need to `gem install -g` to install missing gems"
+    warn ""
+  end
+
+  class << self
+    ##
+    # TODO remove with RubyGems 3.0
+
+    alias detect_gemdeps use_gemdeps # :nodoc:
+  end
+
   # FIX: Almost everywhere else we use the `def self.` way of defining class
   # methods, and then we switch over to `class << self` here. Pick one or the
   # other.
@@ -1087,7 +1134,7 @@ module Gem
     end
 
     ##
-    # Clear default gem related varibles. It is for test
+    # Clear default gem related variables. It is for test
 
     def clear_default_specs
       @path_to_default_spec_map.clear
@@ -1147,16 +1194,18 @@ module Gem
   autoload :ConfigFile,         'rubygems/config_file'
   autoload :Dependency,         'rubygems/dependency'
   autoload :DependencyList,     'rubygems/dependency_list'
-  autoload :DependencyResolver, 'rubygems/dependency_resolver'
+  autoload :DependencyResolver, 'rubygems/resolver'
+  autoload :Installer,          'rubygems/installer'
   autoload :PathSupport,        'rubygems/path_support'
   autoload :Platform,           'rubygems/platform'
   autoload :RequestSet,         'rubygems/request_set'
   autoload :Requirement,        'rubygems/requirement'
+  autoload :Resolver,           'rubygems/resolver'
+  autoload :Source,             'rubygems/source'
   autoload :SourceList,         'rubygems/source_list'
   autoload :SpecFetcher,        'rubygems/spec_fetcher'
   autoload :Specification,      'rubygems/specification'
   autoload :Version,            'rubygems/version'
-  autoload :Source,             'rubygems/source'
 
   require "rubygems/specification"
 end
@@ -1192,4 +1241,5 @@ Gem::Specification.load_defaults
 require 'rubygems/core_ext/kernel_gem'
 require 'rubygems/core_ext/kernel_require'
 
-Gem.detect_gemdeps
+Gem.use_gemdeps
+
diff --git a/jruby/lib/ruby/shared/rubygems/available_set.rb b/jruby/lib/ruby/shared/rubygems/available_set.rb
index bb0b3a3..dae254b 100644
--- a/jruby/lib/ruby/shared/rubygems/available_set.rb
+++ b/jruby/lib/ruby/shared/rubygems/available_set.rb
@@ -4,9 +4,12 @@ class Gem::AvailableSet
 
   Tuple = Struct.new(:spec, :source)
 
+  attr_accessor :remote # :nodoc:
+
   def initialize
     @set = []
     @sorted = nil
+    @remote = true
   end
 
   attr_reader :set
@@ -116,18 +119,18 @@ class Gem::AvailableSet
 
   ##
   #
-  # Used by the DependencyResolver, the protocol to use a AvailableSet as a
+  # Used by the Resolver, the protocol to use a AvailableSet as a
   # search Set.
 
   def find_all(req)
     dep = req.dependency
 
     match = @set.find_all do |t|
-      dep.matches_spec? t.spec
+      dep.match? t.spec
     end
 
     match.map do |t|
-      Gem::DependencyResolver::InstalledSpecification.new(self, t.spec, t.source)
+      Gem::Resolver::LocalSpecification.new(self, t.spec, t.source)
     end
   end
 
diff --git a/jruby/lib/ruby/shared/rubygems/basic_specification.rb b/jruby/lib/ruby/shared/rubygems/basic_specification.rb
index 24bb4bc..e27b261 100644
--- a/jruby/lib/ruby/shared/rubygems/basic_specification.rb
+++ b/jruby/lib/ruby/shared/rubygems/basic_specification.rb
@@ -5,10 +5,30 @@
 class Gem::BasicSpecification
 
   ##
+  # Allows installation of extensions for git: gems.
+
+  attr_writer :base_dir # :nodoc:
+
+  ##
+  # Sets the directory where extensions for this gem will be installed.
+
+  attr_writer :extension_dir # :nodoc:
+
+  ##
+  # Is this specification ignored for activation purposes?
+
+  attr_writer :ignored # :nodoc:
+
+  ##
   # The path this gemspec was loaded from.  This attribute is not persisted.
 
   attr_reader :loaded_from
 
+  ##
+  # Allows correct activation of git: and path: gems.
+
+  attr_writer :full_gem_path # :nodoc:
+
   def self.default_specifications_dir
     File.join(Gem.default_dir, "specifications", "default")
   end
@@ -38,13 +58,27 @@ class Gem::BasicSpecification
   # Return true if this spec can require +file+.
 
   def contains_requirable_file? file
-    root     = full_gem_path
-    suffixes = Gem.suffixes
-
-    require_paths.any? do |lib|
-      base = "#{root}/#{lib}/#{file}"
-      suffixes.any? { |suf| File.file? "#{base}#{suf}" }
-    end
+    @contains_requirable_file ||= {}
+    @contains_requirable_file[file] ||=
+    begin
+      if instance_variable_defined?(:@ignored) then
+        return false
+      elsif missing_extensions? then
+        @ignored = true
+
+        warn "Ignoring #{full_name} because its extensions are not built.  " +
+             "Try: gem pristine #{name} --version #{version}"
+        return false
+      end
+
+      suffixes = Gem.suffixes
+
+      full_require_paths.any? do |dir|
+        base = "#{dir}/#{file}"
+        suffixes.any? { |suf| File.file? "#{base}#{suf}" }
+      end
+    end ? :yes : :no
+    @contains_requirable_file[file] == :yes
   end
 
   def default_gem?
@@ -52,6 +86,22 @@ class Gem::BasicSpecification
       File.dirname(loaded_from) == self.class.default_specifications_dir
   end
 
+  ##
+  # Returns full path to the directory where gem's extensions are installed.
+
+  def extension_dir
+    @extension_dir ||= File.expand_path File.join(extensions_dir, full_name)
+  end
+
+  ##
+  # Returns path to the extensions directory.
+
+  def extensions_dir
+    @extensions_dir ||= Gem.default_ext_dir_for(base_dir) ||
+      File.join(base_dir, 'extensions', Gem::Platform.local.to_s,
+                Gem.extension_api_version)
+  end
+
   def find_full_gem_path # :nodoc:
     # TODO: also, shouldn't it default to full_name if it hasn't been written?
     path = File.expand_path File.join(gems_dir, full_name)
@@ -84,6 +134,53 @@ class Gem::BasicSpecification
   end
 
   ##
+  # Full paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
+  # activated.
+
+  def full_require_paths
+    @full_require_paths ||=
+    begin
+      full_paths = raw_require_paths.map do |path|
+        File.join full_gem_path, path
+      end
+
+      full_paths << extension_dir unless @extensions.nil? || @extensions.empty?
+
+      full_paths
+    end
+  end
+
+  ##
+  # Full path of the target library file.
+  # If the file is not in this gem, return nil.
+
+  def to_fullpath path
+    if activated? then
+      @paths_map ||= {}
+      @paths_map[path] ||=
+      begin
+        fullpath = nil
+        suffixes = Gem.suffixes
+        full_require_paths.find do |dir|
+          suffixes.find do |suf|
+            File.file?(fullpath = "#{dir}/#{path}#{suf}")
+          end
+        end ? fullpath : nil
+      end
+    else
+      nil
+    end
+  end
+
+  ##
+  # Returns the full path to this spec's gem directory.
+  # eg: /usr/local/lib/ruby/1.8/gems/mygem-1.0
+
+  def gem_dir
+    @gem_dir ||= File.expand_path File.join(gems_dir, full_name)
+  end
+
+  ##
   # Returns the full path to the gems directory containing this spec's
   # gem directory. eg: /usr/local/lib/ruby/1.8/gems
 
@@ -99,9 +196,12 @@ class Gem::BasicSpecification
   def loaded_from= path
     @loaded_from   = path && path.to_s
 
-    @full_gem_path = nil
-    @gems_dir      = nil
-    @base_dir      = nil
+    @extension_dir = nil
+    @extensions_dir = nil
+    @full_gem_path         = nil
+    @gem_dir               = nil
+    @gems_dir              = nil
+    @base_dir              = nil
   end
 
   ##
@@ -118,11 +218,49 @@ class Gem::BasicSpecification
     raise NotImplementedError
   end
 
+  def raw_require_paths # :nodoc:
+    Array(@require_paths)
+  end
+
   ##
-  # Require paths of the gem
+  # Paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
+  # activated.
+  #
+  # See also #require_paths=
+  #
+  # If you have an extension you do not need to add <code>"ext"</code> to the
+  # require path, the extension build process will copy the extension files
+  # into "lib" for you.
+  #
+  # The default value is <code>"lib"</code>
+  #
+  # Usage:
+  #
+  #   # If all library files are in the root directory...
+  #   spec.require_path = '.'
 
   def require_paths
-    raise NotImplementedError
+    return raw_require_paths if @extensions.nil? || @extensions.empty?
+
+    [extension_dir].concat raw_require_paths
+  end
+
+  ##
+  # Returns the paths to the source files for use with analysis and
+  # documentation tools.  These paths are relative to full_gem_path.
+
+  def source_paths
+    paths = raw_require_paths.dup
+
+    if @extensions then
+      ext_dirs = @extensions.map do |extension|
+        extension.split(File::SEPARATOR, 2).first
+      end.uniq
+
+      paths.concat ext_dirs
+    end
+
+    paths.uniq
   end
 
   ##
@@ -139,5 +277,13 @@ class Gem::BasicSpecification
     raise NotImplementedError
   end
 
+  ##
+  # Whether this specification is stubbed - i.e. we have information
+  # about the gem from a stub line, without having to evaluate the
+  # entire gemspec file.
+  def stubbed?
+    raise NotImplementedError
+  end
+
 end
 
diff --git a/jruby/lib/ruby/shared/rubygems/command.rb b/jruby/lib/ruby/shared/rubygems/command.rb
index cba79b9..0c6abec 100644
--- a/jruby/lib/ruby/shared/rubygems/command.rb
+++ b/jruby/lib/ruby/shared/rubygems/command.rb
@@ -148,6 +148,8 @@ class Gem::Command
 
   ##
   # Display to the user that a gem couldn't be found and reasons why
+  #--
+  # TODO: replace +domain+ with a parameter to suppress suggestions
 
   def show_lookup_failure(gem_name, version, errors, domain)
     if errors and !errors.empty?
@@ -557,7 +559,8 @@ basic help message containing pointers to more information.
   Further help:
     gem help commands            list all 'gem' commands
     gem help examples            show some examples of usage
-    gem help platforms           show information about platforms
+    gem help gem_dependencies    gem dependencies file guide
+    gem help platforms           gem platforms guide
     gem help <COMMAND>           show help on COMMAND
                                    (e.g. 'gem help install')
     gem server                   present a web page at
diff --git a/jruby/lib/ruby/shared/rubygems/command_manager.rb b/jruby/lib/ruby/shared/rubygems/command_manager.rb
index fdee064..53d18c2 100644
--- a/jruby/lib/ruby/shared/rubygems/command_manager.rb
+++ b/jruby/lib/ruby/shared/rubygems/command_manager.rb
@@ -48,6 +48,7 @@ class Gem::CommandManager
     :list,
     :lock,
     :mirror,
+    :open,
     :outdated,
     :owner,
     :pristine,
@@ -136,7 +137,7 @@ class Gem::CommandManager
   def run(args, build_args=nil)
     process_args(args, build_args)
   rescue StandardError, Timeout::Error => ex
-    alert_error "While executing gem ... (#{ex.class})\n    #{ex.to_s}"
+    alert_error "While executing gem ... (#{ex.class})\n    #{ex}"
     ui.backtrace ex
 
     terminate_interaction(1)
diff --git a/jruby/lib/ruby/shared/rubygems/commands/cert_command.rb b/jruby/lib/ruby/shared/rubygems/commands/cert_command.rb
index e417193..a920e7f 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/cert_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/cert_command.rb
@@ -129,23 +129,21 @@ class Gem::Commands::CertCommand < Gem::Command
   end
 
   def build_key # :nodoc:
-    if options[:key] then
-      options[:key]
-    else
-      passphrase = ask_for_password 'Passphrase for your Private Key:'
-      say "\n"
+    return options[:key] if options[:key]
 
-      passphrase_confirmation = ask_for_password 'Please repeat the passphrase for your Private Key:'
-      say "\n"
+    passphrase = ask_for_password 'Passphrase for your Private Key:'
+    say "\n"
 
-      raise Gem::CommandLineError,
-            "Passphrase and passphrase confirmation don't match" unless passphrase == passphrase_confirmation
+    passphrase_confirmation = ask_for_password 'Please repeat the passphrase for your Private Key:'
+    say "\n"
 
-      key      = Gem::Security.create_key
-      key_path = Gem::Security.write key, "gem-private_key.pem", 0600, passphrase
+    raise Gem::CommandLineError,
+          "Passphrase and passphrase confirmation don't match" unless passphrase == passphrase_confirmation
 
-      return key, key_path
-    end
+    key      = Gem::Security.create_key
+    key_path = Gem::Security.write key, "gem-private_key.pem", 0600, passphrase
+
+    return key, key_path
   end
 
   def certificates_matching filter
diff --git a/jruby/lib/ruby/shared/rubygems/commands/cleanup_command.rb b/jruby/lib/ruby/shared/rubygems/commands/cleanup_command.rb
index c8f0082..6997564 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/cleanup_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/cleanup_command.rb
@@ -67,10 +67,10 @@ If no gems are named all gems in GEM_HOME are cleaned.
 
     say "Clean Up Complete"
 
-    if Gem.configuration.really_verbose then
+    verbose do
       skipped = @default_gems.map { |spec| spec.full_name }
 
-      say "Skipped default gems: #{skipped.join ', '}"
+      "Skipped default gems: #{skipped.join ', '}"
     end
   end
 
diff --git a/jruby/lib/ruby/shared/rubygems/commands/contents_command.rb b/jruby/lib/ruby/shared/rubygems/commands/contents_command.rb
index 9721884..4b944f1 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/contents_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/contents_command.rb
@@ -8,7 +8,8 @@ class Gem::Commands::ContentsCommand < Gem::Command
 
   def initialize
     super 'contents', 'Display the contents of the installed gems',
-          :specdirs => [], :lib_only => false, :prefix => true
+          :specdirs => [], :lib_only => false, :prefix => true,
+          :show_install_dir => false
 
     add_version_option
 
@@ -32,6 +33,11 @@ class Gem::Commands::ContentsCommand < Gem::Command
       options[:prefix] = prefix
     end
 
+    add_option(      '--[no-]show-install-dir',
+               'Show only the gem install dir') do |show, options|
+      options[:show_install_dir] = show
+    end
+
     @path_kind = nil
     @spec_dirs = nil
     @version   = nil
@@ -65,7 +71,12 @@ prefix or only the files that are requireable.
     names = gem_names
 
     names.each do |name|
-      found = gem_contents name
+      found =
+        if options[:show_install_dir] then
+          gem_install_dir name
+        else
+          gem_contents name
+        end
 
       terminate_interaction 1 unless found or names.length > 1
     end
@@ -91,14 +102,14 @@ prefix or only the files that are requireable.
   end
 
   def files_in_default_gem spec
-    spec.files.sort.map do |file|
+    spec.files.map do |file|
       case file
       when /\A#{spec.bindir}\//
-        [Gem::ConfigMap[:bindir], $POSTMATCH]
+        [RbConfig::CONFIG['bindir'], $POSTMATCH]
       when /\.so\z/
-        [Gem::ConfigMap[:archdir], file]
+        [RbConfig::CONFIG['archdir'], file]
       else
-        [Gem::ConfigMap[:rubylibdir], file]
+        [RbConfig::CONFIG['rubylibdir'], file]
       end
     end
   end
@@ -115,6 +126,16 @@ prefix or only the files that are requireable.
     true
   end
 
+  def gem_install_dir name
+    spec = spec_for name
+
+    return false unless spec
+
+    say spec.gem_dir
+
+    true
+  end
+
   def gem_names # :nodoc:
     if options[:all] then
       Gem::Specification.map(&:name)
@@ -125,7 +146,6 @@ prefix or only the files that are requireable.
 
   def path_description spec_dirs # :nodoc:
     if spec_dirs.empty? then
-      spec_dirs = Gem::Specification.dirs
       "default gem paths"
     else
       "specified path"
diff --git a/jruby/lib/ruby/shared/rubygems/commands/dependency_command.rb b/jruby/lib/ruby/shared/rubygems/commands/dependency_command.rb
index c5d6dd7..4a54a3e 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/dependency_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/dependency_command.rb
@@ -31,7 +31,7 @@ class Gem::Commands::DependencyCommand < Gem::Command
   end
 
   def arguments # :nodoc:
-    "GEMNAME       name of gem to show dependencies for"
+    "REGEXP        show dependencies for gems whose names start with REGEXP"
   end
 
   def defaults_str # :nodoc:
@@ -50,7 +50,7 @@ use with other commands.
   end
 
   def usage # :nodoc:
-    "#{program_name} GEMNAME"
+    "#{program_name} REGEXP"
   end
 
   def fetch_remote_specs dependency # :nodoc:
diff --git a/jruby/lib/ruby/shared/rubygems/commands/environment_command.rb b/jruby/lib/ruby/shared/rubygems/commands/environment_command.rb
index d32d12b..067d0b1 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/environment_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/environment_command.rb
@@ -28,8 +28,9 @@ The RubyGems environment can be controlled through command line arguments,
 gemrc files, environment variables and built-in defaults.
 
 Command line argument defaults and some RubyGems defaults can be set in a
-~/.gemrc file for individual users and a /etc/gemrc for all users. These
-files are YAML files with the following YAML keys:
+~/.gemrc file for individual users and a gemrc in the SYSTEM CONFIGURATION
+DIRECTORY for all users. These files are YAML files with the following YAML
+keys:
 
   :sources: A YAML array of remote gem repositories to install gems from
   :verbose: Verbosity of the gem command. false, true, and :really are the
@@ -120,6 +121,8 @@ lib/rubygems/defaults/operating_system.rb
 
     out << "  - SPEC CACHE DIRECTORY: #{Gem.spec_cache_dir}\n"
 
+    out << "  - SYSTEM CONFIGURATION DIRECTORY: #{Gem::ConfigFile::SYSTEM_CONFIG_PATH}\n"
+
     out << "  - RUBYGEMS PLATFORMS:\n"
     Gem.platforms.each do |platform|
       out << "    - #{platform}\n"
diff --git a/jruby/lib/ruby/shared/rubygems/commands/generate_index_command.rb b/jruby/lib/ruby/shared/rubygems/commands/generate_index_command.rb
index a7db013..ca6f694 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/generate_index_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/generate_index_command.rb
@@ -62,7 +62,7 @@ Marshal::MINOR_VERSION constants.  It is used to ensure compatibility.
   end
 
   def execute
-    # This is always true becasue it's the only way now.
+    # This is always true because it's the only way now.
     options[:build_modern] = true
 
     if not File.exist?(options[:directory]) or
diff --git a/jruby/lib/ruby/shared/rubygems/commands/help_command.rb b/jruby/lib/ruby/shared/rubygems/commands/help_command.rb
index ed7be90..955ceb9 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/help_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/help_command.rb
@@ -52,6 +52,183 @@ Some examples of 'gem' usage.
     gem update --system
   EOF
 
+  GEM_DEPENDENCIES = <<-EOF
+A gem dependencies file allows installation of a consistent set of gems across
+multiple environments.  The RubyGems implementation is designed to be
+compatible with Bundler's Gemfile format.  You can see additional
+documentation on the format at:
+
+  http://bundler.io
+
+RubyGems automatically looks for these gem dependencies files:
+
+* gem.deps.rb
+* Gemfile
+* Isolate
+
+These files are looked up automatically using `gem install -g`, or you can
+specify a custom file.
+
+When the RUBYGEMS_GEMDEPS environment variable is set to a gem dependencies
+file the gems from that file will be activated at startup time.  Set it to a
+specific filename or to "-" to have RubyGems automatically discover the gem
+dependencies file by walking up from the current directory.
+
+You can also activate gem dependencies at program startup using
+Gem.use_gemdeps.
+
+NOTE: Enabling automatic discovery on multiuser systems can lead to execution
+of arbitrary code when used from directories outside your control.
+
+Gem Dependencies
+================
+
+Use #gem to declare which gems you directly depend upon:
+
+  gem 'rake'
+
+To depend on a specific set of versions:
+
+  gem 'rake', '~> 10.3', '>= 10.3.2'
+
+RubyGems will require the gem name when activating the gem using
+the RUBYGEMS_GEMDEPS environment variable or Gem::use_gemdeps.  Use the
+require: option to override this behavior if the gem does not have a file of
+that name or you don't want to require those files:
+
+  gem 'my_gem', require: 'other_file'
+
+To prevent RubyGems from requiring any files use:
+
+  gem 'my_gem', require: false
+
+To load dependencies from a .gemspec file:
+
+  gemspec
+
+RubyGems looks for the first .gemspec file in the current directory.  To
+override this use the name: option:
+
+  gemspec name: 'specific_gem'
+
+To look in a different directory use the path: option:
+
+  gemspec name: 'specific_gem', path: 'gemspecs'
+
+To depend on a gem unpacked into a local directory:
+
+  gem 'modified_gem', path: 'vendor/modified_gem'
+
+To depend on a gem from git:
+
+  gem 'private_gem', git: 'git@my.company.example:private_gem.git'
+
+To depend on a gem from github:
+
+  gem 'private_gem', github: 'my_company/private_gem'
+
+To depend on a gem from a github gist:
+
+  gem 'bang', gist: '1232884'
+
+Git, github and gist support the ref:, branch: and tag: options to specify a
+commit reference or hash, branch or tag respectively to use for the gem.
+
+Setting the submodules: option to true for git, github and gist dependencies
+causes fetching of submodules when fetching the repository.
+
+You can depend on multiple gems from a single repository with the git method:
+
+  git 'https://github.com/rails/rails.git' do
+    gem 'activesupport'
+    gem 'activerecord'
+  end
+
+Gem Sources
+===========
+
+RubyGems uses the default sources for regular `gem install` for gem
+dependencies files.  Unlike bundler, you do need to specify a source.
+
+You can override the sources used for downloading gems with:
+
+  source 'https://gem_server.example'
+
+You may specify multiple sources.  Unlike bundler the prepend: option is not
+supported. Sources are used in-order, to prepend a source place it at the
+front of the list.
+
+Gem Platform
+============
+
+You can restrict gem dependencies to specific platforms with the #platform
+and #platforms methods:
+
+  platform :ruby_21 do
+    gem 'debugger'
+  end
+
+See the bundler Gemfile manual page for a list of platforms supported in a gem
+dependencies file.:
+
+  http://bundler.io/v1.6/man/gemfile.5.html
+
+Ruby Version and Engine Dependency
+==================================
+
+You can specify the version, engine and engine version of ruby to use with
+your gem dependencies file.  If you are not running the specified version
+RubyGems will raise an exception.
+
+To depend on a specific version of ruby:
+
+  ruby '2.1.2'
+
+To depend on a specific ruby engine:
+
+  ruby '1.9.3', engine: 'jruby'
+
+To depend on a specific ruby engine version:
+
+  ruby '1.9.3', engine: 'jruby', engine_version: '1.7.11'
+
+Grouping Dependencies
+=====================
+
+Gem dependencies may be placed in groups that can be excluded from install.
+Dependencies required for development or testing of your code may be excluded
+when installed in a production environment.
+
+A #gem dependency may be placed in a group using the group: option:
+
+  gem 'minitest', group: :test
+
+To install dependencies from a gemfile without specific groups use the
+`--without` option for `gem install -g`:
+
+  $ gem install -g --without test
+
+The group: option also accepts multiple groups if the gem fits in multiple
+categories.
+
+Multiple groups may be excluded during install by comma-separating the groups for `--without` or by specifying `--without` multiple times.
+
+The #group method can also be used to place gems in groups:
+
+  group :test do
+    gem 'minitest'
+    gem 'minitest-emoji'
+  end
+
+The #group method allows multiple groups.
+
+The #gemspec development dependencies are placed in the :development group by
+default.  This may be overridden with the :development_group option:
+
+  gemspec development_group: :other
+
+  EOF
+
   PLATFORMS = <<-'EOF'
 RubyGems platforms are composed of three parts, a CPU, an OS, and a
 version.  These values are taken from values in rbconfig.rb.  You can view
@@ -90,6 +267,16 @@ When building platform gems, set the platform in the gem specification to
 Gem::Platform::CURRENT.  This will correctly mark the gem with your ruby's
 platform.
   EOF
+
+  # NOTE when updating also update Gem::Command::HELP
+
+  SUBCOMMANDS = [
+    ["commands",         :show_commands],
+    ["options",          Gem::Command::HELP],
+    ["examples",         EXAMPLES],
+    ["gem_dependencies", GEM_DEPENDENCIES],
+    ["platforms",        PLATFORMS],
+  ]
   # :startdoc:
 
   def initialize
@@ -98,15 +285,6 @@ platform.
     @command_manager = Gem::CommandManager.instance
   end
 
-  def arguments # :nodoc:
-    args = <<-EOF
-      commands      List all 'gem' commands
-      examples      Show examples of 'gem' usage
-      <command>     Show specific help for <command>
-    EOF
-    return args.gsub(/^\s+/, '')
-  end
-
   def usage # :nodoc:
     "#{program_name} ARGUMENT"
   end
@@ -114,19 +292,20 @@ platform.
   def execute
     arg = options[:args][0]
 
-    if begins? "commands", arg then
-      show_commands
-
-    elsif begins? "options", arg then
-      say Gem::Command::HELP
-
-    elsif begins? "examples", arg then
-      say EXAMPLES
+    _, help = SUBCOMMANDS.find do |command,|
+      begins? command, arg
+    end
 
-    elsif begins? "platforms", arg then
-      say PLATFORMS
+    if help then
+      if Symbol === help then
+        send help
+      else
+        say help
+      end
+      return
+    end
 
-    elsif options[:help] then
+    if options[:help] then
       show_help
 
     elsif arg then
diff --git a/jruby/lib/ruby/shared/rubygems/commands/install_command.rb b/jruby/lib/ruby/shared/rubygems/commands/install_command.rb
index f02b129..1bf5928 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/install_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/install_command.rb
@@ -21,7 +21,10 @@ class Gem::Commands::InstallCommand < Gem::Command
   def initialize
     defaults = Gem::DependencyInstaller::DEFAULT_OPTIONS.merge({
       :format_executable => false,
+      :lock              => true,
+      :suggest_alternate => true,
       :version           => Gem::Requirement.default,
+      :without_groups    => [],
     })
 
     super 'install', 'Install a gem into the local repository', defaults
@@ -32,19 +35,53 @@ class Gem::Commands::InstallCommand < Gem::Command
     add_version_option
     add_prerelease_option "to be installed. (Only for listed gems)"
 
-    add_option(:"Install/Update", '-g', '--file FILE',
+    add_option(:"Install/Update", '-g', '--file [FILE]',
                'Read from a gem dependencies API file and',
                'install the listed gems') do |v,o|
+      v = Gem::GEM_DEP_FILES.find do |file|
+        File.exist? file
+      end unless v
+
+      unless v then
+        message = v ? v : "(tried #{Gem::GEM_DEP_FILES.join ', '})"
+
+        raise OptionParser::InvalidArgument,
+                "cannot find gem dependencies file #{message}"
+      end
+
       o[:gemdeps] = v
     end
 
+    add_option(:"Install/Update", '--without GROUPS', Array,
+               'Omit the named groups (comma separated)',
+               'when installing from a gem dependencies',
+               'file') do |v,o|
+      o[:without_groups].concat v.map { |without| without.intern }
+    end
+
     add_option(:"Install/Update", '--default',
                'Add the gem\'s full specification to',
                'specifications/default and extract only its bin') do |v,o|
       o[:install_as_default] = v
     end
 
-    @installed_specs = nil
+    add_option(:"Install/Update", '--explain',
+               'Rather than install the gems, indicate which would',
+               'be installed') do |v,o|
+      o[:explain] = v
+    end
+
+    add_option(:"Install/Update", '--[no-]lock',
+               'Create a lock file (when used with -g/--file)') do |v,o|
+      o[:lock] = v
+    end
+
+    add_option(:"Install/Update", '--[no-]suggestions',
+               'Suggest alternates when gems are not found') do |v,o|
+      o[:suggest_alternate] = v
+    end
+
+    @installed_specs = []
   end
 
   def arguments # :nodoc:
@@ -53,7 +90,7 @@ class Gem::Commands::InstallCommand < Gem::Command
 
   def defaults_str # :nodoc:
     "--both --version '#{Gem::Requirement.default}' --document --no-force\n" +
-    "--install-dir #{Gem.dir}"
+    "--install-dir #{Gem.dir} --lock"
   end
 
   def description # :nodoc:
@@ -67,6 +104,25 @@ The wrapper allows you to choose among alternate gem versions using _version_.
 For example `rake _0.7.3_ --version` will run rake version 0.7.3 if a newer
 version is also installed.
 
+Gem Dependency Files
+====================
+
+RubyGems can install a consistent set of gems across multiple environments
+using `gem install -g` when a gem dependencies file (gem.deps.rb, Gemfile or
+Isolate) is present.  If no explicit file is given RubyGems attempts to find
+one in the current directory.
+
+When the RUBYGEMS_GEMDEPS environment variable is set to a gem dependencies
+file the gems from that file will be activated at startup time.  Set it to a
+specific filename or to "-" to have RubyGems automatically discover the gem
+dependencies file by walking up from the current directory.
+
+NOTE: Enabling automatic discovery on multiuser systems can lead to
+execution of arbitrary code when used from directories outside your control.
+
+Extension Install Failures
+==========================
+
 If an extension fails to compile during gem installation the gem
 specification is not written out, but the gem remains unpacked in the
 repository.  You may need to specify the path to the library's headers and
@@ -129,9 +185,9 @@ to write the specification by hand.  For example:
   end
 
   def execute
-    if gf = options[:gemdeps] then
-      install_from_gemdeps gf
-      return
+    if options.include? :gemdeps then
+      install_from_gemdeps
+      return # not reached
     end
 
     @installed_specs = []
@@ -147,17 +203,14 @@ to write the specification by hand.  For example:
 
     show_installed
 
-    raise Gem::SystemExitException, exit_code
+    terminate_interaction exit_code
   end
 
-  def install_from_gemdeps gf # :nodoc:
+  def install_from_gemdeps # :nodoc:
     require 'rubygems/request_set'
     rs = Gem::RequestSet.new
-    rs.load_gemdeps gf
 
-    rs.resolve
-
-    specs = rs.install options do |req, inst|
+    specs = rs.install_from_gemdeps options do |req, inst|
       s = req.full_spec
 
       if inst
@@ -169,19 +222,71 @@ to write the specification by hand.  For example:
 
     @installed_specs = specs
 
-    raise Gem::SystemExitException, 0
+    terminate_interaction
   end
 
   def install_gem name, version # :nodoc:
     return if options[:conservative] and
       not Gem::Dependency.new(name, version).matching_specs.empty?
 
-    inst = Gem::DependencyInstaller.new options
-    inst.install name, Gem::Requirement.create(version)
+    req = Gem::Requirement.create(version)
+
+    if options[:ignore_dependencies] then
+      install_gem_without_dependencies name, req
+    else
+      inst = Gem::DependencyInstaller.new options
+      request_set = inst.resolve_dependencies name, req
+
+      if options[:explain]
+        puts "Gems to install:"
+
+        request_set.sorted_requests.each do |s|
+          puts "  #{s.full_name}"
+        end
+
+        return
+      else
+        @installed_specs.concat request_set.install options
+      end
+
+      show_install_errors inst.errors
+    end
+  end
+
+  def install_gem_without_dependencies name, req # :nodoc:
+    gem = nil
+
+    if local? then
+      if name =~ /\.gem$/ and File.file? name then
+        source = Gem::Source::SpecificFile.new name
+        spec = source.spec
+      else
+        source = Gem::Source::Local.new
+        spec = source.find_gem name, req
+      end
+      gem = source.download spec if spec
+    end
+
+    if remote? and not gem then
+      dependency = Gem::Dependency.new name, req
+      dependency.prerelease = options[:prerelease]
+
+      fetcher = Gem::RemoteFetcher.fetcher
+      gem = fetcher.download_to_cache dependency
+    end
+
+    inst = Gem::Installer.new gem, options
+    inst.install
+
+    require 'rubygems/dependency_installer'
+    dinst = Gem::DependencyInstaller.new options
+    dinst.installed_gems.replace [inst.spec]
 
-    @installed_specs.push(*inst.installed_gems)
+    Gem.done_installing_hooks.each do |hook|
+      hook.call dinst, [inst.spec]
+    end unless Gem.done_installing_hooks.empty?
 
-    show_install_errors inst.errors
+    @installed_specs.push(inst.spec)
   end
 
   def install_gems # :nodoc:
@@ -195,8 +300,10 @@ to write the specification by hand.  For example:
       rescue Gem::InstallError => e
         alert_error "Error installing #{gem_name}:\n\t#{e.message}"
         exit_code |= 1
-      rescue Gem::GemNotFoundException => e
-        show_lookup_failure e.name, e.version, e.errors, options[:domain]
+      rescue Gem::GemNotFoundException, Gem::UnsatisfiableDependencyError => e
+        domain = options[:domain]
+        domain = :local unless options[:suggest_alternate]
+        show_lookup_failure e.name, e.version, e.errors, domain
 
         exit_code |= 2
       end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/list_command.rb b/jruby/lib/ruby/shared/rubygems/commands/list_command.rb
index 0d15950..c6ff237 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/list_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/list_command.rb
@@ -8,13 +8,13 @@ require 'rubygems/commands/query_command'
 class Gem::Commands::ListCommand < Gem::Commands::QueryCommand
 
   def initialize
-    super 'list', 'Display local gems whose name starts with STRING'
+    super 'list', 'Display local gems whose name matches REGEXP'
 
     remove_option('--name-matches')
   end
 
   def arguments # :nodoc:
-    "STRING        start of gem name to look for"
+    "REGEXP        regexp to look for in gem name"
   end
 
   def defaults_str # :nodoc:
@@ -33,13 +33,7 @@ To search for remote gems use the search command.
   end
 
   def usage # :nodoc:
-    "#{program_name} [STRING]"
-  end
-
-  def execute
-    string = get_one_optional_argument || ''
-    options[:name] = /^#{string}/i
-    super
+    "#{program_name} [STRING ...]"
   end
 
 end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/mirror_command.rb b/jruby/lib/ruby/shared/rubygems/commands/mirror_command.rb
index 75419c8..24fb668 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/mirror_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/mirror_command.rb
@@ -1,23 +1,25 @@
 require 'rubygems/command'
 
-class Gem::Commands::MirrorCommand < Gem::Command
-  def initialize
-    super('mirror', 'Mirror all gem files (requires rubygems-mirror)')
-    begin
-      Gem::Specification.find_by_name('rubygems-mirror').activate
-    rescue Gem::LoadError
-      # no-op
+unless defined? Gem::Commands::MirrorCommand
+  class Gem::Commands::MirrorCommand < Gem::Command
+    def initialize
+      super('mirror', 'Mirror all gem files (requires rubygems-mirror)')
+      begin
+        Gem::Specification.find_by_name('rubygems-mirror').activate
+      rescue Gem::LoadError
+        # no-op
+      end
     end
-  end
 
-  def description # :nodoc:
-    <<-EOF
+    def description # :nodoc:
+      <<-EOF
 The mirror command has been moved to the rubygems-mirror gem.
-    EOF
-  end
+      EOF
+    end
 
-  def execute
-    alert_error "Install the rubygems-mirror gem for the mirror command"
-  end
+    def execute
+      alert_error "Install the rubygems-mirror gem for the mirror command"
+    end
 
+  end
 end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/open_command.rb b/jruby/lib/ruby/shared/rubygems/commands/open_command.rb
new file mode 100644
index 0000000..254a742
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/commands/open_command.rb
@@ -0,0 +1,76 @@
+require 'English'
+require 'rubygems/command'
+require 'rubygems/version_option'
+require 'rubygems/util'
+
+class Gem::Commands::OpenCommand < Gem::Command
+
+  include Gem::VersionOption
+
+  def initialize
+    super 'open', 'Open gem sources in editor'
+
+    add_option('-e', '--editor EDITOR', String,
+               "Opens gem sources in EDITOR") do |editor, options|
+      options[:editor] = editor || get_env_editor
+    end
+  end
+
+  def arguments # :nodoc:
+    "GEMNAME     name of gem to open in editor"
+  end
+
+  def defaults_str # :nodoc:
+    "-e #{get_env_editor}"
+  end
+
+  def description # :nodoc:
+    <<-EOF
+        The open command opens gem in editor and changes current path
+        to gem's source directory. Editor can be specified with -e option,
+        otherwise rubygems will look for editor in $EDITOR, $VISUAL and
+        $GEM_EDITOR variables.
+    EOF
+  end
+
+  def usage # :nodoc:
+    "#{program_name} GEMNAME [-e EDITOR]"
+  end
+
+  def get_env_editor
+    ENV['GEM_EDITOR'] ||
+      ENV['VISUAL'] ||
+      ENV['EDITOR'] ||
+      'vi'
+  end
+
+  def execute
+    @version = options[:version] || Gem::Requirement.default
+    @editor  = options[:editor] || get_env_editor
+
+    found = open_gem(get_one_gem_name)
+
+    terminate_interaction 1 unless found
+  end
+
+  def open_gem name
+    spec = spec_for name
+    return false unless spec
+
+    open_editor(spec.full_gem_path)
+  end
+
+  def open_editor path
+    Dir.chdir(path) do
+      system(*@editor.split(/\s+/) + [path])
+    end
+  end
+
+  def spec_for name
+    spec = Gem::Specification.find_all_by_name(name, @version).last
+
+    return spec if spec
+
+    say "Unable to find gem '#{name}'"
+  end
+end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/outdated_command.rb b/jruby/lib/ruby/shared/rubygems/commands/outdated_command.rb
index f51bc5e..7159dbb 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/outdated_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/outdated_command.rb
@@ -17,7 +17,7 @@ class Gem::Commands::OutdatedCommand < Gem::Command
 
   def description # :nodoc:
     <<-EOF
-The outdated command lists gems you way wish to upgrade to a newer version.
+The outdated command lists gems you may wish to upgrade to a newer version.
 
 You can check for dependency mismatches using the dependency command and
 update the gems with the update or install commands.
diff --git a/jruby/lib/ruby/shared/rubygems/commands/owner_command.rb b/jruby/lib/ruby/shared/rubygems/commands/owner_command.rb
index 13b8793..322bf65 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/owner_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/owner_command.rb
@@ -86,7 +86,9 @@ permission to.
           request.add_field "Authorization", api_key
         end
 
-        with_response response, "Removing #{owner}"
+        action = method == :delete ? "Removing" : "Adding"
+
+        with_response response, "#{action} #{owner}"
       rescue
         # ignore
       end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/pristine_command.rb b/jruby/lib/ruby/shared/rubygems/commands/pristine_command.rb
index 3f3bca4..dcd5bb7 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/pristine_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/pristine_command.rb
@@ -12,6 +12,7 @@ class Gem::Commands::PristineCommand < Gem::Command
           'Restores installed gems to pristine condition from files located in the gem cache',
           :version => Gem::Requirement.default,
           :extensions => true,
+          :extensions_set => false,
           :all => false
 
     add_option('--all',
@@ -23,7 +24,8 @@ class Gem::Commands::PristineCommand < Gem::Command
     add_option('--[no-]extensions',
                'Restore gems with extensions',
                'in addition to regular gems') do |value, options|
-      options[:extensions] = value
+      options[:extensions_set] = true
+      options[:extensions]     = value
     end
 
     add_option('--only-executables',
@@ -62,6 +64,9 @@ If the cached gem cannot be found it will be downloaded.
 
 If --no-extensions is provided pristine will not attempt to restore a gem
 with an extension.
+
+If --extensions is given (but not --all or gem names) only gems with
+extensions will be restored.
     EOF
   end
 
@@ -72,6 +77,14 @@ with an extension.
   def execute
     specs = if options[:all] then
               Gem::Specification.map
+
+            # `--extensions` must be explicitly given to pristine only gems
+            # with extensions.
+            elsif options[:extensions_set] and
+                  options[:extensions] and options[:args].empty? then
+              Gem::Specification.select do |spec|
+                spec.extensions and not spec.extensions.empty?
+              end
             else
               get_all_gem_names.map do |gem_name|
                 Gem::Specification.find_all_by_name gem_name, options[:version]
@@ -96,6 +109,11 @@ with an extension.
         next
       end
 
+      if spec.bundled_gem_in_old_ruby?
+        say "Skipped #{spec.full_name}, it is bundled with old Ruby"
+        next
+      end
+
       unless spec.extensions.empty? or options[:extensions] then
         say "Skipped #{spec.full_name}, it needs to compile an extension"
         next
@@ -107,8 +125,17 @@ with an extension.
         require 'rubygems/remote_fetcher'
 
         say "Cached gem for #{spec.full_name} not found, attempting to fetch..."
+
         dep = Gem::Dependency.new spec.name, spec.version
-        Gem::RemoteFetcher.fetcher.download_to_cache dep
+        found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dep
+
+        if found.empty?
+          say "Skipped #{spec.full_name}, it was not found from cache and remote sources"
+          next
+        end
+
+        spec_candidate, source = found.first
+        Gem::RemoteFetcher.fetcher.download spec_candidate, source.uri.to_s, spec.base_dir
       end
 
       env_shebang =
diff --git a/jruby/lib/ruby/shared/rubygems/commands/push_command.rb b/jruby/lib/ruby/shared/rubygems/commands/push_command.rb
index b90be7b..6899b48 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/push_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/push_command.rb
@@ -69,13 +69,18 @@ You can upgrade or downgrade to the latest release version with:
       terminate_interaction 1
     end
 
+    gem_data = Gem::Package.new(name)
+
     unless @host then
-      if gem_data = Gem::Package.new(name) then
-        @host = gem_data.spec.metadata['default_gem_server']
-      end
+      @host = gem_data.spec.metadata['default_gem_server']
     end
 
-    args << @host if @host
+    # Always include this, even if it's nil
+    args << @host
+
+    if gem_data.spec.metadata.has_key?('allowed_push_host')
+      args << gem_data.spec.metadata['allowed_push_host']
+    end
 
     say "Pushing gem to #{@host || Gem.host}..."
 
diff --git a/jruby/lib/ruby/shared/rubygems/commands/query_command.rb b/jruby/lib/ruby/shared/rubygems/commands/query_command.rb
index c9c3014..432250e 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/query_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/query_command.rb
@@ -72,16 +72,26 @@ is too hard to use.
 
   def execute
     exit_code = 0
+    if options[:args].to_a.empty? and options[:name].source.empty?
+      name = options[:name]
+      no_name = true
+    elsif !options[:name].source.empty?
+      name = Array(options[:name])
+    else
+      name = options[:args].to_a.map{|arg| /#{arg}/i }
+    end
 
-    name = options[:name]
     prerelease = options[:prerelease]
 
     unless options[:installed].nil? then
-      if name.source.empty? then
+      if no_name then
         alert_error "You must specify a gem name"
         exit_code |= 4
+      elsif name.count > 1
+        alert_error "You must specify only ONE gem!"
+        exit_code |= 4
       else
-        installed = installed? name, options[:version]
+        installed = installed? name.first, options[:version]
         installed = !installed unless options[:installed]
 
         if installed then
@@ -95,6 +105,22 @@ is too hard to use.
       terminate_interaction exit_code
     end
 
+    names = Array(name)
+    names.each { |n| show_gems n, prerelease }
+  end
+
+  private
+
+  def display_header type
+    if (ui.outs.tty? and Gem.configuration.verbose) or both? then
+      say
+      say "*** #{type} GEMS ***"
+      say
+    end
+  end
+
+  #Guts of original execute
+  def show_gems name, prerelease
     req = Gem::Requirement.default
     # TODO: deprecate for real
     dep = Gem::Deprecate.skip_during { Gem::Dependency.new name, req }
@@ -105,11 +131,7 @@ is too hard to use.
         alert_warning "prereleases are always shown locally"
       end
 
-      if ui.outs.tty? or both? then
-        say
-        say "*** LOCAL GEMS ***"
-        say
-      end
+      display_header 'LOCAL'
 
       specs = Gem::Specification.find_all { |s|
         s.name =~ name and req =~ s.version
@@ -123,11 +145,7 @@ is too hard to use.
     end
 
     if remote? then
-      if ui.outs.tty? or both? then
-        say
-        say "*** REMOTE GEMS ***"
-        say
-      end
+      display_header 'REMOTE'
 
       fetcher = Gem::SpecFetcher.fetcher
 
@@ -143,11 +161,11 @@ is too hard to use.
                :latest
              end
 
-      if options[:name].source.empty?
+      if name.source.empty?
         spec_tuples = fetcher.detect(type) { true }
       else
         spec_tuples = fetcher.detect(type) do |name_tuple|
-          options[:name] === name_tuple.name
+          name === name_tuple.name
         end
       end
 
@@ -155,8 +173,6 @@ is too hard to use.
     end
   end
 
-  private
-
   ##
   # Check if gem +name+ version +version+ is installed.
 
diff --git a/jruby/lib/ruby/shared/rubygems/commands/search_command.rb b/jruby/lib/ruby/shared/rubygems/commands/search_command.rb
index 5bc9650..a1e2c1a 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/search_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/search_command.rb
@@ -4,7 +4,7 @@ require 'rubygems/commands/query_command'
 class Gem::Commands::SearchCommand < Gem::Commands::QueryCommand
 
   def initialize
-    super 'search', 'Display remote gems whose name contains STRING'
+    super 'search', 'Display remote gems whose name matches REGEXP'
 
     remove_option '--name-matches'
 
@@ -12,7 +12,7 @@ class Gem::Commands::SearchCommand < Gem::Commands::QueryCommand
   end
 
   def arguments # :nodoc:
-    "STRING        fragment of gem name to search for"
+    "REGEXP        regexp to search for in gem name"
   end
 
   def defaults_str # :nodoc:
@@ -21,8 +21,8 @@ class Gem::Commands::SearchCommand < Gem::Commands::QueryCommand
 
   def description # :nodoc:
     <<-EOF
-The search command displays remote gems whose name contains the given
-string.
+The search command displays remote gems whose name matches the given
+regexp.
 
 The --details option displays additional details from the gem but will
 take a little longer to complete as it must download the information
@@ -33,13 +33,7 @@ To list local gems use the list command.
   end
 
   def usage # :nodoc:
-    "#{program_name} [STRING]"
-  end
-
-  def execute
-    string = get_one_optional_argument
-    options[:name] = /#{string}/i
-    super
+    "#{program_name} [REGEXP]"
   end
 
 end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/setup_command.rb b/jruby/lib/ruby/shared/rubygems/commands/setup_command.rb
index face77f..6617396 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/setup_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/setup_command.rb
@@ -13,7 +13,7 @@ class Gem::Commands::SetupCommand < Gem::Command
 
     super 'setup', 'Install RubyGems',
           :format_executable => true, :document => %w[ri],
-          :site_or_vendor => :sitelibdir,
+          :site_or_vendor => 'sitelibdir',
           :destdir => '', :prefix => '', :previous_version => ''
 
     add_option '--previous-version=VERSION',
@@ -36,7 +36,7 @@ class Gem::Commands::SetupCommand < Gem::Command
 
     add_option '--[no-]vendor',
                'Install into vendorlibdir not sitelibdir' do |vendor, options|
-      options[:site_or_vendor] = vendor ? :vendorlibdir : :sitelibdir
+      options[:site_or_vendor] = vendor ? 'vendorlibdir' : 'sitelibdir'
     end
 
     add_option '--[no-]format-executable',
@@ -343,19 +343,19 @@ TEXT
     site_or_vendor = options[:site_or_vendor]
 
     if prefix.empty? then
-      lib_dir = Gem::ConfigMap[site_or_vendor]
-      bin_dir = Gem::ConfigMap[:bindir]
+      lib_dir = RbConfig::CONFIG[site_or_vendor]
+      bin_dir = RbConfig::CONFIG['bindir']
     else
       # Apple installed RubyGems into libdir, and RubyGems <= 1.1.0 gets
       # confused about installation location, so switch back to
       # sitelibdir/vendorlibdir.
       if defined?(APPLE_GEM_HOME) and
         # just in case Apple and RubyGems don't get this patched up proper.
-        (prefix == Gem::ConfigMap[:libdir] or
+        (prefix == RbConfig::CONFIG['libdir'] or
          # this one is important
-         prefix == File.join(Gem::ConfigMap[:libdir], 'ruby')) then
-         lib_dir = Gem::ConfigMap[site_or_vendor]
-         bin_dir = Gem::ConfigMap[:bindir]
+         prefix == File.join(RbConfig::CONFIG['libdir'], 'ruby')) then
+         lib_dir = RbConfig::CONFIG[site_or_vendor]
+         bin_dir = RbConfig::CONFIG['bindir']
       else
         lib_dir = File.join prefix, 'lib'
         bin_dir = File.join prefix, 'bin'
@@ -446,7 +446,7 @@ abort "#{deprecation_message}"
         history.force_encoding Encoding::UTF_8 if
           Object.const_defined? :Encoding
 
-        history = history.sub(/^# coding:.*?^=/m, '')
+        history = history.sub(/^# coding:.*?(?=^=)/m, '')
 
         text = history.split(HISTORY_HEADER)
         text.shift # correct an off-by-one generated by split
diff --git a/jruby/lib/ruby/shared/rubygems/commands/specification_command.rb b/jruby/lib/ruby/shared/rubygems/commands/specification_command.rb
index d96c8b8..3bc02a9 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/specification_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/specification_command.rb
@@ -127,7 +127,7 @@ Specific fields in the specification can be extracted in YAML format:
     end
 
     unless options[:all] then
-      specs = [specs.sort_by { |s| s.version }.last]
+      specs = [specs.max_by { |s| s.version }]
     end
 
     specs.each do |s|
diff --git a/jruby/lib/ruby/shared/rubygems/commands/uninstall_command.rb b/jruby/lib/ruby/shared/rubygems/commands/uninstall_command.rb
index e62095a..9285e57 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/uninstall_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/uninstall_command.rb
@@ -15,7 +15,7 @@ class Gem::Commands::UninstallCommand < Gem::Command
   def initialize
     super 'uninstall', 'Uninstall gems from the local repository',
           :version => Gem::Requirement.default, :user_install => true,
-          :check_dev => false
+          :check_dev => false, :vendor => false
 
     add_option('-a', '--[no-]all',
       'Uninstall all matching versions'
@@ -76,6 +76,18 @@ class Gem::Commands::UninstallCommand < Gem::Command
 
     add_version_option
     add_platform_option
+
+    add_option('--vendor',
+               'Uninstall gem from the vendor directory.',
+               'Only for use by gem repackagers.') do |value, options|
+      unless Gem.vendor_dir then
+        raise OptionParser::InvalidOption.new 'your platform is not supported'
+      end
+
+      alert_warning 'Use your OS package manager to uninstall vendor gems'
+      options[:vendor] = true
+      options[:install_dir] = Gem.vendor_dir
+    end
   end
 
   def arguments # :nodoc:
@@ -112,7 +124,7 @@ that is a dependency of an existing gem.  You can use the
   end
 
   def uninstall_all
-    _, specs = Gem::Specification.partition { |spec| spec.default_gem? }
+    specs = Gem::Specification.reject { |spec| spec.default_gem? }
 
     specs.each do |spec|
       options[:version] = spec.version
diff --git a/jruby/lib/ruby/shared/rubygems/commands/unpack_command.rb b/jruby/lib/ruby/shared/rubygems/commands/unpack_command.rb
index e60e7d9..5a05ad0 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/unpack_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/unpack_command.rb
@@ -134,7 +134,7 @@ command help for an example.
 
     specs = dependency.matching_specs
 
-    selected = specs.sort_by { |s| s.version }.last # HACK: hunt last down
+    selected = specs.max_by { |s| s.version }
 
     return Gem::RemoteFetcher.fetcher.download_to_cache(dependency) unless
       selected
diff --git a/jruby/lib/ruby/shared/rubygems/commands/update_command.rb b/jruby/lib/ruby/shared/rubygems/commands/update_command.rb
index 77bf5ed..001dd77 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/update_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/update_command.rb
@@ -16,6 +16,8 @@ class Gem::Commands::UpdateCommand < Gem::Command
 
   attr_reader :installer # :nodoc:
 
+  attr_reader :updated # :nodoc:
+
   def initialize
     super 'update', 'Update installed gems to the latest version',
       :document => %w[rdoc ri],
@@ -45,7 +47,7 @@ class Gem::Commands::UpdateCommand < Gem::Command
   end
 
   def arguments # :nodoc:
-    "GEMNAME       name of gem to update"
+    "REGEXP        regexp to search for in gem name"
   end
 
   def defaults_str # :nodoc:
@@ -56,13 +58,13 @@ class Gem::Commands::UpdateCommand < Gem::Command
     <<-EOF
 The update command will update your gems to the latest version.
 
-The update comamnd does not remove the previous version.  Use the cleanup
+The update command does not remove the previous version. Use the cleanup
 command to remove old versions.
     EOF
   end
 
   def usage # :nodoc:
-    "#{program_name} GEMNAME [GEMNAME ...]"
+    "#{program_name} REGEXP [REGEXP ...]"
   end
 
   def check_latest_rubygems version # :nodoc:
@@ -82,8 +84,6 @@ command to remove old versions.
   end
 
   def execute
-    hig = {}
-
     if options[:system] then
       update_rubygems
       return
@@ -97,10 +97,14 @@ command to remove old versions.
 
     updated = update_gems gems_to_update
 
+    updated_names = updated.map { |spec| spec.name }
+    not_updated_names = options[:args].uniq - updated_names
+
     if updated.empty? then
       say "Nothing to update"
     else
-      say "Gems updated: #{updated.map { |spec| spec.name }.join ' '}"
+      say "Gems updated: #{updated_names.join(' ')}"
+      say "Gems already up-to-date: #{not_updated_names.join(' ')}" unless not_updated_names.empty?
     end
   end
 
@@ -110,7 +114,11 @@ command to remove old versions.
 
     fetcher = Gem::SpecFetcher.fetcher
 
-    spec_tuples, _ = fetcher.search_for_dependency dependency
+    spec_tuples, errors = fetcher.search_for_dependency dependency
+
+    error = errors.find { |e| e.respond_to? :exception }
+
+    raise error if error
 
     spec_tuples
   end
@@ -134,7 +142,7 @@ command to remove old versions.
       g.name == spec.name and g.match_platform?
     end
 
-    highest_remote_gem = matching_gems.sort_by { |g,_| g.version }.last
+    highest_remote_gem = matching_gems.max_by { |g,_| g.version }
 
     highest_remote_gem ||= [Gem::NameTuple.null]
 
@@ -193,17 +201,16 @@ command to remove old versions.
   def update_gem name, version = Gem::Requirement.default
     return if @updated.any? { |spec| spec.name == name }
 
-    @installer ||= Gem::DependencyInstaller.new options
+    update_options = options.dup
+    update_options[:prerelease] = version.prerelease?
 
-    success = false
+    @installer = Gem::DependencyInstaller.new update_options
 
     say "Updating #{name}"
     begin
       @installer.install name, Gem::Requirement.new(version)
-      success = true
-    rescue Gem::InstallError => e
+    rescue Gem::InstallError, Gem::DependencyError => e
       alert_error "Error installing #{name}:\n\t#{e.message}"
-      success = false
     end
 
     @installer.installed_gems.each do |spec|
@@ -244,6 +251,9 @@ command to remove old versions.
     args << '--no-rdoc' unless options[:document].include? 'rdoc'
     args << '--no-ri'   unless options[:document].include? 'ri'
     args << '--no-format-executable' if options[:no_format_executable]
+    args << '--previous-version' << Gem::VERSION if
+      options[:system] == true or
+        Gem::Version.new(options[:system]) >= Gem::Version.new(2)
     args
   end
 
@@ -252,7 +262,7 @@ command to remove old versions.
 
     highest_installed_gems.each do |l_name, l_spec|
       next if not gem_names.empty? and
-              gem_names.all? { |name| /#{name}/ !~ l_spec.name }
+              gem_names.none? { |name| name == l_spec.name }
 
       highest_remote_ver = highest_remote_version l_spec
 
@@ -265,4 +275,3 @@ command to remove old versions.
   end
 
 end
-
diff --git a/jruby/lib/ruby/shared/rubygems/commands/which_command.rb b/jruby/lib/ruby/shared/rubygems/commands/which_command.rb
index 99b9085..96eeb86 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/which_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/which_command.rb
@@ -35,7 +35,7 @@ requiring to see why it does not behave as you expect.
   end
 
   def execute
-    found = false
+    found = true
 
     options[:args].each do |arg|
       arg = arg.sub(/#{Regexp.union(*Gem.suffixes)}$/, '')
@@ -45,9 +45,9 @@ requiring to see why it does not behave as you expect.
 
       if spec then
         if options[:search_gems_first] then
-          dirs = gem_paths(spec) + $LOAD_PATH
+          dirs = spec.full_require_paths + $LOAD_PATH
         else
-          dirs = $LOAD_PATH + gem_paths(spec)
+          dirs = $LOAD_PATH + spec.full_require_paths
         end
       end
 
@@ -56,9 +56,10 @@ requiring to see why it does not behave as you expect.
 
       if paths.empty? then
         alert_error "Can't find ruby library file or shared library #{arg}"
+
+        found &&= false
       else
         say paths
-        found = true
       end
     end
 
@@ -81,10 +82,6 @@ requiring to see why it does not behave as you expect.
     result
   end
 
-  def gem_paths(spec)
-    spec.require_paths.collect { |d| File.join spec.full_gem_path, d }
-  end
-
   def usage # :nodoc:
     "#{program_name} FILE [FILE ...]"
   end
diff --git a/jruby/lib/ruby/shared/rubygems/commands/yank_command.rb b/jruby/lib/ruby/shared/rubygems/commands/yank_command.rb
index 2285bb4..c05ee66 100644
--- a/jruby/lib/ruby/shared/rubygems/commands/yank_command.rb
+++ b/jruby/lib/ruby/shared/rubygems/commands/yank_command.rb
@@ -21,7 +21,7 @@ via the webhooks.  If you accidentally pushed passwords or other sensitive
 data you will need to change them immediately and yank your gem.
 
 If you are yanking a gem due to intellectual property reasons contact
-http://help.rubygems.org for permanant removal.  Be sure to mention this
+http://help.rubygems.org for permanent removal.  Be sure to mention this
 as the reason for the removal request.
     EOF
   end
@@ -44,10 +44,7 @@ as the reason for the removal request.
       options[:undo] = true
     end
 
-    add_option('-k', '--key KEY_NAME',
-               'Use API key from your gem credentials file') do |value, options|
-      options[:key] = value
-    end
+    add_key_option
   end
 
   def execute
@@ -55,14 +52,12 @@ as the reason for the removal request.
 
     version   = get_version_from_requirements(options[:version])
     platform  = get_platform_from_requirements(options)
-    api_key   = Gem.configuration.rubygems_api_key
-    api_key   = Gem.configuration.api_keys[options[:key].to_sym] if options[:key]
 
     if version then
       if options[:undo] then
-        unyank_gem(version, platform, api_key)
+        unyank_gem(version, platform)
       else
-        yank_gem(version, platform, api_key)
+        yank_gem(version, platform)
       end
     else
       say "A version argument is required: #{usage}"
@@ -70,19 +65,19 @@ as the reason for the removal request.
     end
   end
 
-  def yank_gem(version, platform, api_key)
+  def yank_gem(version, platform)
     say "Yanking gem from #{self.host}..."
-    yank_api_request(:delete, version, platform, "api/v1/gems/yank", api_key)
+    yank_api_request(:delete, version, platform, "api/v1/gems/yank")
   end
 
-  def unyank_gem(version, platform, api_key)
+  def unyank_gem(version, platform)
     say "Unyanking gem from #{host}..."
-    yank_api_request(:put, version, platform, "api/v1/gems/unyank", api_key)
+    yank_api_request(:put, version, platform, "api/v1/gems/unyank")
   end
 
   private
 
-  def yank_api_request(method, version, platform, api, api_key)
+  def yank_api_request(method, version, platform, api)
     name = get_one_gem_name
     response = rubygems_api_request(method, api) do |request|
       request.add_field("Authorization", api_key)
diff --git a/jruby/lib/ruby/shared/rubygems/compatibility.rb b/jruby/lib/ruby/shared/rubygems/compatibility.rb
index 87d5672..6a00a19 100644
--- a/jruby/lib/ruby/shared/rubygems/compatibility.rb
+++ b/jruby/lib/ruby/shared/rubygems/compatibility.rb
@@ -20,8 +20,7 @@ if Gem::GEM_PRELUDE_SUCKAGE and defined?(Gem::QuickLoader) then
 
   $LOADED_FEATURES.delete Gem::QuickLoader.path_to_full_rubygems_library
 
-  if $LOADED_FEATURES.any? do |path| path.end_with? '/rubygems.rb' end then
-    # TODO path does not exist here
+  if path = $LOADED_FEATURES.find {|n| n.end_with? '/rubygems.rb'} then
     raise LoadError, "another rubygems is already loaded from #{path}"
   end
 
@@ -33,7 +32,12 @@ end
 module Gem
   RubyGemsVersion = VERSION
 
+  # TODO remove at RubyGems 3
+
   RbConfigPriorities = %w[
+    MAJOR
+    MINOR
+    TEENY
     EXEEXT RUBY_SO_NAME arch bindir datadir libdir ruby_install_name
     ruby_version rubylibprefix sitedir sitelibdir vendordir vendorlibdir
     rubylibdir
@@ -42,7 +46,7 @@ module Gem
   unless defined?(ConfigMap)
     ##
     # Configuration settings from ::RbConfig
-    ConfigMap = Hash.new do |cm, key|
+    ConfigMap = Hash.new do |cm, key| # TODO remove at RubyGems 3
       cm[key] = RbConfig::CONFIG[key.to_s]
     end
   else
diff --git a/jruby/lib/ruby/shared/rubygems/config_file.rb b/jruby/lib/ruby/shared/rubygems/config_file.rb
index 1acae9b..1bdc79a 100644
--- a/jruby/lib/ruby/shared/rubygems/config_file.rb
+++ b/jruby/lib/ruby/shared/rubygems/config_file.rb
@@ -57,7 +57,7 @@ class Gem::ConfigFile
 
   # :stopdoc:
 
-  system_config_path =
+  SYSTEM_CONFIG_PATH =
     begin
       require "etc"
       Etc.sysconfdir
@@ -86,7 +86,7 @@ class Gem::ConfigFile
 
   # :startdoc:
 
-  SYSTEM_WIDE_CONFIG_FILE = File.join system_config_path, 'gemrc'
+  SYSTEM_WIDE_CONFIG_FILE = File.join SYSTEM_CONFIG_PATH, 'gemrc'
 
   ##
   # List of arguments supplied to the config file object.
@@ -137,9 +137,10 @@ class Gem::ConfigFile
   attr_reader :ssl_verify_mode
 
   ##
-  # Path name of directory or file of openssl CA certificate, used for remote https connection
+  # Path name of directory or file of openssl CA certificate, used for remote
+  # https connection
 
-  attr_reader :ssl_ca_cert
+  attr_accessor :ssl_ca_cert
 
   ##
   # Path name of directory or file of openssl client certificate, used for remote https connection with client authentication
@@ -336,7 +337,7 @@ if you believe they were disclosed to a third party.
       end
       return content
     rescue *YAMLErrors => e
-      warn "Failed to load #{filename}, #{e.to_s}"
+      warn "Failed to load #{filename}, #{e}"
     rescue Errno::EACCES
       warn "Failed to load #{filename} due to permissions problem."
     end
@@ -382,6 +383,8 @@ if you believe they were disclosed to a third party.
         @backtrace = true
       when /^--debug$/ then
         $DEBUG = true
+
+        warn 'NOTE:  Debugging mode prints all exceptions even when rescued'
       else
         @args << arg
       end
@@ -427,6 +430,15 @@ if you believe they were disclosed to a third party.
                             DEFAULT_VERBOSITY
                           end
 
+    yaml_hash[:ssl_verify_mode] =
+      @hash[:ssl_verify_mode] if @hash.key? :ssl_verify_mode
+
+    yaml_hash[:ssl_ca_cert] =
+      @hash[:ssl_ca_cert] if @hash.key? :ssl_ca_cert
+
+    yaml_hash[:ssl_client_cert] =
+      @hash[:ssl_client_cert] if @hash.key? :ssl_client_cert
+
     keys = yaml_hash.keys.map { |key| key.to_s }
     keys << 'debug'
     re = Regexp.union(*keys)
diff --git a/jruby/lib/ruby/shared/rubygems/core_ext/kernel_gem.rb b/jruby/lib/ruby/shared/rubygems/core_ext/kernel_gem.rb
index f946d0d..61e77fe 100644
--- a/jruby/lib/ruby/shared/rubygems/core_ext/kernel_gem.rb
+++ b/jruby/lib/ruby/shared/rubygems/core_ext/kernel_gem.rb
@@ -1,3 +1,9 @@
+##
+# RubyGems adds the #gem method to allow activation of specific gem versions
+# and overrides the #require method on Kernel to make gems appear as if they
+# live on the <code>$LOAD_PATH</code>.  See the documentation of these methods
+# for further detail.
+
 module Kernel
 
   # REFACTOR: This should be pulled out into some kind of hacks file.
@@ -20,6 +26,11 @@ module Kernel
   # Kernel#gem should be called *before* any require statements (otherwise
   # RubyGems may load a conflicting library version).
   #
+  # Kernel#gem only loads prerelease versions when prerelease +requirements+
+  # are given:
+  #
+  #   gem 'rake', '>= 1.1.a', '< 2'
+  #
   # In older RubyGems versions, the environment variable GEM_SKIP could be
   # used to skip activation of specified gems, for example to test out changes
   # that haven't been installed yet.  Now RubyGems defers to -I and the
@@ -44,8 +55,17 @@ module Kernel
       gem_name = gem_name.name
     end
 
-    spec = Gem::Dependency.new(gem_name, *requirements).to_spec
-    spec.activate if spec
+    dep = Gem::Dependency.new(gem_name, *requirements)
+
+    loaded = Gem.loaded_specs[gem_name]
+
+    return false if loaded && dep.matches_spec?(loaded)
+
+    spec = dep.to_spec
+
+    Gem::LOADED_SPECS_MUTEX.synchronize {
+      spec.activate
+    } if spec
   end
 
   private :gem
diff --git a/jruby/lib/ruby/shared/rubygems/core_ext/kernel_require.rb b/jruby/lib/ruby/shared/rubygems/core_ext/kernel_require.rb
index 84bb03f..8f2cdde 100644
--- a/jruby/lib/ruby/shared/rubygems/core_ext/kernel_require.rb
+++ b/jruby/lib/ruby/shared/rubygems/core_ext/kernel_require.rb
@@ -50,12 +50,8 @@ module Kernel
     # normal require handle loading a gem from the rescue below.
 
     if Gem::Specification.unresolved_deps.empty? then
-      begin
-        RUBYGEMS_ACTIVATION_MONITOR.exit
-        return gem_original_require(path)
-      ensure
-        RUBYGEMS_ACTIVATION_MONITOR.enter
-      end
+      RUBYGEMS_ACTIVATION_MONITOR.exit
+      return gem_original_require(path)
     end
 
     # If +path+ is for a gem that has already been loaded, don't
@@ -70,9 +66,7 @@ module Kernel
 
     begin
       RUBYGEMS_ACTIVATION_MONITOR.exit
-      return gem_original_require(path)
-    ensure
-      RUBYGEMS_ACTIVATION_MONITOR.enter
+      return gem_original_require(spec.to_fullpath(path) || path)
     end if spec
 
     # Attempt to find +path+ in any unresolved gems...
@@ -105,6 +99,7 @@ module Kernel
       names = found_specs.map(&:name).uniq
 
       if names.size > 1 then
+        RUBYGEMS_ACTIVATION_MONITOR.exit
         raise Gem::LoadError, "#{path} found in multiple gems: #{names.join ', '}"
       end
 
@@ -115,32 +110,27 @@ module Kernel
       unless valid then
         le = Gem::LoadError.new "unable to find a version of '#{names.first}' to activate"
         le.name = names.first
+        RUBYGEMS_ACTIVATION_MONITOR.exit
         raise le
       end
 
       valid.activate
     end
 
-    begin
-      RUBYGEMS_ACTIVATION_MONITOR.exit
-      return gem_original_require(path)
-    ensure
-      RUBYGEMS_ACTIVATION_MONITOR.enter
-    end
+    RUBYGEMS_ACTIVATION_MONITOR.exit
+    return gem_original_require(path)
   rescue LoadError => load_error
+    RUBYGEMS_ACTIVATION_MONITOR.enter
+
     if load_error.message.start_with?("Could not find") or
         (load_error.message.end_with?(path) and Gem.try_activate(path)) then
-      begin
-        RUBYGEMS_ACTIVATION_MONITOR.exit
-        return gem_original_require(path)
-      ensure
-        RUBYGEMS_ACTIVATION_MONITOR.enter
-      end
+      RUBYGEMS_ACTIVATION_MONITOR.exit
+      return gem_original_require(path)
+    else
+      RUBYGEMS_ACTIVATION_MONITOR.exit
     end
 
     raise load_error
-  ensure
-    RUBYGEMS_ACTIVATION_MONITOR.exit
   end
 
   private :require
diff --git a/jruby/lib/ruby/shared/rubygems/defaults.rb b/jruby/lib/ruby/shared/rubygems/defaults.rb
index 591580b..55ca080 100644
--- a/jruby/lib/ruby/shared/rubygems/defaults.rb
+++ b/jruby/lib/ruby/shared/rubygems/defaults.rb
@@ -29,22 +29,22 @@ module Gem
   def self.default_dir
     path = if defined? RUBY_FRAMEWORK_VERSION then
              [
-               File.dirname(ConfigMap[:sitedir]),
+               File.dirname(RbConfig::CONFIG['sitedir']),
                'Gems',
-               ConfigMap[:ruby_version]
+               RbConfig::CONFIG['ruby_version']
              ]
-           elsif ConfigMap[:rubylibprefix] then
+           elsif RbConfig::CONFIG['rubylibprefix'] then
              [
-              ConfigMap[:rubylibprefix],
+              RbConfig::CONFIG['rubylibprefix'],
               'gems',
-              ConfigMap[:ruby_version]
+              RbConfig::CONFIG['ruby_version']
              ]
            else
              [
-               ConfigMap[:libdir],
+               RbConfig::CONFIG['libdir'],
                ruby_engine,
                'gems',
-               ConfigMap[:ruby_version]
+               RbConfig::CONFIG['ruby_version']
              ]
            end
 
@@ -52,6 +52,17 @@ module Gem
   end
 
   ##
+  # Returns binary extensions dir for specified RubyGems base dir or nil
+  # if such directory cannot be determined.
+  #
+  # By default, the binary extensions are located side by side with their
+  # Ruby counterparts, therefore nil is returned
+
+  def self.default_ext_dir_for base_dir
+    nil
+  end
+
+  ##
   # Paths where RubyGems' .rb files and bin files are installed
 
   def self.default_rubygems_dirs
@@ -63,7 +74,7 @@ module Gem
 
   def self.user_dir
     parts = [Gem.user_home, '.gem', ruby_engine]
-    parts << ConfigMap[:ruby_version] unless ConfigMap[:ruby_version].empty?
+    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
     File.join parts
   end
 
@@ -78,18 +89,18 @@ module Gem
   # Default gem load path
 
   def self.default_path
-    if Gem.user_home && File.exist?(Gem.user_home) then
-      [user_dir, default_dir]
-    else
-      [default_dir]
-    end
+    path = []
+    path << user_dir if user_home && File.exist?(user_home)
+    path << default_dir
+    path << vendor_dir if vendor_dir and File.directory? vendor_dir
+    path
   end
 
   ##
   # Deduce Ruby's --program-prefix and --program-suffix from its install name
 
   def self.default_exec_format
-    exec_format = ConfigMap[:ruby_install_name].sub('ruby', '%s') rescue '%s'
+    exec_format = RbConfig::CONFIG['ruby_install_name'].sub('ruby', '%s') rescue '%s'
 
     unless exec_format =~ /%s/ then
       raise Gem::Exception,
@@ -106,7 +117,7 @@ module Gem
     if defined? RUBY_FRAMEWORK_VERSION then # mac framework support
       '/usr/bin'
     else # generic install
-      ConfigMap[:bindir]
+      RbConfig::CONFIG['bindir']
     end
   end
 
@@ -141,4 +152,26 @@ module Gem
   def self.default_gems_use_full_paths?
     ruby_engine != 'ruby'
   end
+
+  ##
+  # Install extensions into lib as well as into the extension directory.
+
+  def self.install_extension_in_lib # :nodoc:
+    true
+  end
+
+  ##
+  # Directory where vendor gems are installed.
+
+  def self.vendor_dir # :nodoc:
+    if vendor_dir = ENV['GEM_VENDOR'] then
+      return vendor_dir.dup
+    end
+
+    return nil unless RbConfig::CONFIG.key? 'vendordir'
+
+    File.join RbConfig::CONFIG['vendordir'], 'gems',
+              RbConfig::CONFIG['ruby_version']
+  end
+
 end
diff --git a/jruby/lib/ruby/shared/rubygems/dependency.rb b/jruby/lib/ruby/shared/rubygems/dependency.rb
index a96d67c..5924d2f 100644
--- a/jruby/lib/ruby/shared/rubygems/dependency.rb
+++ b/jruby/lib/ruby/shared/rubygems/dependency.rb
@@ -74,7 +74,7 @@ class Gem::Dependency
   end
 
   def inspect # :nodoc:
-    if @prerelease
+    if prerelease? then
       "<%s type=%p name=%p requirements=%p prerelease=ok>" %
         [self.class, self.type, self.name, requirement.to_s]
     else
@@ -145,7 +145,6 @@ class Gem::Dependency
     @requirement = @version_requirements if defined?(@version_requirements)
   end
 
-  # DOC: this method needs documentation or :nodoc''d
   def requirements_list
     requirement.as_list
   end
@@ -205,9 +204,19 @@ class Gem::Dependency
 
   alias === =~
 
-  # DOC: this method needs either documented or :nodoc'd
+  ##
+  # :call-seq:
+  #   dep.match? name          => true or false
+  #   dep.match? name, version => true or false
+  #   dep.match? spec          => true or false
+  #
+  # Does this dependency match the specification described by +name+ and
+  # +version+ or match +spec+?
+  #
+  # NOTE:  Unlike #matches_spec? this method does not return true when the
+  # version is a prerelease version unless this is a prerelease dependency.
 
-  def match? obj, version=nil
+  def match? obj, version=nil, allow_prerelease=false
     if !version
       name = obj.name
       version = obj.version
@@ -216,12 +225,23 @@ class Gem::Dependency
     end
 
     return false unless self.name === name
-    return true if requirement.none?
 
-    requirement.satisfied_by? Gem::Version.new(version)
+    version = Gem::Version.new version
+
+    return true if requirement.none? and not version.prerelease?
+    return false if version.prerelease? and
+                    not allow_prerelease and
+                    not prerelease?
+
+    requirement.satisfied_by? version
   end
 
-  # DOC: this method needs either documented or :nodoc'd
+  ##
+  # Does this dependency match +spec+?
+  #
+  # NOTE:  This is not a convenience method.  Unlike #match? this method
+  # returns true when +spec+ is a prerelease version even if this dependency
+  # is not a prerelease dependency.
 
   def matches_spec? spec
     return false unless name === spec.name
@@ -249,8 +269,6 @@ class Gem::Dependency
     self.class.new name, self_req.as_list.concat(other_req.as_list)
   end
 
-  # DOC: this method needs either documented or :nodoc'd
-
   def matching_specs platform_only = false
     matches = Gem::Specification.stubs.find_all { |spec|
       self.name === spec.name and # TODO: == instead of ===
@@ -263,7 +281,7 @@ class Gem::Dependency
       }
     end
 
-    matches = matches.sort_by { |s| s.sort_obj } # HACK: shouldn't be needed
+    matches.sort_by { |s| s.sort_obj } # HACK: shouldn't be needed
   end
 
   ##
@@ -273,8 +291,6 @@ class Gem::Dependency
     @requirement.specific?
   end
 
-  # DOC: this method needs either documented or :nodoc'd
-
   def to_specs
     matches = matching_specs true
 
@@ -287,12 +303,13 @@ class Gem::Dependency
 
       if specs.empty?
         total = Gem::Specification.to_a.size
-        error = Gem::LoadError.new \
-          "Could not find '#{name}' (#{requirement}) among #{total} total gem(s)"
+        msg   = "Could not find '#{name}' (#{requirement}) among #{total} total gem(s)\n"
       else
-        error = Gem::LoadError.new \
-          "Could not find '#{name}' (#{requirement}) - did find: [#{specs.join ','}]"
+        msg   = "Could not find '#{name}' (#{requirement}) - did find: [#{specs.join ','}]\n"
       end
+      msg << "Checked in 'GEM_PATH=#{Gem.path.join(File::PATH_SEPARATOR)}', execute `gem env` for more information"
+
+      error = Gem::LoadError.new(msg)
       error.name        = self.name
       error.requirement = self.requirement
       raise error
@@ -303,11 +320,15 @@ class Gem::Dependency
     matches
   end
 
-  # DOC: this method needs either documented or :nodoc'd
-
   def to_spec
     matches = self.to_specs
 
-    matches.find { |spec| spec.activated? } or matches.last
+    active = matches.find { |spec| spec.activated? }
+
+    return active if active
+
+    matches.delete_if { |spec| spec.version.prerelease? } unless prerelease?
+
+    matches.last
   end
 end
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_installer.rb b/jruby/lib/ruby/shared/rubygems/dependency_installer.rb
index 8947e81..9741554 100644
--- a/jruby/lib/ruby/shared/rubygems/dependency_installer.rb
+++ b/jruby/lib/ruby/shared/rubygems/dependency_installer.rb
@@ -1,6 +1,5 @@
 require 'rubygems'
 require 'rubygems/dependency_list'
-require 'rubygems/dependency_resolver'
 require 'rubygems/package'
 require 'rubygems/installer'
 require 'rubygems/spec_fetcher'
@@ -73,6 +72,7 @@ class Gem::DependencyInstaller
   def initialize options = {}
     @only_install_dir = !!options[:install_dir]
     @install_dir = options[:install_dir] || Gem.dir
+    @build_root = options[:build_root]
 
     options = DEFAULT_OPTIONS.merge options
 
@@ -103,7 +103,7 @@ class Gem::DependencyInstaller
 
     @cache_dir = options[:cache_dir] || @install_dir
 
-    @errors = nil
+    @errors = []
   end
 
   ##
@@ -158,6 +158,7 @@ class Gem::DependencyInstaller
 
     dependency_list.remove_specs_unsatisfied_by dependencies
   end
+
   ##
   # Creates an AvailableSet to install from based on +dep_or_name+ and
   # +version+
@@ -196,7 +197,7 @@ class Gem::DependencyInstaller
   # sources.  Gems are sorted with newer gems preferred over older gems, and
   # local gems preferred over remote gems.
 
-  def find_gems_with_sources dep # :nodoc:
+  def find_gems_with_sources dep, best_only=false # :nodoc:
     set = Gem::AvailableSet.new
 
     if consider_local?
@@ -211,7 +212,36 @@ class Gem::DependencyInstaller
 
     if consider_remote?
       begin
-        found, errors = Gem::SpecFetcher.fetcher.spec_for_dependency dep
+        # TODO this is pulled from #spec_for_dependency to allow
+        # us to filter tuples before fetching specs.
+        #
+        tuples, errors = Gem::SpecFetcher.fetcher.search_for_dependency dep
+
+        if best_only && !tuples.empty?
+          tuples.sort! do |a,b|
+            if b[0].version == a[0].version
+              if b[0].platform != Gem::Platform::RUBY
+                1
+              else
+                -1
+              end
+            else
+              b[0].version <=> a[0].version
+            end
+          end
+          tuples = [tuples.first]
+        end
+
+        specs = []
+        tuples.each do |tup, source|
+          begin
+            spec = source.fetch_spec(tup)
+          rescue Gem::RemoteFetcher::FetchError => e
+            errors << Gem::SourceFetchProblem.new(source, e)
+          else
+            specs << [spec, source]
+          end
+        end
 
         if @errors
           @errors += errors
@@ -219,15 +249,15 @@ class Gem::DependencyInstaller
           @errors = errors
         end
 
-        set << found
+        set << specs
 
       rescue Gem::RemoteFetcher::FetchError => e
         # FIX if there is a problem talking to the network, we either need to always tell
         # the user (no really_verbose) or fail hard, not silently tell them that we just
         # couldn't find their requested gem.
-        if Gem.configuration.really_verbose then
-          say "Error fetching remote data:\t\t#{e.message}"
-          say "Falling back to local-only install"
+        verbose do
+          "Error fetching remote data:\t\t#{e.message}\n" \
+            "Falling back to local-only install"
         end
         @domain = :local
       end
@@ -250,6 +280,14 @@ class Gem::DependencyInstaller
       if gem_name =~ /\.gem$/ and File.file? gem_name then
         src = Gem::Source::SpecificFile.new(gem_name)
         set.add src.spec, src
+      elsif gem_name =~ /\.gem$/ then
+        Dir[gem_name].each do |name|
+          begin
+            src = Gem::Source::SpecificFile.new name
+            set.add src.spec, src
+          rescue Gem::Package::FormatError
+          end
+        end
       else
         local = Gem::Source::Local.new
 
@@ -263,7 +301,7 @@ class Gem::DependencyInstaller
       dep = Gem::Dependency.new gem_name, version
       dep.prerelease = true if prerelease
 
-      set = find_gems_with_sources(dep)
+      set = find_gems_with_sources(dep, true)
       set.match_platform!
     end
 
@@ -278,7 +316,7 @@ class Gem::DependencyInstaller
   # Gathers all dependencies necessary for the installation from local and
   # remote sources unless the ignore_dependencies was given.
   #--
-  # TODO remove, no longer used
+  # TODO remove at RubyGems 3
 
   def gather_dependencies # :nodoc:
     specs = @available.all_specs
@@ -349,13 +387,16 @@ class Gem::DependencyInstaller
     options = {
       :bin_dir             => @bin_dir,
       :build_args          => @build_args,
+      :document            => @document,
       :env_shebang         => @env_shebang,
       :force               => @force,
       :format_executable   => @format_executable,
       :ignore_dependencies => @ignore_dependencies,
+      :prerelease          => @prerelease,
       :security_policy     => @security_policy,
       :user_install        => @user_install,
       :wrappers            => @wrappers,
+      :build_root          => @build_root,
       :install_as_default  => @install_as_default
     }
     options[:install_dir] = @install_dir if @only_install_dir
@@ -389,23 +430,59 @@ class Gem::DependencyInstaller
   end
 
   def resolve_dependencies dep_or_name, version # :nodoc:
-    as = available_set_for dep_or_name, version
-
-    request_set = as.to_request_set install_development_deps
+    request_set = Gem::RequestSet.new
+    request_set.development         = @development
+    request_set.development_shallow = @dev_shallow
     request_set.soft_missing = @force
+    request_set.prerelease = @prerelease
+    request_set.remote = false unless consider_remote?
 
-    installer_set = Gem::DependencyResolver::InstallerSet.new @domain
-    installer_set.always_install.concat request_set.always_install
+    installer_set = Gem::Resolver::InstallerSet.new @domain
     installer_set.ignore_installed = @only_install_dir
 
+    if consider_local?
+      if dep_or_name =~ /\.gem$/ and File.file? dep_or_name then
+        src = Gem::Source::SpecificFile.new dep_or_name
+        installer_set.add_local dep_or_name, src.spec, src
+        version = src.spec.version if version == Gem::Requirement.default
+      elsif dep_or_name =~ /\.gem$/ then
+        Dir[dep_or_name].each do |name|
+          begin
+            src = Gem::Source::SpecificFile.new name
+            installer_set.add_local dep_or_name, src.spec, src
+          rescue Gem::Package::FormatError
+          end
+        end
+      # else This is a dependency. InstallerSet handles this case
+      end
+    end
+
+    dependency =
+      if spec = installer_set.local?(dep_or_name) then
+        Gem::Dependency.new spec.name, version
+      elsif String === dep_or_name then
+        Gem::Dependency.new dep_or_name, version
+      else
+        dep_or_name
+      end
+
+    dependency.prerelease = @prerelease
+
+    request_set.import [dependency]
+
+    installer_set.add_always_install dependency
+
+    request_set.always_install = installer_set.always_install
+
     if @ignore_dependencies then
       installer_set.ignore_dependencies = true
-      request_set.soft_missing = true
+      request_set.ignore_dependencies   = true
+      request_set.soft_missing          = true
     end
 
-    composed_set = Gem::DependencyResolver.compose_sets as, installer_set
+    request_set.resolve installer_set
 
-    request_set.resolve composed_set
+    @errors.concat request_set.errors
 
     request_set
   end
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_list.rb b/jruby/lib/ruby/shared/rubygems/dependency_list.rb
index 3e40325..ad7a82a 100644
--- a/jruby/lib/ruby/shared/rubygems/dependency_list.rb
+++ b/jruby/lib/ruby/shared/rubygems/dependency_list.rb
@@ -219,11 +219,7 @@ class Gem::DependencyList
     dependencies.each do |dep|
       specs.each do |spec|
         if spec.satisfies_requirement? dep then
-          begin
-            yield spec
-          rescue TSort::Cyclic
-            # do nothing
-          end
+          yield spec
           break
         end
       end
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver.rb
deleted file mode 100644
index abce692..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver.rb
+++ /dev/null
@@ -1,254 +0,0 @@
-require 'rubygems'
-require 'rubygems/dependency'
-require 'rubygems/exceptions'
-require 'rubygems/util/list'
-
-require 'uri'
-require 'net/http'
-
-##
-# Given a set of Gem::Dependency objects as +needed+ and a way to query the
-# set of available specs via +set+, calculates a set of ActivationRequest
-# objects which indicate all the specs that should be activated to meet the
-# all the requirements.
-
-class Gem::DependencyResolver
-
-  ##
-  # Contains all the conflicts encountered while doing resolution
-
-  attr_reader :conflicts
-
-  attr_accessor :development
-
-  attr_reader :missing
-
-  ##
-  # When a missing dependency, don't stop. Just go on and record what was
-  # missing.
-
-  attr_accessor :soft_missing
-
-  def self.compose_sets *sets
-    Gem::DependencyResolver::ComposedSet.new(*sets)
-  end
-
-  ##
-  # Provide a DependencyResolver that queries only against the already
-  # installed gems.
-
-  def self.for_current_gems needed
-    new needed, Gem::DependencyResolver::CurrentSet.new
-  end
-
-  ##
-  # Create DependencyResolver object which will resolve the tree starting
-  # with +needed+ Depedency objects.
-  #
-  # +set+ is an object that provides where to look for specifications to
-  # satisify the Dependencies. This defaults to IndexSet, which will query
-  # rubygems.org.
-
-  def initialize needed, set = nil
-    @set = set || Gem::DependencyResolver::IndexSet.new
-    @needed = needed
-
-    @conflicts    = nil
-    @development  = false
-    @missing      = []
-    @soft_missing = false
-  end
-
-  def requests s, act, reqs=nil
-    s.dependencies.reverse_each do |d|
-      next if d.type == :development and not @development
-      reqs = Gem::List.new Gem::DependencyResolver::DependencyRequest.new(d, act), reqs
-    end
-
-    @set.prefetch reqs
-
-    reqs
-  end
-
-  ##
-  # Proceed with resolution! Returns an array of ActivationRequest objects.
-
-  def resolve
-    @conflicts = []
-
-    needed = nil
-
-    @needed.reverse_each do |n|
-      request = Gem::DependencyResolver::DependencyRequest.new n, nil
-
-      needed = Gem::List.new request, needed
-    end
-
-    res = resolve_for needed, nil
-
-    raise Gem::DependencyResolutionError, res if
-      res.kind_of? Gem::DependencyResolver::DependencyConflict
-
-    res.to_a
-  end
-
-  ##
-  # The meat of the algorithm. Given +needed+ DependencyRequest objects and
-  # +specs+ being a list to ActivationRequest, calculate a new list of
-  # ActivationRequest objects.
-
-  def resolve_for needed, specs
-    while needed
-      dep = needed.value
-      needed = needed.tail
-
-      # If there is already a spec activated for the requested name...
-      if specs && existing = specs.find { |s| dep.name == s.name }
-
-        # then we're done since this new dep matches the
-        # existing spec.
-        next if dep.matches_spec? existing
-
-        # There is a conflict! We return the conflict
-        # object which will be seen by the caller and be
-        # handled at the right level.
-
-        # If the existing activation indicates that there
-        # are other possibles for it, then issue the conflict
-        # on the dep for the activation itself. Otherwise, issue
-        # it on the requester's request itself.
-        #
-        if existing.others_possible?
-          conflict =
-            Gem::DependencyResolver::DependencyConflict.new dep, existing
-        else
-          depreq = existing.request.requester.request
-          conflict =
-            Gem::DependencyResolver::DependencyConflict.new depreq, existing, dep
-        end
-        @conflicts << conflict
-
-        return conflict
-      end
-
-      # Get a list of all specs that satisfy dep and platform
-      possible = @set.find_all dep
-      possible = select_local_platforms possible
-
-      case possible.size
-      when 0
-        @missing << dep
-
-        unless @soft_missing
-          # If there are none, then our work here is done.
-          raise Gem::UnsatisfiableDependencyError, dep
-        end
-      when 1
-        # If there is one, then we just add it to specs
-        # and process the specs dependencies by adding
-        # them to needed.
-
-        spec = possible.first
-        act = Gem::DependencyResolver::ActivationRequest.new spec, dep, false
-
-        specs = Gem::List.prepend specs, act
-
-        # Put the deps for at the beginning of needed
-        # rather than the end to match the depth first
-        # searching done by the multiple case code below.
-        #
-        # This keeps the error messages consistent.
-        needed = requests(spec, act, needed)
-      else
-        # There are multiple specs for this dep. This is
-        # the case that this class is built to handle.
-
-        # Sort them so that we try the highest versions
-        # first.
-        possible = possible.sort_by do |s|
-          [s.source, s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
-        end
-
-        # We track the conflicts seen so that we can report them
-        # to help the user figure out how to fix the situation.
-        conflicts = []
-
-        # To figure out which to pick, we keep resolving
-        # given each one being activated and if there isn't
-        # a conflict, we know we've found a full set.
-        #
-        # We use an until loop rather than #reverse_each
-        # to keep the stack short since we're using a recursive
-        # algorithm.
-        #
-        until possible.empty?
-          s = possible.pop
-
-          # Recursively call #resolve_for with this spec
-          # and add it's dependencies into the picture...
-
-          act = Gem::DependencyResolver::ActivationRequest.new s, dep
-
-          try = requests(s, act, needed)
-
-          res = resolve_for try, Gem::List.prepend(specs, act)
-
-          # While trying to resolve these dependencies, there may
-          # be a conflict!
-
-          if res.kind_of? Gem::DependencyResolver::DependencyConflict
-            # The conflict might be created not by this invocation
-            # but rather one up the stack, so if we can't attempt
-            # to resolve this conflict (conflict isn't with the spec +s+)
-            # then just return it so the caller can try to sort it out.
-            return res unless res.for_spec? s
-
-            # Otherwise, this is a conflict that we can attempt to fix
-            conflicts << [s, res]
-
-            # Optimization:
-            #
-            # Because the conflict indicates the dependency that trigger
-            # it, we can prune possible based on this new information.
-            #
-            # This cuts down on the number of iterations needed.
-            possible.delete_if { |x| !res.dependency.matches_spec? x }
-          else
-            # No conflict, return the specs
-            return res
-          end
-        end
-
-        # We tried all possibles and nothing worked, so we let the user
-        # know and include as much information about the problem since
-        # the user is going to have to take action to fix this.
-        raise Gem::ImpossibleDependenciesError.new(dep, conflicts)
-      end
-    end
-
-    specs
-  end
-
-  ##
-  # Returns the gems in +specs+ that match the local platform.
-
-  def select_local_platforms specs # :nodoc:
-    specs.select do |spec|
-      Gem::Platform.match spec.platform
-    end
-  end
-
-end
-
-require 'rubygems/dependency_resolver/api_set'
-require 'rubygems/dependency_resolver/api_specification'
-require 'rubygems/dependency_resolver/activation_request'
-require 'rubygems/dependency_resolver/composed_set'
-require 'rubygems/dependency_resolver/current_set'
-require 'rubygems/dependency_resolver/dependency_conflict'
-require 'rubygems/dependency_resolver/dependency_request'
-require 'rubygems/dependency_resolver/index_set'
-require 'rubygems/dependency_resolver/index_specification'
-require 'rubygems/dependency_resolver/installed_specification'
-require 'rubygems/dependency_resolver/installer_set'
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/activation_request.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/activation_request.rb
deleted file mode 100644
index 25af637..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/activation_request.rb
+++ /dev/null
@@ -1,109 +0,0 @@
-##
-# Specifies a Specification object that should be activated.
-# Also contains a dependency that was used to introduce this
-# activation.
-
-class Gem::DependencyResolver::ActivationRequest
-
-  attr_reader :request
-
-  attr_reader :spec
-
-  def initialize spec, req, others_possible = true
-    @spec = spec
-    @request = req
-    @others_possible = others_possible
-  end
-
-  def == other
-    case other
-    when Gem::Specification
-      @spec == other
-    when Gem::DependencyResolver::ActivationRequest
-      @spec == other.spec && @request == other.request
-    else
-      false
-    end
-  end
-
-  def download path
-    if @spec.respond_to? :source
-      source = @spec.source
-    else
-      source = Gem.sources.first
-    end
-
-    Gem.ensure_gem_subdirectories path
-
-    source.download full_spec, path
-  end
-
-  def full_name
-    @spec.full_name
-  end
-
-  def full_spec
-    Gem::Specification === @spec ? @spec : @spec.spec
-  end
-
-  def inspect # :nodoc:
-    others_possible = nil
-    others_possible = ' (others possible)' if @others_possible
-
-    '#<%s for %p from %s%s>' % [
-      self.class, @spec, @request, others_possible
-    ]
-  end
-
-  ##
-  # Indicates if the requested gem has already been installed.
-
-  def installed?
-    this_spec = full_spec
-
-    Gem::Specification.any? do |s|
-      s == this_spec
-    end
-  end
-
-  def name
-    @spec.name
-  end
-
-  ##
-  # Indicate if this activation is one of a set of possible
-  # requests for the same Dependency request.
-
-  def others_possible?
-    @others_possible
-  end
-
-  ##
-  # Return the ActivationRequest that contained the dependency
-  # that we were activated for.
-
-  def parent
-    @request.requester
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Activation request', ']' do
-      q.breakable
-      q.pp @spec
-
-      q.breakable
-      q.text ' for '
-      q.pp @request
-
-
-      q.breakable
-      q.text ' (other possible)' if @others_possible
-    end
-  end
-
-  def version
-    @spec.version
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/api_set.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/api_set.rb
deleted file mode 100644
index 469c005..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/api_set.rb
+++ /dev/null
@@ -1,65 +0,0 @@
-##
-# The global rubygems pool, available via the rubygems.org API.
-# Returns instances of APISpecification.
-
-class Gem::DependencyResolver::APISet
-
-  def initialize
-    @data = Hash.new { |h,k| h[k] = [] }
-    @dep_uri = URI 'https://rubygems.org/api/v1/dependencies'
-  end
-
-  ##
-  # Return an array of APISpecification objects matching
-  # DependencyRequest +req+.
-
-  def find_all req
-    res = []
-
-    versions(req.name).each do |ver|
-      if req.dependency.match? req.name, ver[:number]
-        res << Gem::DependencyResolver::APISpecification.new(self, ver)
-      end
-    end
-
-    res
-  end
-
-  ##
-  # A hint run by the resolver to allow the Set to fetch
-  # data for DependencyRequests +reqs+.
-
-  def prefetch reqs
-    names = reqs.map { |r| r.dependency.name }
-    needed = names.find_all { |d| !@data.key?(d) }
-
-    return if needed.empty?
-
-    uri = @dep_uri + "?gems=#{needed.sort.join ','}"
-    str = Gem::RemoteFetcher.fetcher.fetch_path uri
-
-    Marshal.load(str).each do |ver|
-      @data[ver[:name]] << ver
-    end
-  end
-
-  ##
-  # Return data for all versions of the gem +name+.
-
-  def versions name
-    if @data.key?(name)
-      return @data[name]
-    end
-
-    uri = @dep_uri + "?gems=#{name}"
-    str = Gem::RemoteFetcher.fetcher.fetch_path uri
-
-    Marshal.load(str).each do |ver|
-      @data[ver[:name]] << ver
-    end
-
-    @data[name]
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/api_specification.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/api_specification.rb
deleted file mode 100644
index ae68878..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/api_specification.rb
+++ /dev/null
@@ -1,39 +0,0 @@
-##
-# Represents a specification retrieved via the rubygems.org
-# API. This is used to avoid having to load the full
-# Specification object when all we need is the name, version,
-# and dependencies.
-
-class Gem::DependencyResolver::APISpecification
-
-  attr_reader :dependencies
-  attr_reader :name
-  attr_reader :platform
-  attr_reader :set # :nodoc:
-  attr_reader :version
-
-  def initialize(set, api_data)
-    @set = set
-    @name = api_data[:name]
-    @version = Gem::Version.new api_data[:number]
-    @platform = api_data[:platform]
-    @dependencies = api_data[:dependencies].map do |name, ver|
-      Gem::Dependency.new name, ver.split(/\s*,\s*/)
-    end
-  end
-
-  def == other # :nodoc:
-    self.class === other and
-      @set          == other.set and
-      @name         == other.name and
-      @version      == other.version and
-      @platform     == other.platform and
-      @dependencies == other.dependencies
-  end
-
-  def full_name
-    "#{@name}-#{@version}"
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/composed_set.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/composed_set.rb
deleted file mode 100644
index fb38128..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/composed_set.rb
+++ /dev/null
@@ -1,18 +0,0 @@
-class Gem::DependencyResolver::ComposedSet
-
-  def initialize *sets
-    @sets = sets
-  end
-
-  def find_all req
-    res = []
-    @sets.each { |s| res += s.find_all(req) }
-    res
-  end
-
-  def prefetch reqs
-    @sets.each { |s| s.prefetch(reqs) }
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/current_set.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/current_set.rb
deleted file mode 100644
index 13bc490..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/current_set.rb
+++ /dev/null
@@ -1,16 +0,0 @@
-##
-# A set which represents the installed gems. Respects
-# all the normal settings that control where to look
-# for installed gems.
-
-class Gem::DependencyResolver::CurrentSet
-
-  def find_all req
-    req.dependency.matching_specs
-  end
-
-  def prefetch gems
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_conflict.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_conflict.rb
deleted file mode 100644
index 1755d91..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_conflict.rb
+++ /dev/null
@@ -1,85 +0,0 @@
-##
-# Used internally to indicate that a dependency conflicted
-# with a spec that would be activated.
-
-class Gem::DependencyResolver::DependencyConflict
-
-  attr_reader :activated
-
-  attr_reader :dependency
-
-  def initialize(dependency, activated, failed_dep=dependency)
-    @dependency = dependency
-    @activated = activated
-    @failed_dep = failed_dep
-  end
-
-  ##
-  # Return the 2 dependency objects that conflicted
-
-  def conflicting_dependencies
-    [@failed_dep.dependency, @activated.request.dependency]
-  end
-
-  ##
-  # Explanation of the conflict used by exceptions to print useful messages
-
-  def explanation
-    activated   = @activated.spec.full_name
-    requirement = @failed_dep.dependency.requirement
-
-    "  Activated %s instead of (%s) via:\n    %s\n" % [
-      activated, requirement, request_path.join(', ')
-    ]
-  end
-
-  def for_spec?(spec)
-    @dependency.name == spec.name
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Dependency conflict: ', ']' do
-      q.breakable
-
-      q.text 'activated '
-      q.pp @activated
-
-      q.breakable
-      q.text ' dependency '
-      q.pp @dependency
-
-      q.breakable
-      if @dependency == @failed_dep then
-        q.text ' failed'
-      else
-        q.text ' failed dependency '
-        q.pp @failed_dep
-      end
-    end
-  end
-
-  ##
-  # Path of specifications that requested this dependency
-
-  def request_path
-    current = requester
-    path    = []
-
-    while current do
-      path << current.spec.full_name
-
-      current = current.request.requester
-    end
-
-    path
-  end
-
-  ##
-  # Return the Specification that listed the dependency
-
-  def requester
-    @failed_dep.requester
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_request.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_request.rb
deleted file mode 100644
index 05e447c..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/dependency_request.rb
+++ /dev/null
@@ -1,51 +0,0 @@
-##
-# Used Internally. Wraps a Dependency object to also track which spec
-# contained the Dependency.
-
-class Gem::DependencyResolver::DependencyRequest
-
-  attr_reader :dependency
-
-  attr_reader :requester
-
-  def initialize(dep, act)
-    @dependency = dep
-    @requester = act
-  end
-
-  def ==(other)
-    case other
-    when Gem::Dependency
-      @dependency == other
-    when Gem::DependencyResolver::DependencyRequest
-      @dependency == other.dependency && @requester == other.requester
-    else
-      false
-    end
-  end
-
-  def matches_spec?(spec)
-    @dependency.matches_spec? spec
-  end
-
-  def name
-    @dependency.name
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Dependency request ', ']' do
-      q.breakable
-      q.text @dependency.to_s
-
-      q.breakable
-      q.text ' requested by '
-      q.pp @requester
-    end
-  end
-
-  def to_s # :nodoc:
-    @dependency.to_s
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/index_set.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/index_set.rb
deleted file mode 100644
index 8c8bc43..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/index_set.rb
+++ /dev/null
@@ -1,64 +0,0 @@
-##
-# The global rubygems pool represented via the traditional
-# source index.
-
-class Gem::DependencyResolver::IndexSet
-
-  def initialize
-    @f = Gem::SpecFetcher.fetcher
-
-    @all = Hash.new { |h,k| h[k] = [] }
-
-    list, = @f.available_specs :released
-
-    list.each do |uri, specs|
-      specs.each do |n|
-        @all[n.name] << [uri, n]
-      end
-    end
-
-    @specs = {}
-  end
-
-  ##
-  # Return an array of IndexSpecification objects matching
-  # DependencyRequest +req+.
-
-  def find_all req
-    res = []
-
-    name = req.dependency.name
-
-    @all[name].each do |uri, n|
-      if req.dependency.match? n then
-        res << Gem::DependencyResolver::IndexSpecification.new(
-          self, n.name, n.version, uri, n.platform)
-      end
-    end
-
-    res
-  end
-
-  ##
-  # Called from IndexSpecification to get a true Specification
-  # object.
-
-  def load_spec name, ver, platform, source
-    key = "#{name}-#{ver}-#{platform}"
-
-    @specs.fetch key do
-      tuple = Gem::NameTuple.new name, ver, platform
-
-      @specs[key] = source.fetch_spec tuple
-    end
-  end
-
-  ##
-  # No prefetching needed since we load the whole index in
-  # initially.
-
-  def prefetch gems
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/index_specification.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/index_specification.rb
deleted file mode 100644
index 7ffb32e..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/index_specification.rb
+++ /dev/null
@@ -1,60 +0,0 @@
-##
-# Represents a possible Specification object returned
-# from IndexSet. Used to delay needed to download full
-# Specification objects when only the +name+ and +version+
-# are needed.
-
-class Gem::DependencyResolver::IndexSpecification
-
-  attr_reader :name
-
-  attr_reader :platform
-
-  attr_reader :source
-
-  attr_reader :version
-
-  def initialize set, name, version, source, platform
-    @set = set
-    @name = name
-    @version = version
-    @source = source
-    @platform = platform.to_s
-
-    @spec = nil
-  end
-
-  def dependencies
-    spec.dependencies
-  end
-
-  def full_name
-    "#{@name}-#{@version}"
-  end
-
-  def inspect # :nodoc:
-    '#<%s %s source %s>' % [self.class, full_name, @source]
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[Index specification', ']' do
-      q.breakable
-      q.text full_name
-
-      unless Gem::Platform::RUBY == @platform then
-        q.breakable
-        q.text @platform.to_s
-      end
-
-      q.breakable
-      q.text 'source '
-      q.pp @source
-    end
-  end
-
-  def spec
-    @spec ||= @set.load_spec(@name, @version, @platform, @source)
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/installed_specification.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/installed_specification.rb
deleted file mode 100644
index ca20ace..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/installed_specification.rb
+++ /dev/null
@@ -1,42 +0,0 @@
-class Gem::DependencyResolver::InstalledSpecification
-
-  attr_reader :spec
-
-  def initialize set, spec, source=nil
-    @set    = set
-    @source = source
-    @spec   = spec
-  end
-
-  def == other # :nodoc:
-    self.class === other and
-      @set  == other.set and
-      @spec == other.spec
-  end
-
-  def dependencies
-    @spec.dependencies
-  end
-
-  def full_name
-    "#{@spec.name}-#{@spec.version}"
-  end
-
-  def name
-    @spec.name
-  end
-
-  def platform
-    @spec.platform
-  end
-
-  def source
-    @source ||= Gem::Source::Installed.new
-  end
-
-  def version
-    @spec.version
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/dependency_resolver/installer_set.rb b/jruby/lib/ruby/shared/rubygems/dependency_resolver/installer_set.rb
deleted file mode 100644
index e19fcd7..0000000
--- a/jruby/lib/ruby/shared/rubygems/dependency_resolver/installer_set.rb
+++ /dev/null
@@ -1,154 +0,0 @@
-class Gem::DependencyResolver::InstallerSet
-
-  ##
-  # List of Gem::Specification objects that must always be installed.
-
-  attr_reader :always_install
-
-  ##
-  # Only install gems in the always_install list
-
-  attr_accessor :ignore_dependencies
-
-  ##
-  # Do not look in the installed set when finding specifications.  This is
-  # used by the --install-dir option to `gem install`
-
-  attr_accessor :ignore_installed
-
-  def initialize domain
-    @domain = domain
-
-    @f = Gem::SpecFetcher.fetcher
-
-    @all = Hash.new { |h,k| h[k] = [] }
-    @always_install      = []
-    @ignore_dependencies = false
-    @ignore_installed    = false
-    @loaded_remote_specs = []
-    @specs               = {}
-  end
-
-  ##
-  # Should local gems should be considered?
-
-  def consider_local?
-    @domain == :both or @domain == :local
-  end
-
-  ##
-  # Should remote gems should be considered?
-
-  def consider_remote?
-    @domain == :both or @domain == :remote
-  end
-
-  ##
-  # Returns an array of IndexSpecification objects matching DependencyRequest
-  # +req+.
-
-  def find_all req
-    res = []
-
-    dep  = req.dependency
-
-    return res if @ignore_dependencies and
-              @always_install.none? { |spec| dep.matches_spec? spec }
-
-    name = dep.name
-
-    dep.matching_specs.each do |gemspec|
-      next if @always_install.include? gemspec
-
-      res << Gem::DependencyResolver::InstalledSpecification.new(self, gemspec)
-    end unless @ignore_installed
-
-    if consider_local? then
-      local_source = Gem::Source::Local.new
-
-      if spec = local_source.find_gem(name, dep.requirement) then
-        res << Gem::DependencyResolver::IndexSpecification.new(
-          self, spec.name, spec.version, local_source, spec.platform)
-      end
-    end
-
-    if consider_remote? then
-      load_remote_specs dep
-
-      @all[name].each do |remote_source, n|
-        if dep.match? n then
-          res << Gem::DependencyResolver::IndexSpecification.new(
-            self, n.name, n.version, remote_source, n.platform)
-        end
-      end
-    end
-
-    res
-  end
-
-  def inspect # :nodoc:
-    always_install = @always_install.map { |s| s.full_name }
-
-    '#<%s domain: %s specs: %p always install: %p>' % [
-      self.class, @domain, @specs.keys, always_install,
-    ]
-  end
-
-  ##
-  # Loads remote prerelease specs if +dep+ is a prerelease dependency
-
-  def load_remote_specs dep
-    types = [:released]
-    types << :prerelease if dep.prerelease?
-
-    types.each do |type|
-      next if @loaded_remote_specs.include? type
-      @loaded_remote_specs << type
-
-      list, = @f.available_specs type
-
-      list.each do |uri, specs|
-        specs.each do |n|
-          @all[n.name] << [uri, n]
-        end
-      end
-    end
-  end
-
-  ##
-  # Called from IndexSpecification to get a true Specification
-  # object.
-
-  def load_spec name, ver, platform, source
-    key = "#{name}-#{ver}-#{platform}"
-
-    @specs.fetch key do
-      tuple = Gem::NameTuple.new name, ver, platform
-
-      @specs[key] = source.fetch_spec tuple
-    end
-  end
-
-  ##
-  # No prefetching needed since we load the whole index in initially.
-
-  def prefetch(reqs)
-  end
-
-  def pretty_print q # :nodoc:
-    q.group 2, '[InstallerSet', ']' do
-      q.breakable
-      q.text "domain: #{@domain}"
-
-      q.breakable
-      q.text 'specs: '
-      q.pp @specs.keys
-
-      q.breakable
-      q.text 'always install: '
-      q.pp @always_install
-    end
-  end
-
-end
-
diff --git a/jruby/lib/ruby/shared/rubygems/deprecate.rb b/jruby/lib/ruby/shared/rubygems/deprecate.rb
index 274d6a5..e19360d 100644
--- a/jruby/lib/ruby/shared/rubygems/deprecate.rb
+++ b/jruby/lib/ruby/shared/rubygems/deprecate.rb
@@ -50,7 +50,7 @@ module Gem::Deprecate
     class_eval {
       old = "_deprecated_#{name}"
       alias_method old, name
-      define_method name do |*args, &block| # TODO: really works on 1.8.7?
+      define_method name do |*args, &block|
         klass = self.kind_of? Module
         target = klass ? "#{self}." : "#{self.class}#"
         msg = [ "NOTE: #{target}#{name} is deprecated",
diff --git a/jruby/lib/ruby/shared/rubygems/doctor.rb b/jruby/lib/ruby/shared/rubygems/doctor.rb
index 4fb399e..3c71fd5 100644
--- a/jruby/lib/ruby/shared/rubygems/doctor.rb
+++ b/jruby/lib/ruby/shared/rubygems/doctor.rb
@@ -1,6 +1,5 @@
 require 'rubygems'
 require 'rubygems/user_interaction'
-require 'pathname'
 
 ##
 # Cleans up after a partially-failed uninstall or for an invalid
@@ -24,13 +23,17 @@ class Gem::Doctor
     ['build_info',     '.info'],
     ['cache',          '.gem'],
     ['doc',            ''],
+    ['extensions',     ''],
     ['gems',           ''],
   ]
 
-  raise 'Update REPOSITORY_EXTENSION_MAP' unless
-    Gem::REPOSITORY_SUBDIRECTORIES.sort ==
+  missing =
+    Gem::REPOSITORY_SUBDIRECTORIES.sort -
       REPOSITORY_EXTENSION_MAP.map { |(k,_)| k }.sort
 
+  raise "Update REPOSITORY_EXTENSION_MAP, missing: #{missing.join ', '}" unless
+    missing.empty?
+
   ##
   # Creates a new Gem::Doctor that will clean up +gem_repository+.  Only one
   # gem repository may be cleaned at a time.
@@ -38,7 +41,7 @@ class Gem::Doctor
   # If +dry_run+ is true no files or directories will be removed.
 
   def initialize gem_repository, dry_run = false
-    @gem_repository = Pathname(gem_repository)
+    @gem_repository = gem_repository
     @dry_run        = dry_run
 
     @installed_specs = nil
@@ -96,26 +99,29 @@ class Gem::Doctor
   # Removes files in +sub_directory+ with +extension+
 
   def doctor_child sub_directory, extension # :nodoc:
-    directory = @gem_repository + sub_directory
+    directory = File.join(@gem_repository, sub_directory)
+
+    Dir.entries(directory).sort.each do |ent|
+      next if ent == "." || ent == ".."
 
-    directory.children.sort.each do |child|
-      next unless child.exist?
+      child = File.join(directory, ent)
+      next unless File.exist?(child)
 
-      basename = child.basename(extension).to_s
+      basename = File.basename(child, extension)
       next if installed_specs.include? basename
       next if /^rubygems-\d/ =~ basename
       next if 'specifications' == sub_directory and 'default' == basename
 
-      type = child.directory? ? 'directory' : 'file'
+      type = File.directory?(child) ? 'directory' : 'file'
 
       action = if @dry_run then
                  'Extra'
                else
-                 child.rmtree
+                 FileUtils.rm_r(child)
                  'Removed'
                end
 
-      say "#{action} #{type} #{sub_directory}/#{child.basename}"
+      say "#{action} #{type} #{sub_directory}/#{File.basename(child)}"
     end
   rescue Errno::ENOENT
     # ignore
diff --git a/jruby/lib/ruby/shared/rubygems/errors.rb b/jruby/lib/ruby/shared/rubygems/errors.rb
index e296ef3..9defb9e 100644
--- a/jruby/lib/ruby/shared/rubygems/errors.rb
+++ b/jruby/lib/ruby/shared/rubygems/errors.rb
@@ -19,8 +19,36 @@ module Gem
     attr_accessor :requirement
   end
 
-  # FIX: does this need to exist? The subclass is the only other reference
-  # I can find.
+  # Raised when there are conflicting gem specs loaded
+
+  class ConflictError < LoadError
+
+    ##
+    # A Hash mapping conflicting specifications to the dependencies that
+    # caused the conflict
+
+    attr_reader :conflicts
+
+    ##
+    # The specification that had the conflict
+
+    attr_reader :target
+
+    def initialize target, conflicts
+      @target    = target
+      @conflicts = conflicts
+      @name      = target.name
+
+      reason = conflicts.map { |act, dependencies|
+        "#{act.full_name} conflicts with #{dependencies.join(", ")}"
+      }.join ", "
+
+      # TODO: improve message by saying who activated `con`
+
+      super("Unable to activate #{target.full_name}, because #{reason}")
+    end
+  end
+
   class ErrorReason; end
 
   # Generated when trying to lookup a gem to indicate that the gem
@@ -75,15 +103,35 @@ module Gem
   # data from a source
 
   class SourceFetchProblem < ErrorReason
+
+    ##
+    # Creates a new SourceFetchProblem for the given +source+ and +error+.
+
     def initialize(source, error)
       @source = source
       @error = error
     end
 
-    attr_reader :source, :error
+    ##
+    # The source that had the fetch problem.
+
+    attr_reader :source
+
+    ##
+    # The fetch error which is an Exception subclass.
+
+    attr_reader :error
+
+    ##
+    # An English description of the error.
 
     def wordy
       "Unable to download data from #{@source.uri} - #{@error.message}"
     end
+
+    ##
+    # The "exception" alias allows you to call raise on a SourceFetchProblem.
+
+    alias exception error
   end
 end
diff --git a/jruby/lib/ruby/shared/rubygems/exceptions.rb b/jruby/lib/ruby/shared/rubygems/exceptions.rb
index 4a988f9..2a9875c 100644
--- a/jruby/lib/ruby/shared/rubygems/exceptions.rb
+++ b/jruby/lib/ruby/shared/rubygems/exceptions.rb
@@ -23,11 +23,11 @@ class Gem::DependencyError < Gem::Exception; end
 class Gem::DependencyRemovalException < Gem::Exception; end
 
 ##
-# Raised by Gem::DependencyResolver when a Gem::DependencyConflict reaches the
+# Raised by Gem::Resolver when a Gem::Dependency::Conflict reaches the
 # toplevel.  Indicates which dependencies were incompatible through #conflict
 # and #conflicting_dependencies
 
-class Gem::DependencyResolutionError < Gem::Exception
+class Gem::DependencyResolutionError < Gem::DependencyError
 
   attr_reader :conflict
 
@@ -35,7 +35,7 @@ class Gem::DependencyResolutionError < Gem::Exception
     @conflict = conflict
     a, b = conflicting_dependencies
 
-    super "unable to resolve conflicting dependencies '#{a}' and '#{b}'"
+    super "conflicting dependencies #{a} and #{b}\n#{@conflict.explanation}"
   end
 
   def conflicting_dependencies
@@ -81,7 +81,16 @@ end
 
 class Gem::GemNotFoundException < Gem::Exception; end
 
+##
+# Raised by the DependencyInstaller when a specific gem cannot be found
+
 class Gem::SpecificGemNotFoundException < Gem::GemNotFoundException
+
+  ##
+  # Creates a new SpecificGemNotFoundException for a gem with the given +name+
+  # and +version+.  Any +errors+ encountered when attempting to find the gem
+  # are also stored.
+
   def initialize(name, version, errors=nil)
     super "Could not find a valid gem '#{name}' (#{version}) locally or in a repository"
 
@@ -90,11 +99,25 @@ class Gem::SpecificGemNotFoundException < Gem::GemNotFoundException
     @errors = errors
   end
 
-  attr_reader :name, :version, :errors
+  ##
+  # The name of the gem that could not be found.
+
+  attr_reader :name
+
+  ##
+  # The version of the gem that could not be found.
+
+  attr_reader :version
+
+  ##
+  # Errors encountered attempting to find the gem.
+
+  attr_reader :errors
+
 end
 
 ##
-# Raised by Gem::DependencyResolver when dependencies conflict and create the
+# Raised by Gem::Resolver when dependencies conflict and create the
 # inability to find a valid possible spec for a request.
 
 class Gem::ImpossibleDependenciesError < Gem::Exception
@@ -154,6 +177,15 @@ class Gem::RemoteInstallationSkipped < Gem::Exception; end
 # Represents an error communicating via HTTP.
 class Gem::RemoteSourceException < Gem::Exception; end
 
+##
+# Raised when a gem dependencies file specifies a ruby version that does not
+# match the current version.
+
+class Gem::RubyVersionMismatch < Gem::Exception; end
+
+##
+# Raised by Gem::Validator when something is not right in a gem.
+
 class Gem::VerificationError < Gem::Exception; end
 
 ##
@@ -161,8 +193,15 @@ class Gem::VerificationError < Gem::Exception; end
 # exit_code
 
 class Gem::SystemExitException < SystemExit
+
+  ##
+  # The exit code for the process
+
   attr_accessor :exit_code
 
+  ##
+  # Creates a new SystemExitException with the given +exit_code+
+
   def initialize(exit_code)
     @exit_code = exit_code
 
@@ -172,19 +211,54 @@ class Gem::SystemExitException < SystemExit
 end
 
 ##
-# Raised by DependencyResolver when a dependency requests a gem for which
+# Raised by Resolver when a dependency requests a gem for which
 # there is no spec.
 
-class Gem::UnsatisfiableDependencyError < Gem::Exception
+class Gem::UnsatisfiableDependencyError < Gem::DependencyError
+
+  ##
+  # The unsatisfiable dependency.  This is a
+  # Gem::Resolver::DependencyRequest, not a Gem::Dependency
 
   attr_reader :dependency
 
-  def initialize dep
-    requester = dep.requester ? dep.requester.request : '(unknown)'
+  ##
+  # Errors encountered which may have contributed to this exception
 
-    super "Unable to resolve dependency: #{requester} requires #{dep}"
+  attr_accessor :errors
+
+  ##
+  # Creates a new UnsatisfiableDependencyError for the unsatisfiable
+  # Gem::Resolver::DependencyRequest +dep+
+
+  def initialize dep, platform_mismatch=nil
+    if platform_mismatch and !platform_mismatch.empty?
+      plats = platform_mismatch.map { |x| x.platform.to_s }.sort.uniq
+      super "Unable to resolve dependency: No match for '#{dep}' on this platform. Found: #{plats.join(', ')}"
+    else
+      if dep.explicit?
+        super "Unable to resolve dependency: user requested '#{dep}'"
+      else
+        super "Unable to resolve dependency: '#{dep.request_context}' requires '#{dep}'"
+      end
+    end
 
     @dependency = dep
+    @errors     = []
+  end
+
+  ##
+  # The name of the unresolved dependency
+
+  def name
+    @dependency.name
+  end
+
+  ##
+  # The Requirement of the unresolved dependency (not Version).
+
+  def version
+    @dependency.requirement
   end
 
 end
diff --git a/jruby/lib/ruby/shared/rubygems/ext.rb b/jruby/lib/ruby/shared/rubygems/ext.rb
index b2bb09a..5af6bbf 100644
--- a/jruby/lib/ruby/shared/rubygems/ext.rb
+++ b/jruby/lib/ruby/shared/rubygems/ext.rb
@@ -4,13 +4,12 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems'
-
 ##
 # Classes for building C extensions live here.
 
 module Gem::Ext; end
 
+require 'rubygems/ext/build_error'
 require 'rubygems/ext/builder'
 require 'rubygems/ext/configure_builder'
 require 'rubygems/ext/ext_conf_builder'
diff --git a/jruby/lib/ruby/shared/rubygems/ext/build_error.rb b/jruby/lib/ruby/shared/rubygems/ext/build_error.rb
new file mode 100644
index 0000000..bfe85ff
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/ext/build_error.rb
@@ -0,0 +1,6 @@
+##
+# Raised when there is an error while building extensions.
+
+class Gem::Ext::BuildError < Gem::InstallError
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/ext/builder.rb b/jruby/lib/ruby/shared/rubygems/ext/builder.rb
index 8c05723..548f126 100644
--- a/jruby/lib/ruby/shared/rubygems/ext/builder.rb
+++ b/jruby/lib/ruby/shared/rubygems/ext/builder.rb
@@ -28,7 +28,7 @@ class Gem::Ext::Builder
 
   def self.make(dest_path, results)
     unless File.exist? 'Makefile' then
-      raise Gem::InstallError, "Makefile not found:\n\n#{results.join "\n"}"
+      raise Gem::InstallError, 'Makefile not found'
     end
 
     # try to find make program from Ruby configure arguments first
@@ -40,14 +40,18 @@ class Gem::Ext::Builder
 
     destdir = '"DESTDIR=%s"' % ENV['DESTDIR'] if RUBY_VERSION > '2.0'
 
-    ['', 'install'].each do |target|
+    ['clean', '', 'install'].each do |target|
       # Pass DESTDIR via command line to override what's in MAKEFLAGS
       cmd = [
         make_program,
         destdir,
         target
       ].join(' ').rstrip
-      run(cmd, results, "make #{target}".rstrip)
+      begin
+        run(cmd, results, "make #{target}".rstrip)
+      rescue Gem::InstallError
+        raise unless target == 'clean' # ignore clean failure
+      end
     end
   end
 
@@ -74,18 +78,27 @@ class Gem::Ext::Builder
 
     unless $?.success? then
       results << "Building has failed. See above output for more information on the failure." if verbose
-      raise Gem::InstallError, "#{command_name || class_name} failed:\n\n#{results.join "\n"}"
+
+      exit_reason =
+        if $?.exited? then
+          ", exit code #{$?.exitstatus}"
+        elsif $?.signaled? then
+          ", uncaught signal #{$?.termsig}"
+        end
+
+      raise Gem::InstallError, "#{command_name || class_name} failed#{exit_reason}"
     end
   end
 
   ##
-  # Creates a new extension builder for +spec+ using the given +build_args+.
-  # The gem for +spec+ is unpacked in +gem_dir+.
+  # Creates a new extension builder for +spec+.  If the +spec+ does not yet
+  # have build arguments, saved, set +build_args+ which is an ARGV-style
+  # array.
 
-  def initialize spec, build_args
+  def initialize spec, build_args = spec.build_args
     @spec       = spec
     @build_args = build_args
-    @gem_dir    = spec.gem_dir
+    @gem_dir    = spec.full_gem_path
 
     @ran_rake   = nil
   end
@@ -113,12 +126,10 @@ class Gem::Ext::Builder
   end
 
   ##
-  # Logs the build +output+ in +build_dir+, then raises ExtensionBuildError.
+  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.
 
   def build_error build_dir, output, backtrace = nil # :nodoc:
-    gem_make_out = File.join build_dir, 'gem_make.out'
-
-    open gem_make_out, 'wb' do |io| io.puts output end
+    gem_make_out = write_gem_make_out output
 
     message = <<-EOF
 ERROR: Failed to build gem native extension.
@@ -129,14 +140,16 @@ Gem files will remain installed in #{@gem_dir} for inspection.
 Results logged to #{gem_make_out}
 EOF
 
-    raise Gem::Installer::ExtensionBuildError, message, backtrace
+    raise Gem::Ext::BuildError, message, backtrace
   end
 
   def build_extension extension, dest_path # :nodoc:
     results = []
 
     extension ||= '' # I wish I knew why this line existed
-    extension_dir = File.join @gem_dir, File.dirname(extension)
+    extension_dir =
+      File.expand_path File.join @gem_dir, File.dirname(extension)
+    lib_dir = File.join @spec.full_gem_path, @spec.raw_require_paths.first
 
     builder = builder_for extension
 
@@ -146,12 +159,15 @@ EOF
       CHDIR_MUTEX.synchronize do
         Dir.chdir extension_dir do
           results = builder.build(extension, @gem_dir, dest_path,
-                                  results, @build_args)
+                                  results, @build_args, lib_dir)
 
-          say results.join("\n") if Gem.configuration.really_verbose
+          verbose { results.join("\n") }
         end
       end
-    rescue
+
+      write_gem_make_out results.join "\n"
+    rescue => e
+      results << e.message
       build_error extension_dir, results.join("\n"), $@
     end
   end
@@ -170,7 +186,9 @@ EOF
       say "This could take a while..."
     end
 
-    dest_path = File.join @gem_dir, @spec.require_paths.first
+    dest_path = @spec.extension_dir
+
+    FileUtils.rm_f @spec.gem_build_complete_path
 
     @ran_rake = false # only run rake once
 
@@ -179,6 +197,21 @@ EOF
 
       build_extension extension, dest_path
     end
+
+    FileUtils.touch @spec.gem_build_complete_path
+  end
+
+  ##
+  # Writes +output+ to gem_make.out in the extension install directory.
+
+  def write_gem_make_out output # :nodoc:
+    destination = File.join @spec.extension_dir, 'gem_make.out'
+
+    FileUtils.mkdir_p @spec.extension_dir
+
+    open destination, 'wb' do |io| io.puts output end
+
+    destination
   end
 
 end
diff --git a/jruby/lib/ruby/shared/rubygems/ext/cmake_builder.rb b/jruby/lib/ruby/shared/rubygems/ext/cmake_builder.rb
index d6d106f..24531bc 100644
--- a/jruby/lib/ruby/shared/rubygems/ext/cmake_builder.rb
+++ b/jruby/lib/ruby/shared/rubygems/ext/cmake_builder.rb
@@ -1,5 +1,7 @@
+require 'rubygems/command'
+
 class Gem::Ext::CmakeBuilder < Gem::Ext::Builder
-  def self.build(extension, directory, dest_path, results)
+  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
     unless File.exist?('Makefile') then
       cmd = "cmake . -DCMAKE_INSTALL_PREFIX=#{dest_path}"
       cmd << " #{Gem::Command.build_args.join ' '}" unless Gem::Command.build_args.empty?
diff --git a/jruby/lib/ruby/shared/rubygems/ext/configure_builder.rb b/jruby/lib/ruby/shared/rubygems/ext/configure_builder.rb
index ef8b29e..f66e393 100644
--- a/jruby/lib/ruby/shared/rubygems/ext/configure_builder.rb
+++ b/jruby/lib/ruby/shared/rubygems/ext/configure_builder.rb
@@ -4,11 +4,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/ext/builder'
-
 class Gem::Ext::ConfigureBuilder < Gem::Ext::Builder
 
-  def self.build(extension, directory, dest_path, results, args=[])
+  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
     unless File.exist?('Makefile') then
       cmd = "sh ./configure --prefix=#{dest_path}"
       cmd << " #{args.join ' '}" unless args.empty?
diff --git a/jruby/lib/ruby/shared/rubygems/ext/ext_conf_builder.rb b/jruby/lib/ruby/shared/rubygems/ext/ext_conf_builder.rb
index 5112eb8..d11d1ac 100644
--- a/jruby/lib/ruby/shared/rubygems/ext/ext_conf_builder.rb
+++ b/jruby/lib/ruby/shared/rubygems/ext/ext_conf_builder.rb
@@ -4,22 +4,22 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/ext/builder'
-require 'rubygems/command'
 require 'fileutils'
 require 'tempfile'
 
 class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
   FileEntry = FileUtils::Entry_ # :nodoc:
 
-  def self.build(extension, directory, dest_path, results, args=[])
-    tmp_dest = Dir.mktmpdir(".gem.", ".")
+  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
+    # relative path required as some versions of mktmpdir return an absolute
+    # path which breaks make if it includes a space in the name
+    tmp_dest = get_relative_path(Dir.mktmpdir(".gem.", "."))
 
     t = nil
     Tempfile.open %w"siteconf .rb", "." do |siteconf|
       t = siteconf
       siteconf.puts "require 'rbconfig'"
-      siteconf.puts "dest_path = #{(tmp_dest || dest_path).dump}"
+      siteconf.puts "dest_path = #{tmp_dest.dump}"
       %w[sitearchdir sitelibdir].each do |dir|
         siteconf.puts "RbConfig::MAKEFILE_CONFIG['#{dir}'] = dest_path"
         siteconf.puts "RbConfig::CONFIG['#{dir}'] = dest_path"
@@ -27,31 +27,37 @@ class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
 
       siteconf.flush
 
-      siteconf_path = File.expand_path siteconf.path
-
-      rubyopt = ENV["RUBYOPT"]
       destdir = ENV["DESTDIR"]
 
       begin
-        ENV["RUBYOPT"] = ["-r#{siteconf_path}", rubyopt].compact.join(' ')
-        cmd = [Gem.ruby, File.basename(extension), *args].join ' '
+        cmd = [Gem.ruby, "-r", get_relative_path(siteconf.path), File.basename(extension), *args].join ' '
 
-        run cmd, results
+        begin
+          run cmd, results
+        ensure
+          FileUtils.mv 'mkmf.log', dest_path if File.exist? 'mkmf.log'
+          siteconf.unlink
+        end
 
         ENV["DESTDIR"] = nil
-        ENV["RUBYOPT"] = rubyopt
-        siteconf.unlink
 
         make dest_path, results
 
         if tmp_dest
+          # TODO remove in RubyGems 3
+          if Gem.install_extension_in_lib and lib_dir then
+            FileUtils.mkdir_p lib_dir
+            entries = Dir.entries(tmp_dest) - %w[. ..]
+            entries = entries.map { |entry| File.join tmp_dest, entry }
+            FileUtils.cp_r entries, lib_dir, :remove_destination => true
+          end
+
           FileEntry.new(tmp_dest).traverse do |ent|
             destent = ent.class.new(dest_path, ent.rel)
-            destent.exist? or File.rename(ent.path, destent.path)
+            destent.exist? or FileUtils.mv(ent.path, destent.path)
           end
         end
       ensure
-        ENV["RUBYOPT"] = rubyopt
         ENV["DESTDIR"] = destdir
       end
     end
@@ -62,5 +68,11 @@ class Gem::Ext::ExtConfBuilder < Gem::Ext::Builder
     FileUtils.rm_rf tmp_dest if tmp_dest
   end
 
+  private
+  def self.get_relative_path(path)
+    path[0..Dir.pwd.length-1] = '.' if path.start_with?(Dir.pwd)
+    path
+  end
+
 end
 
diff --git a/jruby/lib/ruby/shared/rubygems/ext/rake_builder.rb b/jruby/lib/ruby/shared/rubygems/ext/rake_builder.rb
index 2ac6edd..d5ebf59 100644
--- a/jruby/lib/ruby/shared/rubygems/ext/rake_builder.rb
+++ b/jruby/lib/ruby/shared/rubygems/ext/rake_builder.rb
@@ -4,12 +4,9 @@
 # See LICENSE.txt for permissions.
 #++
 
-require 'rubygems/ext/builder'
-require 'rubygems/command'
-
 class Gem::Ext::RakeBuilder < Gem::Ext::Builder
 
-  def self.build(extension, directory, dest_path, results, args=[])
+  def self.build(extension, directory, dest_path, results, args=[], lib_dir=nil)
     if File.basename(extension) =~ /mkrf_conf/i then
       cmd = "#{Gem.ruby} #{File.basename extension}"
       cmd << " #{args.join " "}" unless args.empty?
@@ -22,7 +19,7 @@ class Gem::Ext::RakeBuilder < Gem::Ext::Builder
     rake = ENV['rake']
 
     rake ||= begin
-               "\"#{Gem.ruby}\" -rubygems #{Gem.bin_path('rake', 'rake')}"
+               "#{Gem.ruby} -rubygems #{Gem.bin_path('rake', 'rake')}"
              rescue Gem::Exception
              end
 
diff --git a/jruby/lib/ruby/shared/rubygems/gemcutter_utilities.rb b/jruby/lib/ruby/shared/rubygems/gemcutter_utilities.rb
index 9dbc18b..4ecf737 100644
--- a/jruby/lib/ruby/shared/rubygems/gemcutter_utilities.rb
+++ b/jruby/lib/ruby/shared/rubygems/gemcutter_utilities.rb
@@ -56,8 +56,10 @@ module Gem::GemcutterUtilities
 
   ##
   # Creates an RubyGems API to +host+ and +path+ with the given HTTP +method+.
+  #
+  # If +allowed_push_host+ metadata is present, then it will only allow that host.
 
-  def rubygems_api_request(method, path, host = nil, &block)
+  def rubygems_api_request(method, path, host = nil, allowed_push_host = nil, &block)
     require 'net/http'
 
     self.host = host if host
@@ -66,6 +68,11 @@ module Gem::GemcutterUtilities
       terminate_interaction 1 # TODO: question this
     end
 
+    if allowed_push_host and self.host != allowed_push_host
+      alert_error "#{self.host.inspect} is not allowed by the gemspec, which only allows #{allowed_push_host.inspect}"
+      terminate_interaction 1
+    end
+
     uri = URI.parse "#{self.host}/#{path}"
 
     request_method = Net::HTTP.const_get method.to_s.capitalize
@@ -79,7 +86,7 @@ module Gem::GemcutterUtilities
 
   def sign_in sign_in_host = nil
     sign_in_host ||= self.host
-    return if Gem.configuration.rubygems_api_key
+    return if api_key
 
     pretty_host = if Gem::DEFAULT_HOST == sign_in_host then
                     'RubyGems.org'
diff --git a/jruby/lib/ruby/shared/rubygems/indexer.rb b/jruby/lib/ruby/shared/rubygems/indexer.rb
index 1c7f8e7..f94fb1b 100644
--- a/jruby/lib/ruby/shared/rubygems/indexer.rb
+++ b/jruby/lib/ruby/shared/rubygems/indexer.rb
@@ -235,7 +235,7 @@ class Gem::Indexer
         sanitize spec
 
         spec
-      rescue SignalException => e
+      rescue SignalException
         alert_error "Received signal, exiting"
         raise
       rescue Exception => e
diff --git a/jruby/lib/ruby/shared/rubygems/install_update_options.rb b/jruby/lib/ruby/shared/rubygems/install_update_options.rb
index d3f55cd..a503b7f 100644
--- a/jruby/lib/ruby/shared/rubygems/install_update_options.rb
+++ b/jruby/lib/ruby/shared/rubygems/install_update_options.rb
@@ -59,6 +59,23 @@ module Gem::InstallUpdateOptions
                            end
     end
 
+    add_option(:"Install/Update", '--build-root DIR',
+               'Temporary installation root. Useful for building',
+               'packages. Do not use this when installing remote gems.') do |value, options|
+      options[:build_root] = File.expand_path(value)
+    end
+
+    add_option(:"Install/Update", '--vendor',
+               'Install gem into the vendor directory.',
+               'Only for use by gem repackagers.') do |value, options|
+      unless Gem.vendor_dir then
+        raise OptionParser::InvalidOption.new 'your platform is not supported'
+      end
+
+      options[:vendor] = true
+      options[:install_dir] = Gem.vendor_dir
+    end
+
     add_option(:"Install/Update", '-N', '--no-document',
                'Disable documentation generation') do |value, options|
       options[:document] = []
diff --git a/jruby/lib/ruby/shared/rubygems/installer.rb b/jruby/lib/ruby/shared/rubygems/installer.rb
index 261af89..10fc1a3 100644
--- a/jruby/lib/ruby/shared/rubygems/installer.rb
+++ b/jruby/lib/ruby/shared/rubygems/installer.rb
@@ -4,6 +4,7 @@
 # See LICENSE.txt for permissions.
 #++
 
+require 'rubygems/command'
 require 'rubygems/exceptions'
 require 'rubygems/package'
 require 'rubygems/ext'
@@ -32,13 +33,15 @@ class Gem::Installer
   ENV_PATHS = %w[/usr/bin/env /bin/env]
 
   ##
-  # Raised when there is an error while building extensions.
-  #
-  class ExtensionBuildError < Gem::InstallError; end
+  # Deprecated in favor of Gem::Ext::BuildError
+
+  ExtensionBuildError = Gem::Ext::BuildError # :nodoc:
 
   include Gem::UserInteraction
 
-  # DOC: Missing docs or :nodoc:.
+  ##
+  # Filename of the gem being installed.
+
   attr_reader :gem
 
   ##
@@ -46,6 +49,8 @@ class Gem::Installer
 
   attr_reader :bin_dir
 
+  attr_reader :build_root # :nodoc:
+
   ##
   # The gem repository the gem will be installed into
 
@@ -56,8 +61,15 @@ class Gem::Installer
 
   attr_reader :options
 
+  ##
+  # Sets the specification for .gem-less installs.
+
+  attr_writer :spec
+
   @path_warning = false
 
+  @install_lock = Mutex.new
+
   class << self
 
     ##
@@ -65,7 +77,19 @@ class Gem::Installer
 
     attr_accessor :path_warning
 
-    # DOC: Missing docs or :nodoc:.
+    ##
+    # Certain aspects of the install process are not thread-safe. This lock is
+    # used to allow multiple threads to install Gems at the same time.
+
+    attr_reader :install_lock
+
+    ##
+    # Overrides the executable format.
+    #
+    # This is a sprintf format with a "%s" which will be replaced with the
+    # executable name.  It is based off the ruby executable name's difference
+    # from "ruby".
+
     attr_writer :exec_format
 
     # Defaults to use Ruby's program prefix and suffix.
@@ -206,6 +230,8 @@ class Gem::Installer
   def install
     pre_install_checks
 
+    FileUtils.rm_f File.join gem_home, 'specifications', @spec.spec_name
+
     run_pre_install_hooks
 
     # Completely remove any previous gem files
@@ -232,7 +258,7 @@ class Gem::Installer
 
     say spec.post_install_message unless spec.post_install_message.nil?
 
-    Gem::Specification.add_spec spec unless Gem::Specification.include? spec
+    Gem::Installer.install_lock.synchronize { Gem::Specification.add_spec spec }
 
     run_post_install_hooks
 
@@ -310,6 +336,7 @@ class Gem::Installer
   # True if the gems in the system satisfy +dependency+.
 
   def installation_satisfies_dependency?(dependency)
+    return true if @options[:development] and dependency.type == :development
     return true if installed_specs.detect { |s| dependency.matches_spec? s }
     return false if @only_install_dir
     not dependency.matching_specs.empty?
@@ -345,7 +372,10 @@ class Gem::Installer
 
   def write_spec
     open spec_file, 'w' do |file|
+      spec.installed_by_version = Gem.rubygems_version
+
       file.puts spec.to_ruby_for_cache
+
       file.fsync rescue nil # for filesystems without fsync(2)
     end
   end
@@ -371,12 +401,11 @@ class Gem::Installer
         file.puts windows_stub_script(bindir, filename)
       end
 
-      say script_path if Gem.configuration.really_verbose
+      verbose script_path
     end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def generate_bin
+  def generate_bin # :nodoc:
     return if spec.executables.nil? or spec.executables.empty?
 
     Dir.mkdir @bin_dir unless File.exist? @bin_dir
@@ -392,8 +421,8 @@ class Gem::Installer
         next
       end
 
-      mode = File.stat(bin_path).mode | 0111
-      FileUtils.chmod mode, bin_path
+      mode = File.stat(bin_path).mode
+      FileUtils.chmod mode | 0111, bin_path unless (mode | 0111) == mode
 
       check_executable_overwrite filename
 
@@ -422,7 +451,7 @@ class Gem::Installer
       file.print app_script_text(filename)
     end
 
-    say bin_script_path if Gem.configuration.really_verbose
+    verbose bin_script_path
 
     generate_windows_script filename, bindir
   end
@@ -469,7 +498,7 @@ class Gem::Installer
   #
 
   def shebang(bin_file_name)
-    ruby_name = Gem::ConfigMap[:ruby_install_name] if @env_shebang
+    ruby_name = RbConfig::CONFIG['ruby_install_name'] if @env_shebang
     path = File.join gem_dir, spec.bindir, bin_file_name
     first_line = File.open(path, "rb") {|file| file.gets}
 
@@ -482,7 +511,7 @@ class Gem::Installer
 
     if which = Gem.configuration[:custom_shebang]
       # replace bin_file_name with "ruby" to avoid endless loops
-      which = which.gsub(/ #{bin_file_name}$/," #{Gem::ConfigMap[:ruby_install_name]}")
+      which = which.gsub(/ #{bin_file_name}$/," #{RbConfig::CONFIG['ruby_install_name']}")
 
       which = which.gsub(/\$(\w+)/) do
         case $1
@@ -525,8 +554,7 @@ class Gem::Installer
     end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def ensure_required_ruby_version_met
+  def ensure_required_ruby_version_met # :nodoc:
     if rrv = spec.required_ruby_version then
       unless rrv.satisfied_by? Gem.ruby_version then
         raise Gem::InstallError, "#{spec.name} requires Ruby version #{rrv}."
@@ -534,8 +562,7 @@ class Gem::Installer
     end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def ensure_required_rubygems_version_met
+  def ensure_required_rubygems_version_met # :nodoc:
     if rrgv = spec.required_rubygems_version then
       unless rrgv.satisfied_by? Gem.rubygems_version then
         raise Gem::InstallError,
@@ -545,8 +572,7 @@ class Gem::Installer
     end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def ensure_dependencies_met
+  def ensure_dependencies_met # :nodoc:
     deps = spec.runtime_dependencies
     deps |= spec.development_dependencies if @development
 
@@ -555,8 +581,7 @@ class Gem::Installer
     end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def process_options
+  def process_options # :nodoc:
     @options = {
       :bin_dir      => nil,
       :env_shebang  => false,
@@ -579,12 +604,20 @@ class Gem::Installer
     # (or use) a new bin dir under the gem_home.
     @bin_dir             = options[:bin_dir] || Gem.bindir(gem_home)
     @development         = options[:development]
+    @build_root          = options[:build_root]
 
     @build_args          = options[:build_args] || Gem::Command.build_args
+
+    unless @build_root.nil?
+      require 'pathname'
+      @build_root = Pathname.new(@build_root).expand_path
+      @bin_dir = File.join(@build_root, options[:bin_dir] || Gem.bindir(@gem_home))
+      @gem_home = File.join(@build_root, @gem_home)
+      alert_warning "You build with buildroot.\n  Build root: #{@build_root}\n  Bin dir: #{@bin_dir}\n  Gem home: #{@gem_home}"
+    end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def check_that_user_bin_dir_is_in_path
+  def check_that_user_bin_dir_is_in_path # :nodoc:
     user_bin_dir = @bin_dir || Gem.bindir(gem_home)
     user_bin_dir = user_bin_dir.gsub(File::SEPARATOR, File::ALT_SEPARATOR) if
       File::ALT_SEPARATOR
@@ -595,16 +628,19 @@ class Gem::Installer
       user_bin_dir = user_bin_dir.downcase
     end
 
-    unless path.split(File::PATH_SEPARATOR).include? user_bin_dir then
-      unless self.class.path_warning then
-        alert_warning "You don't have #{user_bin_dir} in your PATH,\n\t  gem executables will not run."
-        self.class.path_warning = true
+    path = path.split(File::PATH_SEPARATOR)
+
+    unless path.include? user_bin_dir then
+      unless !Gem.win_platform? && (path.include? user_bin_dir.sub(ENV['HOME'], '~'))
+        unless self.class.path_warning then
+          alert_warning "You don't have #{user_bin_dir} in your PATH,\n\t  gem executables will not run."
+          self.class.path_warning = true
+        end
       end
     end
   end
 
-  # DOC: Missing docs or :nodoc:.
-  def verify_gem_home(unpack = false)
+  def verify_gem_home(unpack = false) # :nodoc:
     FileUtils.mkdir_p gem_home
     raise Gem::FilePermissionError, gem_home unless
       unpack or File.writable?(gem_home)
@@ -630,7 +666,7 @@ version = "#{Gem::Requirement.default}"
 if ARGV.first
   str = ARGV.first
   str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
-  if str =~ /\\A_(.*)_\\z/
+  if str =~ /\\A_(.*)_\\z/ and Gem::Version.correct?($1) then
     version = $1
     ARGV.shift
   end
@@ -645,7 +681,7 @@ TEXT
   # return the stub script text used to launch the true Ruby script
 
   def windows_stub_script(bindir, bin_file_name)
-    ruby = File.basename(Gem.ruby).chomp('"')
+    ruby = Gem.ruby.gsub(/^\"|\"$/, "").tr(File::SEPARATOR, "\\")
     return <<-TEXT
 @ECHO OFF
 IF NOT "%~f0" == "~f0" GOTO :WinNT
@@ -667,7 +703,7 @@ TEXT
   end
 
   ##
-  # Logs the build +output+ in +build_dir+, then raises ExtensionBuildError.
+  # Logs the build +output+ in +build_dir+, then raises Gem::Ext::BuildError.
   #
   # TODO:  Delete this for RubyGems 3.  It remains for API compatibility
 
diff --git a/jruby/lib/ruby/shared/rubygems/installer_test_case.rb b/jruby/lib/ruby/shared/rubygems/installer_test_case.rb
index 62a468a..549de01 100644
--- a/jruby/lib/ruby/shared/rubygems/installer_test_case.rb
+++ b/jruby/lib/ruby/shared/rubygems/installer_test_case.rb
@@ -56,11 +56,6 @@ class Gem::Installer
   ##
   # Available through requiring rubygems/installer_test_case
 
-  attr_writer :spec
-
-  ##
-  # Available through requiring rubygems/installer_test_case
-
   attr_writer :wrappers
 end
 
@@ -106,6 +101,8 @@ class Gem::InstallerTestCase < Gem::TestCase
 
     @installer      = util_installer @spec, @gemhome
     @user_installer = util_installer @user_spec, Gem.user_dir, :user
+
+    Gem::Installer.path_warning = false
   end
 
   def util_gem_bindir spec = @spec # :nodoc:
diff --git a/jruby/lib/ruby/shared/rubygems/local_remote_options.rb b/jruby/lib/ruby/shared/rubygems/local_remote_options.rb
index a1e106d..db23d9f 100644
--- a/jruby/lib/ruby/shared/rubygems/local_remote_options.rb
+++ b/jruby/lib/ruby/shared/rubygems/local_remote_options.rb
@@ -100,8 +100,8 @@ module Gem::LocalRemoteOptions
   def add_source_option
     accept_uri_http
 
-    add_option(:"Local/Remote", '--source URL', URI::HTTP,
-               'Add URL as a remote source for gems') do |source, options|
+    add_option(:"Local/Remote", '-s', '--source URL', URI::HTTP,
+               'Append URL to list of remote gem sources') do |source, options|
 
       source << '/' if source !~ /\/\z/
 
diff --git a/jruby/lib/ruby/shared/rubygems/name_tuple.rb b/jruby/lib/ruby/shared/rubygems/name_tuple.rb
index f16ab36..60323db 100644
--- a/jruby/lib/ruby/shared/rubygems/name_tuple.rb
+++ b/jruby/lib/ruby/shared/rubygems/name_tuple.rb
@@ -53,7 +53,7 @@ class Gem::NameTuple
       "#{@name}-#{@version}"
     else
       "#{@name}-#{@version}-#{@platform}"
-    end
+    end.untaint
   end
 
   ##
@@ -90,7 +90,9 @@ class Gem::NameTuple
   alias to_s inspect # :nodoc:
 
   def <=> other
-    to_a <=> other.to_a
+    [@name, @version, @platform == Gem::Platform::RUBY ? -1 : 1] <=>
+      [other.name, other.version,
+       other.platform == Gem::Platform::RUBY ? -1 : 1]
   end
 
   include Comparable
diff --git a/jruby/lib/ruby/shared/rubygems/package.rb b/jruby/lib/ruby/shared/rubygems/package.rb
index c4a77cb..e8b8b38 100644
--- a/jruby/lib/ruby/shared/rubygems/package.rb
+++ b/jruby/lib/ruby/shared/rubygems/package.rb
@@ -54,10 +54,12 @@ class Gem::Package
   class FormatError < Error
     attr_reader :path
 
-    def initialize message, path = nil
-      @path = path
+    def initialize message, source = nil
+      if source
+        @path = source.path
 
-      message << " in #{path}" if path
+        message << " in #{path}" if path
+      end
 
       super message
     end
@@ -80,6 +82,7 @@ class Gem::Package
 
   class TarInvalidError < Error; end
 
+
   attr_accessor :build_time # :nodoc:
 
   ##
@@ -114,19 +117,26 @@ class Gem::Package
   end
 
   ##
-  # Creates a new Gem::Package for the file at +gem+.
+  # Creates a new Gem::Package for the file at +gem+. +gem+ can also be
+  # provided as an IO object.
   #
   # If +gem+ is an existing file in the old format a Gem::Package::Old will be
   # returned.
 
   def self.new gem
-    return super unless Gem::Package == self
-    return super unless File.exist? gem
+    gem = if gem.is_a?(Gem::Package::Source)
+            gem
+          elsif gem.respond_to? :read
+            Gem::Package::IOSource.new gem
+          else
+            Gem::Package::FileSource.new gem
+          end
 
-    start = File.read gem, 20
+    return super(gem) unless Gem::Package == self
+    return super unless gem.present?
 
-    return super unless start
-    return super unless start.include? 'MD5SUM ='
+    return super unless gem.start
+    return super unless gem.start.include? 'MD5SUM ='
 
     Gem::Package::Old.new gem
   end
@@ -227,7 +237,7 @@ class Gem::Package
 
     setup_signer
 
-    open @gem, 'wb' do |gem_io|
+    @gem.with_write_io do |gem_io|
       Gem::Package::TarWriter.new gem_io do |gem|
         add_metadata gem
         add_contents gem
@@ -255,7 +265,7 @@ EOM
 
     @contents = []
 
-    open @gem, 'rb' do |io|
+    @gem.with_read_io do |io|
       gem_tar = Gem::Package::TarReader.new io
 
       gem_tar.each do |entry|
@@ -312,7 +322,7 @@ EOM
 
     FileUtils.mkdir_p destination_dir
 
-    open @gem, 'rb' do |io|
+    @gem.with_read_io do |io|
       reader = Gem::Package::TarReader.new io
 
       reader.each do |entry|
@@ -345,13 +355,23 @@ EOM
 
         FileUtils.rm_rf destination
 
-        FileUtils.mkdir_p File.dirname destination
+        mkdir_options = {}
+        mkdir_options[:mode] = entry.header.mode if entry.directory?
+        mkdir =
+          if entry.directory? then
+            destination
+          else
+            File.dirname destination
+          end
+
+        FileUtils.mkdir_p mkdir, mkdir_options
 
-        open destination, 'wb', entry.header.mode do |out|
+        open destination, 'wb' do |out|
           out.write entry.read
-        end
+          FileUtils.chmod entry.header.mode, destination
+        end if entry.file?
 
-        say destination if Gem.configuration.really_verbose
+        verbose destination
       end
     end
   end
@@ -481,7 +501,7 @@ EOM
     @files     = []
     @spec      = nil
 
-    open @gem, 'rb' do |io|
+    @gem.with_read_io do |io|
       Gem::Package::TarReader.new io do |reader|
         read_checksums reader
 
@@ -583,6 +603,9 @@ EOM
 end
 
 require 'rubygems/package/digest_io'
+require 'rubygems/package/source'
+require 'rubygems/package/file_source'
+require 'rubygems/package/io_source'
 require 'rubygems/package/old'
 require 'rubygems/package/tar_header'
 require 'rubygems/package/tar_reader'
diff --git a/jruby/lib/ruby/shared/rubygems/package/file_source.rb b/jruby/lib/ruby/shared/rubygems/package/file_source.rb
new file mode 100644
index 0000000..85316f6
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/package/file_source.rb
@@ -0,0 +1,33 @@
+##
+# The primary source of gems is a file on disk, including all usages
+# internal to rubygems.
+#
+# This is a private class, do not depend on it directly. Instead, pass a path
+# object to `Gem::Package.new`.
+
+class Gem::Package::FileSource < Gem::Package::Source # :nodoc: all
+
+  attr_reader :path
+
+  def initialize path
+    @path = path
+  end
+
+  def start
+    @start ||= File.read path, 20
+  end
+
+  def present?
+    File.exist? path
+  end
+
+  def with_write_io &block
+    open path, 'wb', &block
+  end
+
+  def with_read_io &block
+    open path, 'rb', &block
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/package/io_source.rb b/jruby/lib/ruby/shared/rubygems/package/io_source.rb
new file mode 100644
index 0000000..f89593d
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/package/io_source.rb
@@ -0,0 +1,45 @@
+##
+# Supports reading and writing gems from/to a generic IO object.  This is
+# useful for other applications built on top of rubygems, such as
+# rubygems.org.
+#
+# This is a private class, do not depend on it directly. Instead, pass an IO
+# object to `Gem::Package.new`.
+
+class Gem::Package::IOSource < Gem::Package::Source # :nodoc: all
+
+  attr_reader :io
+
+  def initialize io
+    @io = io
+  end
+
+  def start
+    @start ||= begin
+      if io.pos > 0
+        raise Gem::Package::Error, "Cannot read start unless IO is at start"
+      end
+
+      value = io.read 20
+      io.rewind
+      value
+    end
+  end
+
+  def present?
+    true
+  end
+
+  def with_read_io
+    yield io
+  end
+
+  def with_write_io
+    yield io
+  end
+
+  def path
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/package/old.rb b/jruby/lib/ruby/shared/rubygems/package/old.rb
index d74753f..d7b228d 100644
--- a/jruby/lib/ruby/shared/rubygems/package/old.rb
+++ b/jruby/lib/ruby/shared/rubygems/package/old.rb
@@ -37,7 +37,7 @@ class Gem::Package::Old < Gem::Package
 
     return @contents if @contents
 
-    open @gem, 'rb' do |io|
+    @gem.with_read_io do |io|
       read_until_dashes io # spec
       header = file_list io
 
@@ -53,7 +53,7 @@ class Gem::Package::Old < Gem::Package
 
     errstr = "Error reading files from gem"
 
-    open @gem, 'rb' do |io|
+    @gem.with_read_io do |io|
       read_until_dashes io # spec
       header = file_list io
       raise Gem::Exception, errstr unless header
@@ -83,7 +83,7 @@ class Gem::Package::Old < Gem::Package
           out.write file_data
         end
 
-        say destination if Gem.configuration.really_verbose
+        verbose destination
       end
     end
   rescue Zlib::DataError
@@ -136,7 +136,7 @@ class Gem::Package::Old < Gem::Package
 
     yaml = ''
 
-    open @gem, 'rb' do |io|
+    @gem.with_read_io do |io|
       skip_ruby io
       read_until_dashes io do |line|
         yaml << line
@@ -145,7 +145,7 @@ class Gem::Package::Old < Gem::Package
 
     yaml_error = if RUBY_VERSION < '1.9' then
                    YAML::ParseError
-                 elsif YAML::ENGINE.yamler == 'syck' then
+                 elsif YAML.const_defined?(:ENGINE) && YAML::ENGINE.yamler == 'syck' then
                    YAML::ParseError
                  else
                    YAML::SyntaxError
@@ -153,10 +153,10 @@ class Gem::Package::Old < Gem::Package
 
     begin
       @spec = Gem::Specification.from_yaml yaml
-    rescue yaml_error => e
+    rescue yaml_error
       raise Gem::Exception, "Failed to parse gem specification out of gem file"
     end
-  rescue ArgumentError => e
+  rescue ArgumentError
     raise Gem::Exception, "Failed to parse gem specification out of gem file"
   end
 
diff --git a/jruby/lib/ruby/shared/rubygems/package/source.rb b/jruby/lib/ruby/shared/rubygems/package/source.rb
new file mode 100644
index 0000000..1f18d47
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/package/source.rb
@@ -0,0 +1,3 @@
+class Gem::Package::Source # :nodoc:
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/package/tar_header.rb b/jruby/lib/ruby/shared/rubygems/package/tar_header.rb
index 28da1db..f9ab13a 100644
--- a/jruby/lib/ruby/shared/rubygems/package/tar_header.rb
+++ b/jruby/lib/ruby/shared/rubygems/package/tar_header.rb
@@ -134,7 +134,7 @@ class Gem::Package::TarHeader
     vals[:gid] ||= 0
     vals[:mtime] ||= 0
     vals[:checksum] ||= ""
-    vals[:typeflag] ||= "0"
+    vals[:typeflag] = "0" if vals[:typeflag].nil? || vals[:typeflag].empty?
     vals[:magic] ||= "ustar"
     vals[:version] ||= "00"
     vals[:uname] ||= "wheel"
diff --git a/jruby/lib/ruby/shared/rubygems/package/tar_reader/entry.rb b/jruby/lib/ruby/shared/rubygems/package/tar_reader/entry.rb
index 7034e59..737c763 100644
--- a/jruby/lib/ruby/shared/rubygems/package/tar_reader/entry.rb
+++ b/jruby/lib/ruby/shared/rubygems/package/tar_reader/entry.rb
@@ -129,6 +129,8 @@ class Gem::Package::TarReader::Entry
     ret
   end
 
+  alias readpartial read # :nodoc:
+
   ##
   # Rewinds to the beginning of the tar file entry
 
diff --git a/jruby/lib/ruby/shared/rubygems/package/tar_writer.rb b/jruby/lib/ruby/shared/rubygems/package/tar_writer.rb
index e1b38ad..dfd6357 100644
--- a/jruby/lib/ruby/shared/rubygems/package/tar_writer.rb
+++ b/jruby/lib/ruby/shared/rubygems/package/tar_writer.rb
@@ -290,7 +290,9 @@ class Gem::Package::TarWriter
   # Splits +name+ into a name and prefix that can fit in the TarHeader
 
   def split_name(name) # :nodoc:
-    raise Gem::Package::TooLongFileName if name.bytesize > 256
+    if name.bytesize > 256
+      raise Gem::Package::TooLongFileName.new("File \"#{name}\" has a too long path (should be 256 or less)")
+    end
 
     if name.bytesize <= 100 then
       prefix = ""
@@ -308,8 +310,12 @@ class Gem::Package::TarWriter
       prefix = (parts + [nxt]).join "/"
       name = newname
 
-      if name.bytesize > 100 or prefix.bytesize > 155 then
-        raise Gem::Package::TooLongFileName
+      if name.bytesize > 100
+        raise Gem::Package::TooLongFileName.new("File \"#{prefix}/#{name}\" has a too long name (should be 100 or less)")
+      end
+
+      if prefix.bytesize > 155 then
+        raise Gem::Package::TooLongFileName.new("File \"#{prefix}/#{name}\" has a too long base path (should be 155 or less)")
       end
     end
 
diff --git a/jruby/lib/ruby/shared/rubygems/path_support.rb b/jruby/lib/ruby/shared/rubygems/path_support.rb
index 2af303e..e68654c 100644
--- a/jruby/lib/ruby/shared/rubygems/path_support.rb
+++ b/jruby/lib/ruby/shared/rubygems/path_support.rb
@@ -43,13 +43,6 @@ class Gem::PathSupport
   private
 
   ##
-  # Set the Gem home directory (as reported by Gem.dir).
-
-  def home=(home)
-    @home = home.to_s
-  end
-
-  ##
   # Set the Gem search path (as reported by Gem.path).
 
   def path=(gpaths)
diff --git a/jruby/lib/ruby/shared/rubygems/platform.rb b/jruby/lib/ruby/shared/rubygems/platform.rb
index 247ee6e..fa56141 100644
--- a/jruby/lib/ruby/shared/rubygems/platform.rb
+++ b/jruby/lib/ruby/shared/rubygems/platform.rb
@@ -16,8 +16,8 @@ class Gem::Platform
   attr_accessor :version
 
   def self.local
-    arch = Gem::ConfigMap[:arch]
-    arch = "#{arch}_60" if arch =~ /mswin32$/
+    arch = RbConfig::CONFIG['arch']
+    arch = "#{arch}_60" if arch =~ /mswin(?:32|64)$/
     @local ||= new(arch)
   end
 
@@ -29,6 +29,14 @@ class Gem::Platform
     end
   end
 
+  def self.installable?(spec)
+    if spec.respond_to? :installable_platform?
+      spec.installable_platform?
+    else
+      match spec.platform
+    end
+  end
+
   def self.new(arch) # :nodoc:
     case arch
     when Gem::Platform::CURRENT then
@@ -165,6 +173,7 @@ class Gem::Platform
               when /^dalvik(\d+)?$/       then [nil,         'dalvik',  $1    ]
               when /dotnet(\-(\d+\.\d+))?/ then ['universal','dotnet',  $2    ]
               when /mswin32(\_(\d+))?/    then ['x86',       'mswin32', $2    ]
+              when /mswin64(\_(\d+))?/    then ['x64',       'mswin64', $2    ]
               when 'powerpc-darwin'       then ['powerpc',   'darwin',  nil   ]
               when /powerpc-darwin(\d)/   then ['powerpc',   'darwin',  $1    ]
               when /sparc-solaris2.8/     then ['sparc',     'solaris', '2.8' ]
diff --git a/jruby/lib/ruby/shared/rubygems/psych_additions.rb b/jruby/lib/ruby/shared/rubygems/psych_additions.rb
index dcc13fd..08fc04c 100644
--- a/jruby/lib/ruby/shared/rubygems/psych_additions.rb
+++ b/jruby/lib/ruby/shared/rubygems/psych_additions.rb
@@ -1,9 +1,9 @@
-# This exists just to satify bugs in marshal'd gemspecs that
+# This exists just to satisfy bugs in marshal'd gemspecs that
 # contain a reference to YAML::PrivateType. We prune these out
 # in Specification._load, but if we don't have the constant, Marshal
 # blows up.
 
 module Psych # :nodoc:
-  class PrivateType
+  class PrivateType # :nodoc:
   end
 end
diff --git a/jruby/lib/ruby/shared/rubygems/rdoc.rb b/jruby/lib/ruby/shared/rubygems/rdoc.rb
index f16c869..180b95f 100644
--- a/jruby/lib/ruby/shared/rubygems/rdoc.rb
+++ b/jruby/lib/ruby/shared/rubygems/rdoc.rb
@@ -8,7 +8,7 @@ rescue Gem::LoadError
   # swallow
 else
   # This will force any deps that 'rdoc' might have
-  # (such as json) that are ambigious to be activated, which
+  # (such as json) that are ambiguous to be activated, which
   # is important because we end up using Specification.reset
   # and we don't want the warning it pops out.
   Gem.finish_resolve
@@ -193,7 +193,7 @@ class Gem::RDoc # :nodoc: all
     ::RDoc::Parser::C.reset
 
     args = @spec.rdoc_options
-    args.concat @spec.require_paths
+    args.concat @spec.source_paths
     args.concat @spec.extra_rdoc_files
 
     case config_args = Gem.configuration[:rdoc]
@@ -263,7 +263,7 @@ class Gem::RDoc # :nodoc: all
       Gem::Requirement.new('>= 2.4.0') =~ self.class.rdoc_version
 
     r = new_rdoc
-    say "rdoc #{args.join ' '}" if Gem.configuration.really_verbose
+    verbose { "rdoc #{args.join ' '}" }
 
     Dir.chdir @spec.full_gem_path do
       begin
@@ -279,7 +279,6 @@ class Gem::RDoc # :nodoc: all
         ui.errs.puts "... RDOC args: #{args.join(' ')}"
         ui.backtrace ex
         ui.errs.puts "(continuing with the rest of the installation)"
-      ensure
       end
     end
   end
diff --git a/jruby/lib/ruby/shared/rubygems/remote_fetcher.rb b/jruby/lib/ruby/shared/rubygems/remote_fetcher.rb
index 6abd6bd..3f107a3 100644
--- a/jruby/lib/ruby/shared/rubygems/remote_fetcher.rb
+++ b/jruby/lib/ruby/shared/rubygems/remote_fetcher.rb
@@ -2,6 +2,7 @@ require 'rubygems'
 require 'rubygems/request'
 require 'rubygems/uri_formatter'
 require 'rubygems/user_interaction'
+require 'rubygems/request/connection_pools'
 require 'resolv'
 
 ##
@@ -73,12 +74,14 @@ class Gem::RemoteFetcher
     Socket.do_not_reverse_lookup = true
 
     @proxy = proxy
+    @pools = {}
+    @pool_lock = Mutex.new
+    @cert_files = Gem::Request.get_cert_files
 
     @dns = dns
   end
 
   ##
-  #
   # Given a source at +uri+, calculate what hostname to actually
   # connect to query the data for it.
 
@@ -91,7 +94,13 @@ class Gem::RemoteFetcher
     rescue Resolv::ResolvError
       uri
     else
-      URI.parse "#{res.target}#{uri.path}"
+      target = res.target.to_s.strip
+
+      if /\.#{Regexp.quote(host)}\z/ =~ target
+        return URI.parse "#{uri.scheme}://#{target}#{uri.path}"
+      end
+
+      uri
     end
   end
 
@@ -100,14 +109,14 @@ class Gem::RemoteFetcher
   # filename. Returns nil if the gem cannot be located.
   #--
   # Should probably be integrated with #download below, but that will be a
-  # larger, more emcompassing effort. -erikh
+  # larger, more encompassing effort. -erikh
 
   def download_to_cache dependency
     found, _ = Gem::SpecFetcher.fetcher.spec_for_dependency dependency
 
     return if found.empty?
 
-    spec, source = found.sort_by { |(s,_)| s.version }.last
+    spec, source = found.max_by { |(s,_)| s.version }
 
     download spec, source.uri.to_s
   end
@@ -132,11 +141,19 @@ class Gem::RemoteFetcher
 
     FileUtils.mkdir_p cache_dir rescue nil unless File.exist? cache_dir
 
-   # Always escape URI's to deal with potential spaces and such
-    unless URI::Generic === source_uri
-      source_uri = URI.parse(URI.const_defined?(:DEFAULT_PARSER) ?
-                             URI::DEFAULT_PARSER.escape(source_uri.to_s) :
-                             URI.escape(source_uri.to_s))
+    # Always escape URI's to deal with potential spaces and such
+    # It should also be considered that source_uri may already be
+    # a valid URI with escaped characters. e.g. "{DESede}" is encoded
+    # as "%7BDESede%7D". If this is escaped again the percentage
+    # symbols will be escaped.
+    unless source_uri.is_a?(URI::Generic)
+      begin
+        source_uri = URI.parse(source_uri)
+      rescue
+        source_uri = URI.parse(URI.const_defined?(:DEFAULT_PARSER) ?
+                               URI::DEFAULT_PARSER.escape(source_uri.to_s) :
+                               URI.escape(source_uri.to_s))
+      end
     end
 
     scheme = source_uri.scheme
@@ -147,11 +164,10 @@ class Gem::RemoteFetcher
     # REFACTOR: split this up and dispatch on scheme (eg download_http)
     # REFACTOR: be sure to clean up fake fetcher when you do this... cleaner
     case scheme
-    when 'http', 'https' then
+    when 'http', 'https', 's3' then
       unless File.exist? local_gem_path then
         begin
-          say "Downloading gem #{gem_file_name}" if
-            Gem.configuration.really_verbose
+          verbose "Downloading gem #{gem_file_name}"
 
           remote_gem_path = source_uri + "gems/#{gem_file_name}"
 
@@ -161,8 +177,7 @@ class Gem::RemoteFetcher
 
           alternate_name = "#{spec.original_name}.gem"
 
-          say "Failed, downloading gem #{alternate_name}" if
-            Gem.configuration.really_verbose
+          verbose "Failed, downloading gem #{alternate_name}"
 
           remote_gem_path = source_uri + "gems/#{alternate_name}"
 
@@ -181,8 +196,7 @@ class Gem::RemoteFetcher
         local_gem_path = source_uri.to_s
       end
 
-      say "Using local gem #{local_gem_path}" if
-        Gem.configuration.really_verbose
+      verbose "Using local gem #{local_gem_path}"
     when nil then # TODO test for local overriding cache
       source_path = if Gem.win_platform? && source_uri.scheme &&
                        !source_uri.path.include?(':') then
@@ -200,8 +214,7 @@ class Gem::RemoteFetcher
         local_gem_path = source_uri.to_s
       end
 
-      say "Using local gem #{local_gem_path}" if
-        Gem.configuration.really_verbose
+      verbose "Using local gem #{local_gem_path}"
     else
       raise ArgumentError, "unsupported URI scheme #{source_uri.scheme}"
     end
@@ -225,6 +238,7 @@ class Gem::RemoteFetcher
 
     case response
     when Net::HTTPOK, Net::HTTPNotModified then
+      response.uri = uri if response.respond_to? :uri
       head ? response : response.body
     when Net::HTTPMovedPermanently, Net::HTTPFound, Net::HTTPSeeOther,
          Net::HTTPTemporaryRedirect then
@@ -258,7 +272,7 @@ class Gem::RemoteFetcher
 
     data = send "fetch_#{uri.scheme}", uri, mtime, head
 
-    if data and !head and uri.to_s =~ /gz$/
+    if data and !head and uri.to_s =~ /\.gz$/
       begin
         data = Gem.gunzip data
       rescue Zlib::GzipFile::Error
@@ -279,6 +293,11 @@ class Gem::RemoteFetcher
     end
   end
 
+  def fetch_s3(uri, mtime = nil, head = false)
+    public_uri = sign_s3_url(uri)
+    fetch_https public_uri, mtime, head
+  end
+
   ##
   # Downloads +uri+ to +path+ if necessary. If no path is given, it just
   # passes the data.
@@ -286,19 +305,20 @@ class Gem::RemoteFetcher
   def cache_update_path uri, path = nil, update = true
     mtime = path && File.stat(path).mtime rescue nil
 
-    if mtime && Net::HTTPNotModified === fetch_path(uri, mtime, true)
-      Gem.read_binary(path)
-    else
-      data = fetch_path(uri)
+    data = fetch_path(uri, mtime)
 
-      if update and path then
-        open(path, 'wb') do |io|
-          io.write data
-        end
-      end
+    if data == nil # indicates the server returned 304 Not Modified
+      return Gem.read_binary(path)
+    end
 
-      data
+    if update and path
+      open(path, 'wb') do |io|
+        io.flock(File::LOCK_EX)
+        io.write data
+      end
     end
+
+    data
   end
 
   ##
@@ -312,7 +332,7 @@ class Gem::RemoteFetcher
 
   def correct_for_windows_path(path)
     if path[0].chr == '/' && path[1].chr =~ /[a-z]/i && path[2].chr == ':'
-      path = path[1..-1]
+      path[1..-1]
     else
       path
     end
@@ -324,7 +344,10 @@ class Gem::RemoteFetcher
   # connections to reduce connect overhead.
 
   def request(uri, request_class, last_modified = nil)
-    request = Gem::Request.new uri, request_class, last_modified, @proxy
+    proxy = proxy_for @proxy, uri
+    pool  = pools_for(proxy).pool_for uri
+
+    request = Gem::Request.new uri, request_class, last_modified, pool
 
     request.fetch do |req|
       yield req if block_given?
@@ -335,5 +358,47 @@ class Gem::RemoteFetcher
     uri.scheme.downcase == 'https'
   end
 
+  def close_all
+    @pools.each_value {|pool| pool.close_all}
+  end
+
+  protected
+
+  # we have our own signing code here to avoid a dependency on the aws-sdk gem
+  # fortunately, a simple GET request isn't too complex to sign properly
+  def sign_s3_url(uri, expiration = nil)
+    require 'base64'
+    require 'openssl'
+
+    unless uri.user && uri.password
+      raise FetchError.new("credentials needed in s3 source, like s3://key:secret@bucket-name/", uri.to_s)
+    end
+
+    expiration ||= s3_expiration
+    canonical_path = "/#{uri.host}#{uri.path}"
+    payload = "GET\n\n\n#{expiration}\n#{canonical_path}"
+    digest = OpenSSL::HMAC.digest('sha1', uri.password, payload)
+    # URI.escape is deprecated, and there isn't yet a replacement that does quite what we want
+    signature = Base64.encode64(digest).gsub("\n", '').gsub(/[\+\/=]/) { |c| BASE64_URI_TRANSLATE[c] }
+    URI.parse("https://#{uri.host}.s3.amazonaws.com#{uri.path}?AWSAccessKeyId=#{uri.user}&Expires=#{expiration}&Signature=#{signature}")
+  end
+
+  def s3_expiration
+    (Time.now + 3600).to_i # one hour from now
+  end
+
+  BASE64_URI_TRANSLATE = { '+' => '%2B', '/' => '%2F', '=' => '%3D' }.freeze
+
+  private
+
+  def proxy_for proxy, uri
+    Gem::Request.proxy_uri(proxy || Gem::Request.get_proxy_from_env(uri.scheme))
+  end
+
+  def pools_for proxy
+    @pool_lock.synchronize do
+      @pools[proxy] ||= Gem::Request::ConnectionPools.new proxy, @cert_files
+    end
+  end
 end
 
diff --git a/jruby/lib/ruby/shared/rubygems/request.rb b/jruby/lib/ruby/shared/rubygems/request.rb
index fe72611..702769c 100644
--- a/jruby/lib/ruby/shared/rubygems/request.rb
+++ b/jruby/lib/ruby/shared/rubygems/request.rb
@@ -7,35 +7,43 @@ class Gem::Request
 
   include Gem::UserInteraction
 
-  attr_reader :proxy_uri
+  ###
+  # Legacy.  This is used in tests.
+  def self.create_with_proxy uri, request_class, last_modified, proxy # :nodoc:
+    cert_files = get_cert_files
+    proxy ||= get_proxy_from_env(uri.scheme)
+    pool       = ConnectionPools.new proxy_uri(proxy), cert_files
+
+    new(uri, request_class, last_modified, pool.pool_for(uri))
+  end
+
+  def self.proxy_uri proxy # :nodoc:
+    case proxy
+    when :no_proxy then nil
+    when URI::HTTP then proxy
+    else URI.parse(proxy)
+    end
+  end
 
-  def initialize(uri, request_class, last_modified, proxy)
+  def initialize(uri, request_class, last_modified, pool)
     @uri = uri
     @request_class = request_class
     @last_modified = last_modified
     @requests = Hash.new 0
-    @connections = {}
-    @connections_mutex = Mutex.new
     @user_agent = user_agent
 
-    @proxy_uri =
-      case proxy
-      when :no_proxy then nil
-      when nil then get_proxy_from_env
-      when URI::HTTP then proxy
-      else URI.parse(proxy)
-      end
-    @env_no_proxy = get_no_proxy_from_env
+    @connection_pool = pool
   end
 
-  def add_rubygems_trusted_certs(store)
+  def proxy_uri; @connection_pool.proxy_uri; end
+  def cert_files; @connection_pool.cert_files; end
+
+  def self.get_cert_files
     pattern = File.expand_path("./ssl_certs/*.pem", File.dirname(__FILE__))
-    Dir.glob(pattern).each do |ssl_cert_file|
-      store.add_file ssl_cert_file
-    end
+    Dir.glob(pattern)
   end
 
-  def configure_connection_for_https(connection)
+  def self.configure_connection_for_https(connection, cert_files)
     require 'net/https'
     connection.use_ssl = true
     connection.verify_mode =
@@ -48,17 +56,19 @@ class Gem::Request
       connection.key = OpenSSL::PKey::RSA.new pem
     end
 
+    store.set_default_paths
+    cert_files.each do |ssl_cert_file|
+      store.add_file ssl_cert_file
+    end
     if Gem.configuration.ssl_ca_cert
       if File.directory? Gem.configuration.ssl_ca_cert
         store.add_path Gem.configuration.ssl_ca_cert
       else
         store.add_file Gem.configuration.ssl_ca_cert
       end
-    else
-      store.set_default_paths
-      add_rubygems_trusted_certs(store)
     end
     connection.cert_store = store
+    connection
   rescue LoadError => e
     raise unless (e.respond_to?(:path) && e.path == 'openssl') ||
                  e.message =~ / -- openssl$/
@@ -72,31 +82,7 @@ class Gem::Request
   # connection, using a proxy if needed.
 
   def connection_for(uri)
-    net_http_args = [uri.host, uri.port]
-
-    if @proxy_uri and not no_proxy?(uri.host) then
-      net_http_args += [
-        @proxy_uri.host,
-        @proxy_uri.port,
-        Gem::UriFormatter.new(@proxy_uri.user).unescape,
-        Gem::UriFormatter.new(@proxy_uri.password).unescape,
-      ]
-    end
-
-    connection_id = [Thread.current.object_id, *net_http_args].join ':'
-
-    connection = @connections_mutex.synchronize do
-      @connections[connection_id] ||= Net::HTTP.new(*net_http_args)
-      @connections[connection_id]
-    end
-
-    if https?(uri) and not connection.started? then
-      configure_connection_for_https(connection)
-    end
-
-    connection.start unless connection.started?
-
-    connection
+    @connection_pool.checkout
   rescue defined?(OpenSSL::SSL) ? OpenSSL::SSL::SSLError : Errno::EHOSTDOWN,
          Errno::EHOSTDOWN => e
     raise Gem::RemoteFetcher::FetchError.new(e.message, uri)
@@ -106,7 +92,8 @@ class Gem::Request
     request = @request_class.new @uri.request_uri
 
     unless @uri.nil? || @uri.user.nil? || @uri.user.empty? then
-      request.basic_auth @uri.user, @uri.password
+      request.basic_auth Gem::UriFormatter.new(@uri.user).unescape,
+                         Gem::UriFormatter.new(@uri.password).unescape
     end
 
     request.add_field 'User-Agent', @user_agent
@@ -119,6 +106,37 @@ class Gem::Request
 
     yield request if block_given?
 
+    perform_request request
+  end
+
+  ##
+  # Returns a proxy URI for the given +scheme+ if one is set in the
+  # environment variables.
+
+  def self.get_proxy_from_env scheme = 'http'
+    _scheme = scheme.downcase
+    _SCHEME = scheme.upcase
+    env_proxy = ENV["#{_scheme}_proxy"] || ENV["#{_SCHEME}_PROXY"]
+
+    no_env_proxy = env_proxy.nil? || env_proxy.empty?
+
+    return get_proxy_from_env 'http' if no_env_proxy and _scheme != 'http'
+    return :no_proxy                 if no_env_proxy
+
+    uri = URI(Gem::UriFormatter.new(env_proxy).normalize)
+
+    if uri and uri.user.nil? and uri.password.nil? then
+      user     = ENV["#{_scheme}_proxy_user"] || ENV["#{_SCHEME}_PROXY_USER"]
+      password = ENV["#{_scheme}_proxy_pass"] || ENV["#{_SCHEME}_PROXY_PASS"]
+
+      uri.user     = Gem::UriFormatter.new(user).escape
+      uri.password = Gem::UriFormatter.new(password).escape
+    end
+
+    uri
+  end
+
+  def perform_request request # :nodoc:
     connection = connection_for @uri
 
     retried = false
@@ -127,8 +145,7 @@ class Gem::Request
     begin
       @requests[connection.object_id] += 1
 
-      say "#{request.method} #{@uri}" if
-        Gem.configuration.really_verbose
+      verbose "#{request.method} #{@uri}"
 
       file_name = File.basename(@uri.path)
       # perform download progress reporter only for gems
@@ -157,11 +174,10 @@ class Gem::Request
         response = connection.request request
       end
 
-      say "#{response.code} #{response.message}" if
-        Gem.configuration.really_verbose
+      verbose "#{response.code} #{response.message}"
 
     rescue Net::HTTPBadResponse
-      say "bad response" if Gem.configuration.really_verbose
+      verbose "bad response"
 
       reset connection
 
@@ -176,8 +192,7 @@ class Gem::Request
            Errno::ECONNABORTED, Errno::ECONNRESET, Errno::EPIPE
 
       requests = @requests[connection.object_id]
-      say "connection reset after #{requests} requests, retrying" if
-        Gem.configuration.really_verbose
+      verbose "connection reset after #{requests} requests, retrying"
 
       raise Gem::RemoteFetcher::FetchError.new('too many connection resets', @uri) if retried
 
@@ -188,49 +203,8 @@ class Gem::Request
     end
 
     response
-  end
-
-  ##
-  # Returns list of no_proxy entries (if any) from the environment
-
-  def get_no_proxy_from_env
-    env_no_proxy = ENV['no_proxy'] || ENV['NO_PROXY']
-
-    return [] if env_no_proxy.nil?  or env_no_proxy.empty?
-
-    env_no_proxy.split(/\s*,\s*/)
-  end
-
-  ##
-  # Returns an HTTP proxy URI if one is set in the environment variables.
-
-  def get_proxy_from_env
-    env_proxy = ENV['http_proxy'] || ENV['HTTP_PROXY']
-
-    return nil if env_proxy.nil? or env_proxy.empty?
-
-    uri = URI(Gem::UriFormatter.new(env_proxy).normalize)
-
-    if uri and uri.user.nil? and uri.password.nil? then
-      # Probably we have http_proxy_* variables?
-      uri.user = Gem::UriFormatter.new(ENV['http_proxy_user'] || ENV['HTTP_PROXY_USER']).escape
-      uri.password = Gem::UriFormatter.new(ENV['http_proxy_pass'] || ENV['HTTP_PROXY_PASS']).escape
-    end
-
-    uri
-  end
-
-  def https?(uri)
-    uri.scheme.downcase == 'https'
-  end
-
-  def no_proxy? host
-    host = host.downcase
-    @env_no_proxy.each do |pattern|
-      pattern = pattern.downcase
-      return true if host[-pattern.length, pattern.length ] == pattern
-    end
-    return false
+  ensure
+    @connection_pool.checkin connection
   end
 
   ##
@@ -264,3 +238,7 @@ class Gem::Request
 
 end
 
+require 'rubygems/request/http_pool'
+require 'rubygems/request/https_pool'
+require 'rubygems/request/connection_pools'
+
diff --git a/jruby/lib/ruby/shared/rubygems/request/connection_pools.rb b/jruby/lib/ruby/shared/rubygems/request/connection_pools.rb
new file mode 100644
index 0000000..7a0a6e6
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/request/connection_pools.rb
@@ -0,0 +1,83 @@
+require 'thread'
+
+class Gem::Request::ConnectionPools # :nodoc:
+
+  @client = Net::HTTP
+
+  class << self
+    attr_accessor :client
+  end
+
+  def initialize proxy_uri, cert_files
+    @proxy_uri  = proxy_uri
+    @cert_files = cert_files
+    @pools      = {}
+    @pool_mutex = Mutex.new
+  end
+
+  def pool_for uri
+    http_args = net_http_args(uri, @proxy_uri)
+    key       = http_args + [https?(uri)]
+    @pool_mutex.synchronize do
+      @pools[key] ||=
+        if https? uri then
+          Gem::Request::HTTPSPool.new(http_args, @cert_files, @proxy_uri)
+        else
+          Gem::Request::HTTPPool.new(http_args, @cert_files, @proxy_uri)
+        end
+    end
+  end
+
+  def close_all
+    @pools.each_value {|pool| pool.close_all}
+  end
+
+  private
+
+  ##
+  # Returns list of no_proxy entries (if any) from the environment
+
+  def get_no_proxy_from_env
+    env_no_proxy = ENV['no_proxy'] || ENV['NO_PROXY']
+
+    return [] if env_no_proxy.nil?  or env_no_proxy.empty?
+
+    env_no_proxy.split(/\s*,\s*/)
+  end
+
+  def https? uri
+    uri.scheme.downcase == 'https'
+  end
+
+  def no_proxy? host, env_no_proxy
+    host = host.downcase
+
+    env_no_proxy.any? do |pattern|
+      pattern = pattern.downcase
+
+      host[-pattern.length, pattern.length] == pattern or
+        (pattern.start_with? '.' and pattern[1..-1] == host)
+    end
+  end
+
+  def net_http_args uri, proxy_uri
+    net_http_args = [uri.host, uri.port]
+
+    no_proxy = get_no_proxy_from_env
+
+    if proxy_uri and not no_proxy?(uri.host, no_proxy) then
+      net_http_args + [
+        proxy_uri.host,
+        proxy_uri.port,
+        Gem::UriFormatter.new(proxy_uri.user).unescape,
+        Gem::UriFormatter.new(proxy_uri.password).unescape,
+      ]
+    elsif no_proxy? uri.host, no_proxy then
+      net_http_args + [nil, nil]
+    else
+      net_http_args
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/request/http_pool.rb b/jruby/lib/ruby/shared/rubygems/request/http_pool.rb
new file mode 100644
index 0000000..c9a1858
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/request/http_pool.rb
@@ -0,0 +1,47 @@
+##
+# A connection "pool" that only manages one connection for now.  Provides
+# thread safe `checkout` and `checkin` methods.  The pool consists of one
+# connection that corresponds to `http_args`.  This class is private, do not
+# use it.
+
+class Gem::Request::HTTPPool # :nodoc:
+  attr_reader :cert_files, :proxy_uri
+
+  def initialize http_args, cert_files, proxy_uri
+    @http_args  = http_args
+    @cert_files = cert_files
+    @proxy_uri  = proxy_uri
+    @queue      = SizedQueue.new 1
+    @queue << nil
+  end
+
+  def checkout
+    @queue.pop || make_connection
+  end
+
+  def checkin connection
+    @queue.push connection
+  end
+
+  def close_all
+    until @queue.empty?
+      if connection = @queue.pop(true) and connection.started?
+        connection.finish
+      end
+    end
+    @queue.push(nil)
+  end
+
+  private
+
+  def make_connection
+    setup_connection Gem::Request::ConnectionPools.client.new(*@http_args)
+  end
+
+  def setup_connection connection
+    connection.start
+    connection
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/request/https_pool.rb b/jruby/lib/ruby/shared/rubygems/request/https_pool.rb
new file mode 100644
index 0000000..2e3da0a
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/request/https_pool.rb
@@ -0,0 +1,10 @@
+class Gem::Request::HTTPSPool < Gem::Request::HTTPPool # :nodoc:
+  private
+
+  def setup_connection connection
+    Gem::Request.configure_connection_for_https(connection, @cert_files)
+    super
+  end
+end
+
+
diff --git a/jruby/lib/ruby/shared/rubygems/request_set.rb b/jruby/lib/ruby/shared/rubygems/request_set.rb
index a45c64e..cfbc955 100644
--- a/jruby/lib/ruby/shared/rubygems/request_set.rb
+++ b/jruby/lib/ruby/shared/rubygems/request_set.rb
@@ -1,10 +1,18 @@
-require 'rubygems'
-require 'rubygems/dependency'
-require 'rubygems/dependency_resolver'
-require 'rubygems/dependency_list'
-require 'rubygems/installer'
 require 'tsort'
 
+##
+# A RequestSet groups a request to activate a set of dependencies.
+#
+#   nokogiri = Gem::Dependency.new 'nokogiri', '~> 1.6'
+#   pg = Gem::Dependency.new 'pg', '~> 0.14'
+#
+#   set = Gem::RequestSet.new nokogiri, pg
+#
+#   requests = set.resolve
+#
+#   p requests.map { |r| r.full_name }
+#   #=> ["nokogiri-1.6.0", "mini_portile-0.5.1", "pg-0.17.0"]
+
 class Gem::RequestSet
 
   include TSort
@@ -12,26 +20,91 @@ class Gem::RequestSet
   ##
   # Array of gems to install even if already installed
 
-  attr_reader :always_install
+  attr_accessor :always_install
 
   attr_reader :dependencies
 
   attr_accessor :development
 
   ##
+  # Errors fetching gems during resolution.
+
+  attr_reader :errors
+
+  ##
+  # Set to true if you want to install only direct development dependencies.
+
+  attr_accessor :development_shallow
+
+  ##
+  # The set of git gems imported via load_gemdeps.
+
+  attr_reader :git_set # :nodoc:
+
+  ##
+  # When true, dependency resolution is not performed, only the requested gems
+  # are installed.
+
+  attr_accessor :ignore_dependencies
+
+  attr_reader :install_dir # :nodoc:
+
+  ##
+  # If true, allow dependencies to match prerelease gems.
+
+  attr_accessor :prerelease
+
+  ##
+  # When false no remote sets are used for resolving gems.
+
+  attr_accessor :remote
+
+  attr_reader :resolver # :nodoc:
+
+  ##
+  # Sets used for resolution
+
+  attr_reader :sets # :nodoc:
+
+  ##
   # Treat missing dependencies as silent errors
 
   attr_accessor :soft_missing
 
+  ##
+  # The set of vendor gems imported via load_gemdeps.
+
+  attr_reader :vendor_set # :nodoc:
+
+  ##
+  # Creates a RequestSet for a list of Gem::Dependency objects, +deps+.  You
+  # can then #resolve and #install the resolved list of dependencies.
+  #
+  #   nokogiri = Gem::Dependency.new 'nokogiri', '~> 1.6'
+  #   pg = Gem::Dependency.new 'pg', '~> 0.14'
+  #
+  #   set = Gem::RequestSet.new nokogiri, pg
+
   def initialize *deps
     @dependencies = deps
 
-    @always_install = []
-    @development    = false
-    @requests       = []
-    @soft_missing   = false
-    @sorted         = nil
-    @specs          = nil
+    @always_install      = []
+    @conservative        = false
+    @dependency_names    = {}
+    @development         = false
+    @development_shallow = false
+    @errors              = []
+    @git_set             = nil
+    @ignore_dependencies = false
+    @install_dir         = Gem.dir
+    @prerelease          = false
+    @remote              = true
+    @requests            = []
+    @sets                = []
+    @soft_missing        = false
+    @sorted              = nil
+    @specs               = nil
+    @vendor_set          = nil
 
     yield self if block_given?
   end
@@ -40,30 +113,48 @@ class Gem::RequestSet
   # Declare that a gem of name +name+ with +reqs+ requirements is needed.
 
   def gem name, *reqs
-    @dependencies << Gem::Dependency.new(name, reqs)
+    if dep = @dependency_names[name] then
+      dep.requirement.concat reqs
+    else
+      dep = Gem::Dependency.new name, *reqs
+      @dependency_names[name] = dep
+      @dependencies << dep
+    end
   end
 
   ##
   # Add +deps+ Gem::Dependency objects to the set.
 
   def import deps
-    @dependencies += deps
+    @dependencies.concat deps
   end
 
-  def install options, &block
+  ##
+  # Installs gems for this RequestSet using the Gem::Installer +options+.
+  #
+  # If a +block+ is given an activation +request+ and +installer+ are yielded.
+  # The +installer+ will be +nil+ if a gem matching the request was already
+  # installed.
+
+  def install options, &block # :yields: request, installer
     if dir = options[:install_dir]
-      return install_into dir, false, options, &block
+      requests = install_into dir, false, options, &block
+      return requests
     end
 
     cache_dir = options[:cache_dir] || Gem.dir
+    @prerelease = options[:prerelease]
 
-    specs = []
+    requests = []
 
     sorted_requests.each do |req|
-      if req.installed? and
-         @always_install.none? { |spec| spec == req.spec.spec } then
-        yield req, nil if block_given?
-        next
+      if req.installed? then
+        req.spec.spec.build_extensions
+
+        if @always_install.none? { |spec| spec == req.spec.spec } then
+          yield req, nil if block_given?
+          next
+        end
       end
 
       path = req.download cache_dir
@@ -72,13 +163,77 @@ class Gem::RequestSet
 
       yield req, inst if block_given?
 
-      specs << inst.install
+      requests << inst.install
+    end
+
+    requests
+  ensure
+    raise if $!
+    return requests if options[:gemdeps]
+
+    specs = requests.map do |request|
+      case request
+      when Gem::Resolver::ActivationRequest then
+        request.spec.spec
+      else
+        request
+      end
     end
 
-    specs
+    require 'rubygems/dependency_installer'
+    inst = Gem::DependencyInstaller.new options
+    inst.installed_gems.replace specs
+
+    Gem.done_installing_hooks.each do |hook|
+      hook.call inst, specs
+    end unless Gem.done_installing_hooks.empty?
+  end
+
+  ##
+  # Installs from the gem dependencies files in the +:gemdeps+ option in
+  # +options+, yielding to the +block+ as in #install.
+  #
+  # If +:without_groups+ is given in the +options+, those groups in the gem
+  # dependencies file are not used.  See Gem::Installer for other +options+.
+
+  def install_from_gemdeps options, &block
+    gemdeps = options[:gemdeps]
+
+    @install_dir = options[:install_dir] || Gem.dir
+    @prerelease  = options[:prerelease]
+    @remote      = options[:domain] != :local
+    @conservative = true if options[:conservative]
+
+    gem_deps_api = load_gemdeps gemdeps, options[:without_groups], true
+
+    resolve
+
+    if options[:explain]
+      puts "Gems to install:"
+
+      sorted_requests.each do |spec|
+        puts "  #{spec.full_name}"
+      end
+
+      if Gem.configuration.really_verbose
+        @resolver.stats.display
+      end
+    else
+      installed = install options, &block
+
+      if options.fetch :lock, true then
+        lockfile =
+          Gem::RequestSet::Lockfile.build self, gemdeps, gem_deps_api.dependencies
+        lockfile.write
+      end
+
+      installed
+    end
   end
 
   def install_into dir, force = true, options = {}
+    gem_home, ENV['GEM_HOME'] = ENV['GEM_HOME'], dir
+
     existing = force ? [] : specs_in(dir)
     existing.delete_if { |s| @always_install.include? s }
 
@@ -86,52 +241,130 @@ class Gem::RequestSet
 
     installed = []
 
-    sorted_requests.each do |req|
-      if existing.find { |s| s.full_name == req.spec.full_name }
-        yield req, nil if block_given?
-        next
-      end
+    options[:development] = false
+    options[:install_dir] = dir
+    options[:only_install_dir] = true
+    @prerelease = options[:prerelease]
 
-      path = req.download(dir)
+    sorted_requests.each do |request|
+      spec = request.spec
 
-      unless path then # already installed
-        yield req, nil if block_given?
+      if existing.find { |s| s.full_name == spec.full_name } then
+        yield request, nil if block_given?
         next
       end
 
-      options[:install_dir] = dir
-      options[:only_install_dir] = true
-
-      inst = Gem::Installer.new path, options
-
-      yield req, inst if block_given?
-
-      inst.install
+      spec.install options do |installer|
+        yield request, installer if block_given?
+      end
 
-      installed << req
+      installed << request
     end
 
     installed
+  ensure
+    ENV['GEM_HOME'] = gem_home
   end
 
   ##
   # Load a dependency management file.
 
-  def load_gemdeps path
-    gf = Gem::RequestSet::GemDepedencyAPI.new self, path
+  def load_gemdeps path, without_groups = [], installing = false
+    @git_set    = Gem::Resolver::GitSet.new
+    @vendor_set = Gem::Resolver::VendorSet.new
+
+    @git_set.root_dir = @install_dir
+
+    lock_file = "#{File.expand_path(path)}.lock".untaint
+    begin
+      tokenizer = Gem::RequestSet::Lockfile::Tokenizer.from_file lock_file
+      parser = tokenizer.make_parser self, []
+      parser.parse
+    rescue Errno::ENOENT
+    end
+
+    gf = Gem::RequestSet::GemDependencyAPI.new self, path
+    gf.installing = installing
+    gf.without_groups = without_groups if without_groups
     gf.load
   end
 
+  def pretty_print q # :nodoc:
+    q.group 2, '[RequestSet:', ']' do
+      q.breakable
+
+      if @remote then
+        q.text 'remote'
+        q.breakable
+      end
+
+      if @prerelease then
+        q.text 'prerelease'
+        q.breakable
+      end
+
+      if @development_shallow then
+        q.text 'shallow development'
+        q.breakable
+      elsif @development then
+        q.text 'development'
+        q.breakable
+      end
+
+      if @soft_missing then
+        q.text 'soft missing'
+      end
+
+      q.group 2, '[dependencies:', ']' do
+        q.breakable
+        @dependencies.map do |dep|
+          q.text dep.to_s
+          q.breakable
+        end
+      end
+
+      q.breakable
+      q.text 'sets:'
+
+      q.breakable
+      q.pp @sets.map { |set| set.class }
+    end
+  end
+
   ##
   # Resolve the requested dependencies and return an Array of Specification
   # objects to be activated.
 
-  def resolve set = nil
-    resolver = Gem::DependencyResolver.new @dependencies, set
-    resolver.development  = @development
-    resolver.soft_missing = @soft_missing
+  def resolve set = Gem::Resolver::BestSet.new
+    @sets << set
+    @sets << @git_set
+    @sets << @vendor_set
+
+    set = Gem::Resolver.compose_sets(*@sets)
+    set.remote = @remote
+    set.prerelease = @prerelease
+
+    resolver = Gem::Resolver.new @dependencies, set
+    resolver.development         = @development
+    resolver.development_shallow = @development_shallow
+    resolver.ignore_dependencies = @ignore_dependencies
+    resolver.soft_missing        = @soft_missing
+
+    if @conservative
+      installed_gems = {}
+      Gem::Specification.find_all do |spec|
+        (installed_gems[spec.name] ||= []) << spec
+      end
+      resolver.skip_gems = installed_gems
+    end
+
+    @resolver = resolver
 
     @requests = resolver.resolve
+
+    @errors = set.errors
+
+    @requests
   end
 
   ##
@@ -139,7 +372,7 @@ class Gem::RequestSet
   # and return an Array of Specification objects to be activated.
 
   def resolve_current
-    resolve Gem::DependencyResolver::CurrentSet.new
+    resolve Gem::Resolver::CurrentSet.new
   end
 
   def sorted_requests
@@ -164,20 +397,23 @@ class Gem::RequestSet
     node.spec.dependencies.each do |dep|
       next if dep.type == :development and not @development
 
-      match = @requests.find { |r| dep.match? r.spec.name, r.spec.version }
-      if match
-        begin
-          yield match
-        rescue TSort::Cyclic
-        end
-      else
-        unless @soft_missing
-          raise Gem::DependencyError, "Unresolved depedency found during sorting - #{dep}"
-        end
+      match = @requests.find { |r|
+        dep.match? r.spec.name, r.spec.version, @prerelease
+      }
+
+      unless match then
+        next if dep.type == :development and @development_shallow
+        next if @soft_missing
+        raise Gem::DependencyError,
+              "Unresolved dependency found during sorting - #{dep} (requested by #{node.spec.full_name})"
       end
+
+      yield match
     end
   end
 
 end
 
 require 'rubygems/request_set/gem_dependency_api'
+require 'rubygems/request_set/lockfile'
+require 'rubygems/request_set/lockfile/tokenizer'
diff --git a/jruby/lib/ruby/shared/rubygems/request_set/gem_dependency_api.rb b/jruby/lib/ruby/shared/rubygems/request_set/gem_dependency_api.rb
index 178ed1b..6dd7892 100644
--- a/jruby/lib/ruby/shared/rubygems/request_set/gem_dependency_api.rb
+++ b/jruby/lib/ruby/shared/rubygems/request_set/gem_dependency_api.rb
@@ -1,39 +1,801 @@
 ##
-# A semi-compatible DSL for Bundler's Gemfile format
+# A semi-compatible DSL for the Bundler Gemfile and Isolate gem dependencies
+# files.
+#
+# To work with both the Bundler Gemfile and Isolate formats this
+# implementation takes some liberties to allow compatibility with each, most
+# notably in #source.
+#
+# A basic gem dependencies file will look like the following:
+#
+#   source 'https://rubygems.org'
+#
+#   gem 'rails', '3.2.14a
+#   gem 'devise', '~> 2.1', '>= 2.1.3'
+#   gem 'cancan'
+#   gem 'airbrake'
+#   gem 'pg'
+#
+# RubyGems recommends saving this as gem.deps.rb over Gemfile or Isolate.
+#
+# To install the gems in this Gemfile use `gem install -g` to install it and
+# create a lockfile.  The lockfile will ensure that when you make changes to
+# your gem dependencies file a minimum amount of change is made to the
+# dependencies of your gems.
+#
+# RubyGems can activate all the gems in your dependencies file at startup
+# using the RUBYGEMS_GEMDEPS environment variable or through Gem.use_gemdeps.
+# See Gem.use_gemdeps for details and warnings.
+#
+# See `gem help install` and `gem help gem_dependencies` for further details.
 
-class Gem::RequestSet::GemDepedencyAPI
+class Gem::RequestSet::GemDependencyAPI
+
+  ENGINE_MAP = { # :nodoc:
+    :jruby        => %w[jruby],
+    :jruby_18     => %w[jruby],
+    :jruby_19     => %w[jruby],
+    :maglev       => %w[maglev],
+    :mri          => %w[ruby],
+    :mri_18       => %w[ruby],
+    :mri_19       => %w[ruby],
+    :mri_20       => %w[ruby],
+    :mri_21       => %w[ruby],
+    :rbx          => %w[rbx],
+    :ruby         => %w[ruby rbx maglev],
+    :ruby_18      => %w[ruby rbx maglev],
+    :ruby_19      => %w[ruby rbx maglev],
+    :ruby_20      => %w[ruby rbx maglev],
+    :ruby_21      => %w[ruby rbx maglev],
+  }
+
+  mswin     = Gem::Platform.new 'x86-mswin32'
+  mswin64   = Gem::Platform.new 'x64-mswin64'
+  x86_mingw = Gem::Platform.new 'x86-mingw32'
+  x64_mingw = Gem::Platform.new 'x64-mingw32'
+
+  PLATFORM_MAP = { # :nodoc:
+    :jruby        => Gem::Platform::RUBY,
+    :jruby_18     => Gem::Platform::RUBY,
+    :jruby_19     => Gem::Platform::RUBY,
+    :maglev       => Gem::Platform::RUBY,
+    :mingw        => x86_mingw,
+    :mingw_18     => x86_mingw,
+    :mingw_19     => x86_mingw,
+    :mingw_20     => x86_mingw,
+    :mingw_21     => x86_mingw,
+    :mri          => Gem::Platform::RUBY,
+    :mri_18       => Gem::Platform::RUBY,
+    :mri_19       => Gem::Platform::RUBY,
+    :mri_20       => Gem::Platform::RUBY,
+    :mri_21       => Gem::Platform::RUBY,
+    :mswin        => mswin,
+    :mswin_18     => mswin,
+    :mswin_19     => mswin,
+    :mswin_20     => mswin,
+    :mswin_21     => mswin,
+    :mswin64      => mswin64,
+    :mswin64_19   => mswin64,
+    :mswin64_20   => mswin64,
+    :mswin64_21   => mswin64,
+    :rbx          => Gem::Platform::RUBY,
+    :ruby         => Gem::Platform::RUBY,
+    :ruby_18      => Gem::Platform::RUBY,
+    :ruby_19      => Gem::Platform::RUBY,
+    :ruby_20      => Gem::Platform::RUBY,
+    :ruby_21      => Gem::Platform::RUBY,
+    :x64_mingw    => x64_mingw,
+    :x64_mingw_20 => x64_mingw,
+    :x64_mingw_21 => x64_mingw
+  }
+
+  gt_eq_0        = Gem::Requirement.new '>= 0'
+  tilde_gt_1_8_0 = Gem::Requirement.new '~> 1.8.0'
+  tilde_gt_1_9_0 = Gem::Requirement.new '~> 1.9.0'
+  tilde_gt_2_0_0 = Gem::Requirement.new '~> 2.0.0'
+  tilde_gt_2_1_0 = Gem::Requirement.new '~> 2.1.0'
+
+  VERSION_MAP = { # :nodoc:
+    :jruby        => gt_eq_0,
+    :jruby_18     => tilde_gt_1_8_0,
+    :jruby_19     => tilde_gt_1_9_0,
+    :maglev       => gt_eq_0,
+    :mingw        => gt_eq_0,
+    :mingw_18     => tilde_gt_1_8_0,
+    :mingw_19     => tilde_gt_1_9_0,
+    :mingw_20     => tilde_gt_2_0_0,
+    :mingw_21     => tilde_gt_2_1_0,
+    :mri          => gt_eq_0,
+    :mri_18       => tilde_gt_1_8_0,
+    :mri_19       => tilde_gt_1_9_0,
+    :mri_20       => tilde_gt_2_0_0,
+    :mri_21       => tilde_gt_2_1_0,
+    :mswin        => gt_eq_0,
+    :mswin_18     => tilde_gt_1_8_0,
+    :mswin_19     => tilde_gt_1_9_0,
+    :mswin_20     => tilde_gt_2_0_0,
+    :mswin_21     => tilde_gt_2_1_0,
+    :mswin64      => gt_eq_0,
+    :mswin64_19   => tilde_gt_1_9_0,
+    :mswin64_20   => tilde_gt_2_0_0,
+    :mswin64_21   => tilde_gt_2_1_0,
+    :rbx          => gt_eq_0,
+    :ruby         => gt_eq_0,
+    :ruby_18      => tilde_gt_1_8_0,
+    :ruby_19      => tilde_gt_1_9_0,
+    :ruby_20      => tilde_gt_2_0_0,
+    :ruby_21      => tilde_gt_2_1_0,
+    :x64_mingw    => gt_eq_0,
+    :x64_mingw_20 => tilde_gt_2_0_0,
+    :x64_mingw_21 => tilde_gt_2_1_0,
+  }
+
+  WINDOWS = { # :nodoc:
+    :mingw        => :only,
+    :mingw_18     => :only,
+    :mingw_19     => :only,
+    :mingw_20     => :only,
+    :mingw_21     => :only,
+    :mri          => :never,
+    :mri_18       => :never,
+    :mri_19       => :never,
+    :mri_20       => :never,
+    :mri_21       => :never,
+    :mswin        => :only,
+    :mswin_18     => :only,
+    :mswin_19     => :only,
+    :mswin_20     => :only,
+    :mswin_21     => :only,
+    :mswin64      => :only,
+    :mswin64_19   => :only,
+    :mswin64_20   => :only,
+    :mswin64_21   => :only,
+    :rbx          => :never,
+    :ruby         => :never,
+    :ruby_18      => :never,
+    :ruby_19      => :never,
+    :ruby_20      => :never,
+    :ruby_21      => :never,
+    :x64_mingw    => :only,
+    :x64_mingw_20 => :only,
+    :x64_mingw_21 => :only,
+  }
+
+  ##
+  # The gems required by #gem statements in the gem.deps.rb file
+
+  attr_reader :dependencies
+
+  ##
+  # A set of gems that are loaded via the +:git+ option to #gem
+
+  attr_reader :git_set # :nodoc:
+
+  ##
+  # A Hash containing gem names and files to require from those gems.
+
+  attr_reader :requires # :nodoc:
+
+  ##
+  # A set of gems that are loaded via the +:path+ option to #gem
+
+  attr_reader :vendor_set # :nodoc:
+
+  ##
+  # The groups of gems to exclude from installation
+
+  attr_accessor :without_groups # :nodoc:
+
+  ##
+  # Creates a new GemDependencyAPI that will add dependencies to the
+  # Gem::RequestSet +set+ based on the dependency API description in +path+.
 
   def initialize set, path
     @set = set
     @path = path
+
+    @current_groups     = nil
+    @current_platforms  = nil
+    @current_repository = nil
+    @dependencies       = {}
+    @default_sources    = true
+    @git_set            = @set.git_set
+    @git_sources        = {}
+    @installing         = false
+    @requires           = Hash.new { |h, name| h[name] = [] }
+    @vendor_set         = @set.vendor_set
+    @gem_sources        = {}
+    @without_groups     = []
+
+    git_source :github do |repo_name|
+      repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include? "/"
+
+      "git://github.com/#{repo_name}.git"
+    end
+
+    git_source :bitbucket do |repo_name|
+      repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include? "/"
+
+      user, = repo_name.split "/", 2
+
+      "https://#{user}@bitbucket.org/#{repo_name}.git"
+    end
+  end
+
+  ##
+  # Adds +dependencies+ to the request set if any of the +groups+ are allowed.
+  # This is used for gemspec dependencies.
+
+  def add_dependencies groups, dependencies # :nodoc:
+    return unless (groups & @without_groups).empty?
+
+    dependencies.each do |dep|
+      @set.gem dep.name, *dep.requirement
+    end
+  end
+
+  private :add_dependencies
+
+  ##
+  # Finds a gemspec with the given +name+ that lives at +path+.
+
+  def find_gemspec name, path # :nodoc:
+    glob = File.join path, "#{name}.gemspec"
+
+    spec_files = Dir[glob]
+
+    case spec_files.length
+    when 1 then
+      spec_file = spec_files.first
+
+      spec = Gem::Specification.load spec_file
+
+      return spec if spec
+
+      raise ArgumentError, "invalid gemspec #{spec_file}"
+    when 0 then
+      raise ArgumentError, "no gemspecs found at #{Dir.pwd}"
+    else
+      raise ArgumentError,
+        "found multiple gemspecs at #{Dir.pwd}, " +
+        "use the name: option to specify the one you want"
+    end
+  end
+
+  ##
+  # Changes the behavior of gem dependency file loading to installing mode.
+  # In installing mode certain restrictions are ignored such as ruby version
+  # mismatch checks.
+
+  def installing= installing # :nodoc:
+    @installing = installing
   end
 
+  ##
+  # Loads the gem dependency file and returns self.
+
   def load
     instance_eval File.read(@path).untaint, @path, 1
+
+    self
+  end
+
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # :call-seq:
+  #   gem(name)
+  #   gem(name, *requirements)
+  #   gem(name, *requirements, options)
+  #
+  # Specifies a gem dependency with the given +name+ and +requirements+.  You
+  # may also supply +options+ following the +requirements+
+  #
+  # +options+ include:
+  #
+  # require: ::
+  #   RubyGems does not provide any autorequire features so requires in a gem
+  #   dependencies file are recorded but ignored.
+  #
+  #   In bundler the require: option overrides the file to require during
+  #   Bundler.require.  By default the name of the dependency is required in
+  #   Bundler.  A single file or an Array of files may be given.
+  #
+  #   To disable requiring any file give +false+:
+  #
+  #     gem 'rake', require: false
+  #
+  # group: ::
+  #   Place the dependencies in the given dependency group.  A single group or
+  #   an Array of groups may be given.
+  #
+  #   See also #group
+  #
+  # platform: ::
+  #   Only install the dependency on the given platform.  A single platform or
+  #   an Array of platforms may be given.
+  #
+  #   See #platform for a list of platforms available.
+  #
+  # path: ::
+  #   Install this dependency from an unpacked gem in the given directory.
+  #
+  #     gem 'modified_gem', path: 'vendor/modified_gem'
+  #
+  # git: ::
+  #   Install this dependency from a git repository:
+  #
+  #     gem 'private_gem', git: git@my.company.example:private_gem.git'
+  #
+  # gist: ::
+  #   Install this dependency from the gist ID:
+  #
+  #     gem 'bang', gist: '1232884'
+  #
+  # github: ::
+  #   Install this dependency from a github git repository:
+  #
+  #     gem 'private_gem', github: 'my_company/private_gem'
+  #
+  # submodules: ::
+  #   Set to +true+ to include submodules when fetching the git repository for
+  #   git:, gist: and github: dependencies.
+  #
+  # ref: ::
+  #   Use the given commit name or SHA for git:, gist: and github:
+  #   dependencies.
+  #
+  # branch: ::
+  #   Use the given branch for git:, gist: and github: dependencies.
+  #
+  # tag: ::
+  #   Use the given tag for git:, gist: and github: dependencies.
+
+  def gem name, *requirements
+    options = requirements.pop if requirements.last.kind_of?(Hash)
+    options ||= {}
+
+    options[:git] = @current_repository if @current_repository
+
+    source_set = false
+
+    source_set ||= gem_path       name, options
+    source_set ||= gem_git        name, options
+    source_set ||= gem_git_source name, options
+
+    duplicate = @dependencies.include? name
+
+    @dependencies[name] =
+      if requirements.empty? and not source_set then
+        Gem::Requirement.default
+      elsif source_set then
+        Gem::Requirement.source_set
+      else
+        Gem::Requirement.create requirements
+      end
+
+    return unless gem_platforms options
+
+    groups = gem_group name, options
+
+    return unless (groups & @without_groups).empty?
+
+    pin_gem_source name, :default unless source_set
+
+    gem_requires name, options
+
+    if duplicate then
+      warn <<-WARNING
+Gem dependencies file #{@path} requires #{name} more than once.
+      WARNING
+    end
+
+    @set.gem name, *requirements
+  end
+
+  ##
+  # Handles the git: option from +options+ for gem +name+.
+  #
+  # Returns +true+ if the path option was handled.
+
+  def gem_git name, options # :nodoc:
+    if gist = options.delete(:gist) then
+      options[:git] = "https://gist.github.com/#{gist}.git"
+    end
+
+    return unless repository = options.delete(:git)
+
+    pin_gem_source name, :git, repository
+
+    reference = nil
+    reference ||= options.delete :ref
+    reference ||= options.delete :branch
+    reference ||= options.delete :tag
+    reference ||= 'master'
+
+    submodules = options.delete :submodules
+
+    @git_set.add_git_gem name, repository, reference, submodules
+
+    true
+  end
+
+  private :gem_git
+
+  ##
+  # Handles a git gem option from +options+ for gem +name+ for a git source
+  # registered through git_source.
+  #
+  # Returns +true+ if the custom source option was handled.
+
+  def gem_git_source name, options # :nodoc:
+    return unless git_source = (@git_sources.keys & options.keys).last
+
+    source_callback = @git_sources[git_source]
+    source_param = options.delete git_source
+
+    git_url = source_callback.call source_param
+
+    options[:git] = git_url
+
+    gem_git name, options
+
+    true
+  end
+
+  private :gem_git_source
+
+  ##
+  # Handles the :group and :groups +options+ for the gem with the given
+  # +name+.
+
+  def gem_group name, options # :nodoc:
+    g = options.delete :group
+    all_groups  = g ? Array(g) : []
+
+    groups = options.delete :groups
+    all_groups |= groups if groups
+
+    all_groups |= @current_groups if @current_groups
+
+    all_groups
   end
 
-  # :category: Bundler Gemfile DSL
+  private :gem_group
+
+  ##
+  # Handles the path: option from +options+ for gem +name+.
+  #
+  # Returns +true+ if the path option was handled.
 
-  def gem name, *reqs
-    # Ignore the opts for now.
-    reqs.pop if reqs.last.kind_of?(Hash)
+  def gem_path name, options # :nodoc:
+    return unless directory = options.delete(:path)
 
-    @set.gem name, *reqs
+    pin_gem_source name, :path, directory
+
+    @vendor_set.add_vendor_gem name, directory
+
+    true
   end
 
-  def group *what
+  private :gem_path
+
+  ##
+  # Handles the platforms: option from +options+.  Returns true if the
+  # platform matches the current platform.
+
+  def gem_platforms options # :nodoc:
+    platform_names = Array(options.delete :platform)
+    platform_names.concat Array(options.delete :platforms)
+    platform_names.concat @current_platforms if @current_platforms
+
+    return true if platform_names.empty?
+
+    platform_names.any? do |platform_name|
+      raise ArgumentError, "unknown platform #{platform_name.inspect}" unless
+        platform = PLATFORM_MAP[platform_name]
+
+      next false unless Gem::Platform.match platform
+
+      if engines = ENGINE_MAP[platform_name] then
+        next false unless engines.include? Gem.ruby_engine
+      end
+
+      case WINDOWS[platform_name]
+      when :only then
+        next false unless Gem.win_platform?
+      when :never then
+        next false if Gem.win_platform?
+      end
+
+      VERSION_MAP[platform_name].satisfied_by? Gem.ruby_version
+    end
   end
 
-  def platform what
-    if what == :ruby
-      yield
+  private :gem_platforms
+
+  ##
+  # Records the require: option from +options+ and adds those files, or the
+  # default file to the require list for +name+.
+
+  def gem_requires name, options # :nodoc:
+    if options.include? :require then
+      if requires = options.delete(:require) then
+        @requires[name].concat Array requires
+      end
+    else
+      @requires[name] << name
+    end
+  end
+
+  private :gem_requires
+
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Block form for specifying gems from a git +repository+.
+  #
+  #   git 'https://github.com/rails/rails.git' do
+  #     gem 'activesupport'
+  #     gem 'activerecord'
+  #   end
+
+  def git repository
+    @current_repository = repository
+
+    yield
+
+  ensure
+    @current_repository = nil
+  end
+
+  ##
+  # Defines a custom git source that uses +name+ to expand git repositories
+  # for use in gems built from git repositories.  You must provide a block
+  # that accepts a git repository name for expansion.
+
+  def git_source name, &callback
+    @git_sources[name] = callback
+  end
+
+  ##
+  # Returns the basename of the file the dependencies were loaded from
+
+  def gem_deps_file # :nodoc:
+    File.basename @path
+  end
+
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Loads dependencies from a gemspec file.
+  #
+  # +options+ include:
+  #
+  # name: ::
+  #   The name portion of the gemspec file.  Defaults to searching for any
+  #   gemspec file in the current directory.
+  #
+  #     gemspec name: 'my_gem'
+  #
+  # path: ::
+  #   The path the gemspec lives in.  Defaults to the current directory:
+  #
+  #     gemspec 'my_gem', path: 'gemspecs', name: 'my_gem'
+  #
+  # development_group: ::
+  #   The group to add development dependencies to.  By default this is
+  #   :development.  Only one group may be specified.
+
+  def gemspec options = {}
+    name              = options.delete(:name) || '{,*}'
+    path              = options.delete(:path) || '.'
+    development_group = options.delete(:development_group) || :development
+
+    spec = find_gemspec name, path
+
+    groups = gem_group spec.name, {}
+
+    self_dep = Gem::Dependency.new spec.name, spec.version
+
+    add_dependencies groups, [self_dep]
+    add_dependencies groups, spec.runtime_dependencies
+
+    @dependencies[spec.name] = Gem::Requirement.source_set
+
+    spec.dependencies.each do |dep|
+      @dependencies[dep.name] = dep.requirement
     end
+
+    groups << development_group
+
+    add_dependencies groups, spec.development_dependencies
+
+    gem_requires spec.name, options
   end
 
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Block form for placing a dependency in the given +groups+.
+  #
+  #   group :development do
+  #     gem 'debugger'
+  #   end
+  #
+  #   group :development, :test do
+  #     gem 'minitest'
+  #   end
+  #
+  # Groups can be excluded at install time using `gem install -g --without
+  # development`.  See `gem help install` and `gem help gem_dependencies` for
+  # further details.
+
+  def group *groups
+    @current_groups = groups
+
+    yield
+
+  ensure
+    @current_groups = nil
+  end
+
+  ##
+  # Pins the gem +name+ to the given +source+.  Adding a gem with the same
+  # name from a different +source+ will raise an exception.
+
+  def pin_gem_source name, type = :default, source = nil
+    source_description =
+      case type
+      when :default then '(default)'
+      when :path    then "path: #{source}"
+      when :git     then "git: #{source}"
+      else               '(unknown)'
+      end
+
+    raise ArgumentError,
+      "duplicate source #{source_description} for gem #{name}" if
+        @gem_sources.fetch(name, source) != source
+
+    @gem_sources[name] = source
+  end
+
+  private :pin_gem_source
+
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Block form for restricting gems to a set of platforms.
+  #
+  # The gem dependencies platform is different from Gem::Platform.  A platform
+  # gem.deps.rb platform matches on the ruby engine, the ruby version and
+  # whether or not windows is allowed.
+  #
+  # :ruby, :ruby_XY ::
+  #   Matches non-windows, non-jruby implementations where X and Y can be used
+  #   to match releases in the 1.8, 1.9, 2.0 or 2.1 series.
+  #
+  # :mri, :mri_XY ::
+  #   Matches non-windows C Ruby (Matz Ruby) or only the 1.8, 1.9, 2.0 or
+  #   2.1 series.
+  #
+  # :mingw, :mingw_XY ::
+  #   Matches 32 bit C Ruby on MinGW or only the 1.8, 1.9, 2.0 or 2.1 series.
+  #
+  # :x64_mingw, :x64_mingw_XY ::
+  #   Matches 64 bit C Ruby on MinGW or only the 1.8, 1.9, 2.0 or 2.1 series.
+  #
+  # :mswin, :mswin_XY ::
+  #   Matches 32 bit C Ruby on Microsoft Windows or only the 1.8, 1.9, 2.0 or
+  #   2.1 series.
+  #
+  # :mswin64, :mswin64_XY ::
+  #   Matches 64 bit C Ruby on Microsoft Windows or only the 1.8, 1.9, 2.0 or
+  #   2.1 series.
+  #
+  # :jruby, :jruby_XY ::
+  #   Matches JRuby or JRuby in 1.8 or 1.9 mode.
+  #
+  # :maglev ::
+  #   Matches Maglev
+  #
+  # :rbx ::
+  #   Matches non-windows Rubinius
+  #
+  # NOTE:  There is inconsistency in what environment a platform matches.  You
+  # may need to read the source to know the exact details.
+
+  def platform *platforms
+    @current_platforms = platforms
+
+    yield
+
+  ensure
+    @current_platforms = nil
+  end
+
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Block form for restricting gems to a particular set of platforms.  See
+  # #platform.
+
   alias :platforms :platform
 
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Restricts this gem dependencies file to the given ruby +version+.
+  #
+  # You may also provide +engine:+ and +engine_version:+ options to restrict
+  # this gem dependencies file to a particular ruby engine and its engine
+  # version.  This matching is performed by using the RUBY_ENGINE and
+  # engine_specific VERSION constants.  (For JRuby, JRUBY_VERSION).
+
+  def ruby version, options = {}
+    engine         = options[:engine]
+    engine_version = options[:engine_version]
+
+    raise ArgumentError,
+          'you must specify engine_version along with the ruby engine' if
+            engine and not engine_version
+
+    return true if @installing
+
+    unless RUBY_VERSION == version then
+      message = "Your Ruby version is #{RUBY_VERSION}, " +
+                "but your #{gem_deps_file} requires #{version}"
+
+      raise Gem::RubyVersionMismatch, message
+    end
+
+    if engine and engine != Gem.ruby_engine then
+      message = "Your ruby engine is #{Gem.ruby_engine}, " +
+                "but your #{gem_deps_file} requires #{engine}"
+
+      raise Gem::RubyVersionMismatch, message
+    end
+
+    if engine_version then
+      my_engine_version = Object.const_get "#{Gem.ruby_engine.upcase}_VERSION"
+
+      if engine_version != my_engine_version then
+        message =
+          "Your ruby engine version is #{Gem.ruby_engine} #{my_engine_version}, " +
+          "but your #{gem_deps_file} requires #{engine} #{engine_version}"
+
+        raise Gem::RubyVersionMismatch, message
+      end
+    end
+
+    return true
+  end
+
+  ##
+  # :category: Gem Dependencies DSL
+  #
+  # Sets +url+ as a source for gems for this dependency API.  RubyGems uses
+  # the default configured sources if no source was given.  If a source is set
+  # only that source is used.
+  #
+  # This method differs in behavior from Bundler:
+  #
+  # * The +:gemcutter+, # +:rubygems+ and +:rubyforge+ sources are not
+  #   supported as they are deprecated in bundler.
+  # * The +prepend:+ option is not supported.  If you wish to order sources
+  #   then list them in your preferred order.
+
   def source url
+    Gem.sources.clear if @default_sources
+
+    @default_sources = false
+
+    Gem.sources << url
   end
 
+  # TODO: remove this typo name at RubyGems 3.0
+
+  Gem::RequestSet::GemDepedencyAPI = self # :nodoc:
+
 end
 
diff --git a/jruby/lib/ruby/shared/rubygems/request_set/lockfile.rb b/jruby/lib/ruby/shared/rubygems/request_set/lockfile.rb
new file mode 100644
index 0000000..3c54785
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/request_set/lockfile.rb
@@ -0,0 +1,238 @@
+##
+# Parses a gem.deps.rb.lock file and constructs a LockSet containing the
+# dependencies found inside.  If the lock file is missing no LockSet is
+# constructed.
+
+class Gem::RequestSet::Lockfile
+  ##
+  # Raised when a lockfile cannot be parsed
+
+  class ParseError < Gem::Exception
+
+    ##
+    # The column where the error was encountered
+
+    attr_reader :column
+
+    ##
+    # The line where the error was encountered
+
+    attr_reader :line
+
+    ##
+    # The location of the lock file
+
+    attr_reader :path
+
+    ##
+    # Raises a ParseError with the given +message+ which was encountered at a
+    # +line+ and +column+ while parsing.
+
+    def initialize message, column, line, path
+      @line   = line
+      @column = column
+      @path   = path
+      super "#{message} (at line #{line} column #{column})"
+    end
+  end
+
+  ##
+  # Creates a new Lockfile for the given +request_set+ and +gem_deps_file+
+  # location.
+
+  def self.build request_set, gem_deps_file, dependencies = nil
+    request_set.resolve
+    dependencies ||= requests_to_deps request_set.sorted_requests
+    new request_set, gem_deps_file, dependencies
+  end
+
+  def self.requests_to_deps requests # :nodoc:
+    deps = {}
+
+    requests.each do |request|
+      spec        = request.spec
+      name        = request.name
+      requirement = request.request.dependency.requirement
+
+      deps[name] = if [Gem::Resolver::VendorSpecification,
+                       Gem::Resolver::GitSpecification].include? spec.class then
+                     Gem::Requirement.source_set
+                   else
+                     requirement
+                   end
+    end
+
+    deps
+  end
+
+  ##
+  # The platforms for this Lockfile
+
+  attr_reader :platforms
+
+  def initialize request_set, gem_deps_file, dependencies
+    @set           = request_set
+    @dependencies  = dependencies
+    @gem_deps_file = File.expand_path(gem_deps_file)
+    @gem_deps_dir  = File.dirname(@gem_deps_file)
+
+    @gem_deps_file.untaint unless gem_deps_file.tainted?
+
+    @platforms      = []
+  end
+
+  def add_DEPENDENCIES out # :nodoc:
+    out << "DEPENDENCIES"
+
+    out.concat @dependencies.sort_by { |name,| name }.map { |name, requirement|
+      "  #{name}#{requirement.for_lockfile}"
+    }
+
+    out << nil
+  end
+
+  def add_GEM out, spec_groups # :nodoc:
+    return if spec_groups.empty?
+
+    source_groups = spec_groups.values.flatten.group_by do |request|
+      request.spec.source.uri
+    end
+
+    source_groups.sort_by { |group,| group.to_s }.map do |group, requests|
+      out << "GEM"
+      out << "  remote: #{group}"
+      out << "  specs:"
+
+      requests.sort_by { |request| request.name }.each do |request|
+        next if request.spec.name == 'bundler'
+        platform = "-#{request.spec.platform}" unless
+          Gem::Platform::RUBY == request.spec.platform
+
+        out << "    #{request.name} (#{request.version}#{platform})"
+
+        request.full_spec.dependencies.sort.each do |dependency|
+          next if dependency.type == :development
+
+          requirement = dependency.requirement
+          out << "      #{dependency.name}#{requirement.for_lockfile}"
+        end
+      end
+      out << nil
+    end
+  end
+
+  def add_GIT out, git_requests
+    return if git_requests.empty?
+
+    by_repository_revision = git_requests.group_by do |request|
+      source = request.spec.source
+      [source.repository, source.rev_parse]
+    end
+
+    out << "GIT"
+    by_repository_revision.each do |(repository, revision), requests|
+      out << "  remote: #{repository}"
+      out << "  revision: #{revision}"
+      out << "  specs:"
+
+      requests.sort_by { |request| request.name }.each do |request|
+        out << "    #{request.name} (#{request.version})"
+
+        dependencies = request.spec.dependencies.sort_by { |dep| dep.name }
+        dependencies.each do |dep|
+          out << "      #{dep.name}#{dep.requirement.for_lockfile}"
+        end
+      end
+    end
+
+    out << nil
+  end
+
+  def relative_path_from dest, base # :nodoc:
+    dest = File.expand_path(dest)
+    base = File.expand_path(base)
+
+    if dest.index(base) == 0 then
+      offset = dest[base.size+1..-1]
+
+      return '.' unless offset
+
+      offset
+    else
+      dest
+    end
+  end
+
+  def add_PATH out, path_requests # :nodoc:
+    return if path_requests.empty?
+
+    out << "PATH"
+    path_requests.each do |request|
+      directory = File.expand_path(request.spec.source.uri)
+
+      out << "  remote: #{relative_path_from directory, @gem_deps_dir}"
+      out << "  specs:"
+      out << "    #{request.name} (#{request.version})"
+    end
+
+    out << nil
+  end
+
+  def add_PLATFORMS out # :nodoc:
+    out << "PLATFORMS"
+
+    platforms = requests.map { |request| request.spec.platform }.uniq
+
+    platforms = platforms.sort_by { |platform| platform.to_s }
+
+    platforms.sort.each do |platform|
+      out << "  #{platform}"
+    end
+
+    out << nil
+  end
+
+  def spec_groups
+    requests.group_by { |request| request.spec.class }
+  end
+
+  ##
+  # The contents of the lock file.
+
+  def to_s
+    out = []
+
+    groups = spec_groups
+
+    add_PATH out, groups.delete(Gem::Resolver::VendorSpecification) { [] }
+
+    add_GIT out, groups.delete(Gem::Resolver::GitSpecification) { [] }
+
+    add_GEM out, groups
+
+    add_PLATFORMS out
+
+    add_DEPENDENCIES out
+
+    out.join "\n"
+  end
+
+  ##
+  # Writes the lock file alongside the gem dependencies file
+
+  def write
+    content = to_s
+
+    open "#{@gem_deps_file}.lock", 'w' do |io|
+      io.write content
+    end
+  end
+
+  private
+
+  def requests
+    @set.sorted_requests
+  end
+end
+
+require 'rubygems/request_set/lockfile/tokenizer'
diff --git a/jruby/lib/ruby/shared/rubygems/request_set/lockfile/parser.rb b/jruby/lib/ruby/shared/rubygems/request_set/lockfile/parser.rb
new file mode 100644
index 0000000..7778b7a
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/request_set/lockfile/parser.rb
@@ -0,0 +1,334 @@
+class Gem::RequestSet::Lockfile::Parser
+  ###
+  # Parses lockfiles
+
+  def initialize tokenizer, set, platforms, filename = nil
+    @tokens    = tokenizer
+    @filename  = filename
+    @set       = set
+    @platforms = platforms
+  end
+
+  def parse
+    until @tokens.empty? do
+      type, data, column, line = get
+
+      case type
+      when :section then
+        @tokens.skip :newline
+
+        case data
+        when 'DEPENDENCIES' then
+          parse_DEPENDENCIES
+        when 'GIT' then
+          parse_GIT
+        when 'GEM' then
+          parse_GEM
+        when 'PATH' then
+          parse_PATH
+        when 'PLATFORMS' then
+          parse_PLATFORMS
+        else
+          type, = get until @tokens.empty? or peek.first == :section
+        end
+      else
+        raise "BUG: unhandled token #{type} (#{data.inspect}) at line #{line} column #{column}"
+      end
+    end
+  end
+
+  ##
+  # Gets the next token for a Lockfile
+
+  def get expected_types = nil, expected_value = nil # :nodoc:
+    current_token = @tokens.shift
+
+    type, value, column, line = current_token
+
+    if expected_types and not Array(expected_types).include? type then
+      unget current_token
+
+      message = "unexpected token [#{type.inspect}, #{value.inspect}], " +
+                "expected #{expected_types.inspect}"
+
+      raise Gem::RequestSet::Lockfile::ParseError.new message, column, line, @filename
+    end
+
+    if expected_value and expected_value != value then
+      unget current_token
+
+      message = "unexpected token [#{type.inspect}, #{value.inspect}], " +
+                "expected [#{expected_types.inspect}, " +
+                "#{expected_value.inspect}]"
+
+      raise Gem::RequestSet::Lockfile::ParseError.new message, column, line, @filename
+    end
+
+    current_token
+  end
+
+  def parse_DEPENDENCIES # :nodoc:
+    while not @tokens.empty? and :text == peek.first do
+      _, name, = get :text
+
+      requirements = []
+
+      case peek[0]
+      when :bang then
+        get :bang
+
+        requirements << pinned_requirement(name)
+      when :l_paren then
+        get :l_paren
+
+        loop do
+          _, op,      = get :requirement
+          _, version, = get :text
+
+          requirements << "#{op} #{version}"
+
+          break unless peek[0] == :comma
+
+          get :comma
+        end
+
+        get :r_paren
+
+        if peek[0] == :bang then
+          requirements.clear
+          requirements << pinned_requirement(name)
+
+          get :bang
+        end
+      end
+
+      @set.gem name, *requirements
+
+      skip :newline
+    end
+  end
+
+  def parse_GEM # :nodoc:
+    sources = []
+
+    while [:entry, 'remote'] == peek.first(2) do
+      get :entry, 'remote'
+      _, data, = get :text
+      skip :newline
+
+      sources << Gem::Source.new(data)
+    end
+
+    sources << Gem::Source.new(Gem::DEFAULT_HOST) if sources.empty?
+
+    get :entry, 'specs'
+
+    skip :newline
+
+    set = Gem::Resolver::LockSet.new sources
+    last_specs = nil
+
+    while not @tokens.empty? and :text == peek.first do
+      _, name, column, = get :text
+
+      case peek[0]
+      when :newline then
+        last_specs.each do |spec|
+          spec.add_dependency Gem::Dependency.new name if column == 6
+        end
+      when :l_paren then
+        get :l_paren
+
+        type, data, = get [:text, :requirement]
+
+        if type == :text and column == 4 then
+          version, platform = data.split '-', 2
+
+          platform =
+            platform ? Gem::Platform.new(platform) : Gem::Platform::RUBY
+
+          last_specs = set.add name, version, platform
+        else
+          dependency = parse_dependency name, data
+
+          last_specs.each do |spec|
+            spec.add_dependency dependency
+          end
+        end
+
+        get :r_paren
+      else
+        raise "BUG: unknown token #{peek}"
+      end
+
+      skip :newline
+    end
+
+    @set.sets << set
+  end
+
+  def parse_GIT # :nodoc:
+    get :entry, 'remote'
+    _, repository, = get :text
+
+    skip :newline
+
+    get :entry, 'revision'
+    _, revision, = get :text
+
+    skip :newline
+
+    type, value = peek.first 2
+    if type == :entry and %w[branch ref tag].include? value then
+      get
+      get :text
+
+      skip :newline
+    end
+
+    get :entry, 'specs'
+
+    skip :newline
+
+    set = Gem::Resolver::GitSet.new
+    set.root_dir = @set.install_dir
+
+    last_spec = nil
+
+    while not @tokens.empty? and :text == peek.first do
+      _, name, column, = get :text
+
+      case peek[0]
+      when :newline then
+        last_spec.add_dependency Gem::Dependency.new name if column == 6
+      when :l_paren then
+        get :l_paren
+
+        type, data, = get [:text, :requirement]
+
+        if type == :text and column == 4 then
+          last_spec = set.add_git_spec name, data, repository, revision, true
+        else
+          dependency = parse_dependency name, data
+
+          last_spec.add_dependency dependency
+        end
+
+        get :r_paren
+      else
+        raise "BUG: unknown token #{peek}"
+      end
+
+      skip :newline
+    end
+
+    @set.sets << set
+  end
+
+  def parse_PATH # :nodoc:
+    get :entry, 'remote'
+    _, directory, = get :text
+
+    skip :newline
+
+    get :entry, 'specs'
+
+    skip :newline
+
+    set = Gem::Resolver::VendorSet.new
+    last_spec = nil
+
+    while not @tokens.empty? and :text == peek.first do
+      _, name, column, = get :text
+
+      case peek[0]
+      when :newline then
+        last_spec.add_dependency Gem::Dependency.new name if column == 6
+      when :l_paren then
+        get :l_paren
+
+        type, data, = get [:text, :requirement]
+
+        if type == :text and column == 4 then
+          last_spec = set.add_vendor_gem name, directory
+        else
+          dependency = parse_dependency name, data
+
+          last_spec.dependencies << dependency
+        end
+
+        get :r_paren
+      else
+        raise "BUG: unknown token #{peek}"
+      end
+
+      skip :newline
+    end
+
+    @set.sets << set
+  end
+
+  def parse_PLATFORMS # :nodoc:
+    while not @tokens.empty? and :text == peek.first do
+      _, name, = get :text
+
+      @platforms << name
+
+      skip :newline
+    end
+  end
+
+  ##
+  # Parses the requirements following the dependency +name+ and the +op+ for
+  # the first token of the requirements and returns a Gem::Dependency object.
+
+  def parse_dependency name, op # :nodoc:
+    return Gem::Dependency.new name, op unless peek[0] == :text
+
+    _, version, = get :text
+
+    requirements = ["#{op} #{version}"]
+
+    while peek[0] == :comma do
+      get :comma
+      _, op,      = get :requirement
+      _, version, = get :text
+
+      requirements << "#{op} #{version}"
+    end
+
+    Gem::Dependency.new name, requirements
+  end
+
+  private
+
+  def skip type # :nodoc:
+    @tokens.skip type
+  end
+
+  ##
+  # Peeks at the next token for Lockfile
+
+  def peek # :nodoc:
+    @tokens.peek
+  end
+
+  def pinned_requirement name # :nodoc:
+    spec = @set.sets.select { |set|
+      Gem::Resolver::GitSet    === set or
+        Gem::Resolver::VendorSet === set
+    }.map { |set|
+      set.specs[name]
+    }.compact.first
+
+    spec.version
+  end
+
+  ##
+  # Ungets the last token retrieved by #get
+
+  def unget token # :nodoc:
+    @tokens.unshift token
+  end
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/request_set/lockfile/tokenizer.rb b/jruby/lib/ruby/shared/rubygems/request_set/lockfile/tokenizer.rb
new file mode 100644
index 0000000..73c9a83
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/request_set/lockfile/tokenizer.rb
@@ -0,0 +1,108 @@
+require 'strscan'
+require 'rubygems/request_set/lockfile/parser'
+
+class Gem::RequestSet::Lockfile::Tokenizer
+  def self.from_file file
+    new File.read(file), file
+  end
+
+  def initialize input, filename = nil, line = 0, pos = 0
+    @line     = line
+    @line_pos = pos
+    @tokens   = []
+    @filename = filename
+    tokenize input
+  end
+
+  def make_parser set, platforms
+    Gem::RequestSet::Lockfile::Parser.new self, set, platforms, @filename
+  end
+
+  def to_a
+    @tokens
+  end
+
+  def skip type
+    @tokens.shift while not @tokens.empty? and peek.first == type
+  end
+
+  ##
+  # Calculates the column (by byte) and the line of the current token based on
+  # +byte_offset+.
+
+  def token_pos byte_offset # :nodoc:
+    [byte_offset - @line_pos, @line]
+  end
+
+  def empty?
+    @tokens.empty?
+  end
+
+  def unshift token
+    @tokens.unshift token
+  end
+
+  def next_token
+    @tokens.shift
+  end
+  alias :shift :next_token
+
+  def peek
+    @tokens.first || [:EOF]
+  end
+
+  private
+
+  def tokenize input
+    s = StringScanner.new input
+
+    until s.eos? do
+      pos = s.pos
+
+      pos = s.pos if leading_whitespace = s.scan(/ +/)
+
+      if s.scan(/[<|=>]{7}/) then
+        message = "your #{@filename} contains merge conflict markers"
+        column, line = token_pos pos
+
+        raise Gem::RequestSet::Lockfile::ParseError.new message, column, line, @filename
+      end
+
+      @tokens <<
+        case
+        when s.scan(/\r?\n/) then
+          token = [:newline, nil, *token_pos(pos)]
+          @line_pos = s.pos
+          @line += 1
+          token
+        when s.scan(/[A-Z]+/) then
+          if leading_whitespace then
+            text = s.matched
+            text += s.scan(/[^\s)]*/).to_s # in case of no match
+            [:text, text, *token_pos(pos)]
+          else
+            [:section, s.matched, *token_pos(pos)]
+          end
+        when s.scan(/([a-z]+):\s/) then
+          s.pos -= 1 # rewind for possible newline
+          [:entry, s[1], *token_pos(pos)]
+        when s.scan(/\(/) then
+          [:l_paren, nil, *token_pos(pos)]
+        when s.scan(/\)/) then
+          [:r_paren, nil, *token_pos(pos)]
+        when s.scan(/<=|>=|=|~>|<|>|!=/) then
+          [:requirement, s.matched, *token_pos(pos)]
+        when s.scan(/,/) then
+          [:comma, nil, *token_pos(pos)]
+        when s.scan(/!/) then
+          [:bang, nil, *token_pos(pos)]
+        when s.scan(/[^\s),!]*/) then
+          [:text, s.matched, *token_pos(pos)]
+        else
+          raise "BUG: can't create token for: #{s.string[s.pos..-1].inspect}"
+        end
+    end
+
+    @tokens
+  end
+end
diff --git a/jruby/lib/ruby/shared/rubygems/requirement.rb b/jruby/lib/ruby/shared/rubygems/requirement.rb
index ed76892..572bf96 100644
--- a/jruby/lib/ruby/shared/rubygems/requirement.rb
+++ b/jruby/lib/ruby/shared/rubygems/requirement.rb
@@ -1,13 +1,3 @@
-##
-# A Requirement is a set of one or more version restrictions. It supports a
-# few (<tt>=, !=, >, <, >=, <=, ~></tt>) different restriction operators.
-
-# REFACTOR: The fact that a requirement is singular or plural is kind of
-# awkward. Is Requirement the right name for this? Or should it be one
-# [op, number] pair, and we call the list of requirements something else?
-# Since a Requirement is held by a Dependency, maybe this should be made
-# singular and the list aspect should be pulled up into Dependency?
-
 require "rubygems/version"
 require "rubygems/deprecate"
 
@@ -15,6 +5,13 @@ require "rubygems/deprecate"
 # load our yaml + workarounds now.
 Gem.load_yaml if defined? ::YAML
 
+##
+# A Requirement is a set of one or more version restrictions. It supports a
+# few (<tt>=, !=, >, <, >=, <=, ~></tt>) different restriction operators.
+#
+# See Gem::Version for a description on how versions and requirements work
+# together in RubyGems.
+
 class Gem::Requirement
   OPS = { #:nodoc:
     "="  =>  lambda { |v, r| v == r },
@@ -26,12 +23,24 @@ class Gem::Requirement
     "~>" =>  lambda { |v, r| v >= r && v.release < r.bump }
   }
 
+  SOURCE_SET_REQUIREMENT = Struct.new(:for_lockfile).new "!" # :nodoc:
+
   quoted  = OPS.keys.map { |k| Regexp.quote k }.join "|"
-  PATTERN_RAW = "\\s*(#{quoted})?\\s*(#{Gem::Version::VERSION_PATTERN})\\s*"
+  PATTERN_RAW = "\\s*(#{quoted})?\\s*(#{Gem::Version::VERSION_PATTERN})\\s*" # :nodoc:
+
+  ##
+  # A regular expression that matches a requirement
+
   PATTERN = /\A#{PATTERN_RAW}\z/
 
+  ##
+  # The default requirement matches any version
+
   DefaultRequirement = [">=", Gem::Version.new(0)]
 
+  ##
+  # Raised when a bad requirement is encountered
+
   class BadRequirementError < ArgumentError; end
 
   ##
@@ -41,15 +50,14 @@ class Gem::Requirement
   # If the input is "weird", the default version requirement is
   # returned.
 
-  # REFACTOR: There's no reason that this can't be unified with .new.
-  # .new is the standard Ruby factory method.
-
   def self.create input
     case input
     when Gem::Requirement then
       input
     when Gem::Version, Array then
       new input
+    when '!' then
+      source_set
     else
       if input.respond_to? :to_str then
         new [input.to_str]
@@ -66,6 +74,13 @@ class Gem::Requirement
     new '>= 0'
   end
 
+  ###
+  # A source set requirement, used for Gemfiles and lockfiles
+
+  def self.source_set # :nodoc:
+    SOURCE_SET_REQUIREMENT
+  end
+
   ##
   # Parse +obj+, returning an <tt>[op, version]</tt> pair. +obj+ can
   # be a String or a Gem::Version.
@@ -78,11 +93,6 @@ class Gem::Requirement
   #     parse("1.0")                   # => ["=", "1.0"]
   #     parse(Gem::Version.new("1.0")) # => ["=,  "1.0"]
 
-  # REFACTOR: Little two element arrays like this have no real semantic
-  # value. I'd love to see something like this:
-  # Constraint = Struct.new(:operator, :version); (or similar)
-  # and have a Requirement be a list of Constraints.
-
   def self.parse obj
     return ["=", obj] if Gem::Version === obj
 
@@ -122,9 +132,35 @@ class Gem::Requirement
   end
 
   ##
+  # Concatenates the +new+ requirements onto this requirement.
+
+  def concat new
+    new = new.flatten
+    new.compact!
+    new.uniq!
+    new = new.map { |r| self.class.parse r }
+
+    @requirements.concat new
+  end
+
+  ##
+  # Formats this requirement for use in a Gem::RequestSet::Lockfile.
+
+  def for_lockfile # :nodoc:
+    return if [DefaultRequirement] == @requirements
+
+    list = requirements.sort_by { |_, version|
+      version
+    }.map { |op, version|
+      "#{op} #{version}"
+    }.uniq
+
+    " (#{list.join ', '})"
+  end
+
+  ##
   # true if this gem has no requirements.
 
-  # FIX: maybe this should be using #default ?
   def none?
     if @requirements.size == 1
       @requirements[0] == DefaultRequirement
@@ -133,12 +169,20 @@ class Gem::Requirement
     end
   end
 
+  ##
+  # true if the requirement is for only an exact version
+
+  def exact?
+    return false unless @requirements.size == 1
+    @requirements[0][0] == "="
+  end
+
   def as_list # :nodoc:
     requirements.map { |op, version| "#{op} #{version}" }.sort
   end
 
   def hash # :nodoc:
-    requirements.hash
+    requirements.sort.hash
   end
 
   def marshal_dump # :nodoc:
@@ -166,11 +210,11 @@ class Gem::Requirement
     yaml_initialize coder.tag, coder.map
   end
 
-  def to_yaml_properties
+  def to_yaml_properties # :nodoc:
     ["@requirements"]
   end
 
-  def encode_with(coder)
+  def encode_with coder # :nodoc:
     coder.add 'requirements', @requirements
   end
 
@@ -214,15 +258,13 @@ class Gem::Requirement
     as_list.join ", "
   end
 
-  # DOC: this should probably be :nodoc'd
-  def == other
+  def == other # :nodoc:
     Gem::Requirement === other and to_s == other.to_s
   end
 
   private
 
-  # DOC: this should probably be :nodoc'd
-  def fix_syck_default_key_in_requirements
+  def fix_syck_default_key_in_requirements # :nodoc:
     Gem.load_yaml
 
     # Fixup the Syck DefaultKey bug
@@ -234,9 +276,9 @@ class Gem::Requirement
   end
 end
 
-# This is needed for compatibility with older yaml
-# gemspecs.
-
 class Gem::Version
-  Requirement = Gem::Requirement
+  # This is needed for compatibility with older yaml
+  # gemspecs.
+
+  Requirement = Gem::Requirement # :nodoc:
 end
diff --git a/jruby/lib/ruby/shared/rubygems/resolver.rb b/jruby/lib/ruby/shared/rubygems/resolver.rb
new file mode 100644
index 0000000..ef17d68
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver.rb
@@ -0,0 +1,485 @@
+require 'rubygems/dependency'
+require 'rubygems/exceptions'
+require 'rubygems/util/list'
+
+require 'uri'
+require 'net/http'
+
+##
+# Given a set of Gem::Dependency objects as +needed+ and a way to query the
+# set of available specs via +set+, calculates a set of ActivationRequest
+# objects which indicate all the specs that should be activated to meet the
+# all the requirements.
+
+class Gem::Resolver
+
+  ##
+  # If the DEBUG_RESOLVER environment variable is set then debugging mode is
+  # enabled for the resolver.  This will display information about the state
+  # of the resolver while a set of dependencies is being resolved.
+
+  DEBUG_RESOLVER = !ENV['DEBUG_RESOLVER'].nil?
+
+  require 'pp' if DEBUG_RESOLVER
+
+  ##
+  # Contains all the conflicts encountered while doing resolution
+
+  attr_reader :conflicts
+
+  ##
+  # Set to true if all development dependencies should be considered.
+
+  attr_accessor :development
+
+  ##
+  # Set to true if immediate development dependencies should be considered.
+
+  attr_accessor :development_shallow
+
+  ##
+  # When true, no dependencies are looked up for requested gems.
+
+  attr_accessor :ignore_dependencies
+
+  ##
+  # List of dependencies that could not be found in the configured sources.
+
+  attr_reader :missing
+
+  attr_reader :stats
+
+  ##
+  # Hash of gems to skip resolution.  Keyed by gem name, with arrays of
+  # gem specifications as values.
+
+  attr_accessor :skip_gems
+
+  ##
+  # When a missing dependency, don't stop. Just go on and record what was
+  # missing.
+
+  attr_accessor :soft_missing
+
+  ##
+  # Combines +sets+ into a ComposedSet that allows specification lookup in a
+  # uniform manner.  If one of the +sets+ is itself a ComposedSet its sets are
+  # flattened into the result ComposedSet.
+
+  def self.compose_sets *sets
+    sets.compact!
+
+    sets = sets.map do |set|
+      case set
+      when Gem::Resolver::BestSet then
+        set
+      when Gem::Resolver::ComposedSet then
+        set.sets
+      else
+        set
+      end
+    end.flatten
+
+    case sets.length
+    when 0 then
+      raise ArgumentError, 'one set in the composition must be non-nil'
+    when 1 then
+      sets.first
+    else
+      Gem::Resolver::ComposedSet.new(*sets)
+    end
+  end
+
+  ##
+  # Creates a Resolver that queries only against the already installed gems
+  # for the +needed+ dependencies.
+
+  def self.for_current_gems needed
+    new needed, Gem::Resolver::CurrentSet.new
+  end
+
+  ##
+  # Create Resolver object which will resolve the tree starting
+  # with +needed+ Dependency objects.
+  #
+  # +set+ is an object that provides where to look for specifications to
+  # satisfy the Dependencies. This defaults to IndexSet, which will query
+  # rubygems.org.
+
+  def initialize needed, set = nil
+    @set = set || Gem::Resolver::IndexSet.new
+    @needed = needed
+
+    @conflicts           = []
+    @development         = false
+    @development_shallow = false
+    @ignore_dependencies = false
+    @missing             = []
+    @skip_gems           = {}
+    @soft_missing        = false
+    @stats               = Gem::Resolver::Stats.new
+  end
+
+  def explain stage, *data # :nodoc:
+    return unless DEBUG_RESOLVER
+
+    d = data.map { |x| x.pretty_inspect }.join(", ")
+    $stderr.printf "%10s %s\n", stage.to_s.upcase, d
+  end
+
+  def explain_list stage # :nodoc:
+    return unless DEBUG_RESOLVER
+
+    data = yield
+    $stderr.printf "%10s (%d entries)\n", stage.to_s.upcase, data.size
+    PP.pp data, $stderr unless data.empty?
+  end
+
+  ##
+  # Creates an ActivationRequest for the given +dep+ and the last +possible+
+  # specification.
+  #
+  # Returns the Specification and the ActivationRequest
+
+  def activation_request dep, possible # :nodoc:
+    spec = possible.pop
+
+    explain :activate, [spec.full_name, possible.size]
+    explain :possible, possible
+
+    activation_request =
+      Gem::Resolver::ActivationRequest.new spec, dep, possible
+
+    return spec, activation_request
+  end
+
+  def requests s, act, reqs=nil # :nodoc:
+    return reqs if @ignore_dependencies
+
+    s.fetch_development_dependencies if @development
+
+    s.dependencies.reverse_each do |d|
+      next if d.type == :development and not @development
+      next if d.type == :development and @development_shallow and
+              act.development?
+      next if d.type == :development and @development_shallow and
+              act.parent
+
+      reqs.add Gem::Resolver::DependencyRequest.new(d, act)
+      @stats.requirement!
+    end
+
+    @set.prefetch reqs
+
+    @stats.record_requirements reqs
+
+    reqs
+  end
+
+  ##
+  # Proceed with resolution! Returns an array of ActivationRequest objects.
+
+  def resolve
+    @conflicts = []
+
+    needed = Gem::Resolver::RequirementList.new
+
+    @needed.reverse_each do |n|
+      request = Gem::Resolver::DependencyRequest.new n, nil
+
+      needed.add request
+      @stats.requirement!
+    end
+
+    @stats.record_requirements needed
+
+    res = resolve_for needed, nil
+
+    raise Gem::DependencyResolutionError, res if
+      res.kind_of? Gem::Resolver::Conflict
+
+    res.to_a
+  end
+
+  ##
+  # Extracts the specifications that may be able to fulfill +dependency+ and
+  # returns those that match the local platform and all those that match.
+
+  def find_possible dependency # :nodoc:
+    all = @set.find_all dependency
+
+    if (skip_dep_gems = skip_gems[dependency.name]) && !skip_dep_gems.empty?
+      matching = all.select do |api_spec|
+        skip_dep_gems.any? { |s| api_spec.version == s.version }
+      end
+
+      all = matching unless matching.empty?
+    end
+
+    matching_platform = select_local_platforms all
+
+    return matching_platform, all
+  end
+
+  def handle_conflict(dep, existing) # :nodoc:
+    # There is a conflict! We return the conflict object which will be seen by
+    # the caller and be handled at the right level.
+
+    # If the existing activation indicates that there are other possibles for
+    # it, then issue the conflict on the dependency for the activation itself.
+    # Otherwise, if there was a requester, issue it on the requester's
+    # request itself.
+    # Finally, if the existing request has no requester (toplevel) unwind to
+    # it anyway.
+
+    if existing.others_possible?
+      conflict =
+        Gem::Resolver::Conflict.new dep, existing
+    elsif dep.requester
+      depreq = dep.requester.request
+      conflict =
+        Gem::Resolver::Conflict.new depreq, existing, dep
+    elsif existing.request.requester.nil?
+      conflict =
+        Gem::Resolver::Conflict.new dep, existing
+    else
+      raise Gem::DependencyError, "Unable to figure out how to unwind conflict"
+    end
+
+    @conflicts << conflict unless @conflicts.include? conflict
+
+    return conflict
+  end
+
+  # Contains the state for attempting activation of a set of possible specs.
+  # +needed+ is a Gem::List of DependencyRequest objects that, well, need
+  # to be satisfied.
+  # +specs+ is the List of ActivationRequest that are being tested.
+  # +dep+ is the DependencyRequest that was used to generate this state.
+  # +spec+ is the Specification for this state.
+  # +possible+ is List of DependencyRequest objects that can be tried to
+  # find a  complete set.
+  # +conflicts+ is a [DependencyRequest, Conflict] hit tried to
+  # activate the state.
+  #
+  State = Struct.new(:needed, :specs, :dep, :spec, :possibles, :conflicts) do
+    def summary # :nodoc:
+      nd = needed.map { |s| s.to_s }.sort if nd
+
+      if specs then
+        ss = specs.map { |s| s.full_name }.sort
+        ss.unshift ss.length
+      end
+
+      d = dep.to_s
+      d << " from #{dep.requester.full_name}" if dep.requester
+
+      ps = possibles.map { |p| p.full_name }.sort
+      ps.unshift ps.length
+
+      cs = conflicts.map do |(s, c)|
+        [s.full_name, c.conflicting_dependencies.map { |cd| cd.to_s }]
+      end
+
+      { :needed => nd, :specs => ss, :dep => d, :spec => spec.full_name,
+        :possibles => ps, :conflicts => cs }
+    end
+  end
+
+  ##
+  # The meat of the algorithm. Given +needed+ DependencyRequest objects and
+  # +specs+ being a list to ActivationRequest, calculate a new list of
+  # ActivationRequest objects.
+
+  def resolve_for needed, specs # :nodoc:
+    # The State objects that are used to attempt the activation tree.
+    states = []
+
+    while !needed.empty?
+      @stats.iteration!
+
+      dep = needed.remove
+      explain :try, [dep, dep.requester ? dep.requester.request : :toplevel]
+      explain_list(:next5) { needed.next5 }
+      explain_list(:specs) { Array(specs).map { |x| x.full_name }.sort }
+
+      # If there is already a spec activated for the requested name...
+      if specs && existing = specs.find { |s| dep.name == s.name }
+        # then we're done since this new dep matches the existing spec.
+        next if dep.matches_spec? existing
+
+        conflict = handle_conflict dep, existing
+
+        return conflict unless dep.requester
+
+        explain :conflict, dep, :existing, existing.full_name
+
+        depreq = dep.requester.request
+
+        state = nil
+        until states.empty?
+          x = states.pop
+
+          i = existing.request.requester
+          explain :consider, x.spec.full_name, [depreq.name, dep.name, i ? i.name : :top]
+
+          if x.spec.name == depreq.name or
+              x.spec.name == dep.name or
+              (i && (i.name == x.spec.name))
+            explain :found, x.spec.full_name
+            state = x
+            break
+          end
+        end
+
+        return conflict unless state
+
+        @stats.backtracking!
+
+        needed, specs = resolve_for_conflict needed, specs, state
+
+        states << state unless state.possibles.empty?
+
+        next
+      end
+
+      matching, all = find_possible dep
+
+      case matching.size
+      when 0
+        resolve_for_zero dep, all
+      when 1
+        needed, specs =
+          resolve_for_single needed, specs, dep, matching
+      else
+        needed, specs =
+          resolve_for_multiple needed, specs, states, dep, matching
+      end
+    end
+
+    specs
+  end
+
+  ##
+  # Rewinds +needed+ and +specs+ to a previous state in +state+ for a conflict
+  # between +dep+ and +existing+.
+
+  def resolve_for_conflict needed, specs, state # :nodoc:
+    # We exhausted the possibles so it's definitely not going to work out,
+    # bail out.
+    raise Gem::ImpossibleDependenciesError.new state.dep, state.conflicts if
+      state.possibles.empty?
+
+    # Retry resolution with this spec and add it's dependencies
+    spec, act = activation_request state.dep, state.possibles
+
+    needed = requests spec, act, state.needed.dup
+    specs = Gem::List.prepend state.specs, act
+
+    return needed, specs
+  end
+
+  ##
+  # There are multiple +possible+ specifications for this +dep+.  Updates
+  # +needed+, +specs+ and +states+ for further resolution of the +possible+
+  # choices.
+
+  def resolve_for_multiple needed, specs, states, dep, possible # :nodoc:
+    # Sort them so that we try the highest versions first.
+    possible = possible.sort_by do |s|
+      [s.source, s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
+    end
+
+    spec, act = activation_request dep, possible
+
+    # We may need to try all of +possible+, so we setup state to unwind back
+    # to current +needed+ and +specs+ so we can try another. This is code is
+    # what makes conflict resolution possible.
+    states << State.new(needed.dup, specs, dep, spec, possible, [])
+
+    @stats.record_depth states
+
+    explain :states, states.map { |s| s.dep }
+
+    needed = requests spec, act, needed
+    specs = Gem::List.prepend specs, act
+
+    return needed, specs
+  end
+
+  ##
+  # Add the spec from the +possible+ list to +specs+ and process the spec's
+  # dependencies by adding them to +needed+.
+
+  def resolve_for_single needed, specs, dep, possible # :nodoc:
+    spec, act = activation_request dep, possible
+
+    specs = Gem::List.prepend specs, act
+
+    # Put the deps for at the beginning of needed
+    # rather than the end to match the depth first
+    # searching done by the multiple case code below.
+    #
+    # This keeps the error messages consistent.
+    needed = requests spec, act, needed
+
+    return needed, specs
+  end
+
+  ##
+  # When there are no possible specifications for +dep+ our work is done.
+
+  def resolve_for_zero dep, platform_mismatch # :nodoc:
+    @missing << dep
+
+    unless @soft_missing
+      exc = Gem::UnsatisfiableDependencyError.new dep, platform_mismatch
+      exc.errors = @set.errors
+
+      raise exc
+    end
+  end
+
+  ##
+  # Returns the gems in +specs+ that match the local platform.
+
+  def select_local_platforms specs # :nodoc:
+    specs.select do |spec|
+      Gem::Platform.installable? spec
+    end
+  end
+
+end
+
+##
+# TODO remove in RubyGems 3
+
+Gem::DependencyResolver = Gem::Resolver # :nodoc:
+
+require 'rubygems/resolver/activation_request'
+require 'rubygems/resolver/conflict'
+require 'rubygems/resolver/dependency_request'
+require 'rubygems/resolver/requirement_list'
+require 'rubygems/resolver/stats'
+
+require 'rubygems/resolver/set'
+require 'rubygems/resolver/api_set'
+require 'rubygems/resolver/composed_set'
+require 'rubygems/resolver/best_set'
+require 'rubygems/resolver/current_set'
+require 'rubygems/resolver/git_set'
+require 'rubygems/resolver/index_set'
+require 'rubygems/resolver/installer_set'
+require 'rubygems/resolver/lock_set'
+require 'rubygems/resolver/vendor_set'
+
+require 'rubygems/resolver/specification'
+require 'rubygems/resolver/spec_specification'
+require 'rubygems/resolver/api_specification'
+require 'rubygems/resolver/git_specification'
+require 'rubygems/resolver/index_specification'
+require 'rubygems/resolver/installed_specification'
+require 'rubygems/resolver/local_specification'
+require 'rubygems/resolver/lock_specification'
+require 'rubygems/resolver/vendor_specification'
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/activation_request.rb b/jruby/lib/ruby/shared/rubygems/resolver/activation_request.rb
new file mode 100644
index 0000000..56c6363
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/activation_request.rb
@@ -0,0 +1,172 @@
+##
+# Specifies a Specification object that should be activated.  Also contains a
+# dependency that was used to introduce this activation.
+
+class Gem::Resolver::ActivationRequest
+
+  ##
+  # The parent request for this activation request.
+
+  attr_reader :request
+
+  ##
+  # The specification to be activated.
+
+  attr_reader :spec
+
+  ##
+  # Creates a new ActivationRequest that will activate +spec+.  The parent
+  # +request+ is used to provide diagnostics in case of conflicts.
+  #
+  # +others_possible+ indicates that other specifications may also match this
+  # activation request.
+
+  def initialize spec, request, others_possible = true
+    @spec = spec
+    @request = request
+    @others_possible = others_possible
+  end
+
+  def == other # :nodoc:
+    case other
+    when Gem::Specification
+      @spec == other
+    when Gem::Resolver::ActivationRequest
+      @spec == other.spec && @request == other.request
+    else
+      false
+    end
+  end
+
+  ##
+  # Is this activation request for a development dependency?
+
+  def development?
+    @request.development?
+  end
+
+  ##
+  # Downloads a gem at +path+ and returns the file path.
+
+  def download path
+    if @spec.respond_to? :source
+      source = @spec.source
+    else
+      source = Gem.sources.first
+    end
+
+    Gem.ensure_gem_subdirectories path
+
+    source.download full_spec, path
+  end
+
+  ##
+  # The full name of the specification to be activated.
+
+  def full_name
+    @spec.full_name
+  end
+
+  ##
+  # The Gem::Specification for this activation request.
+
+  def full_spec
+    Gem::Specification === @spec ? @spec : @spec.spec
+  end
+
+  def inspect # :nodoc:
+    others =
+      case @others_possible
+      when true then # TODO remove at RubyGems 3
+        ' (others possible)'
+      when false then # TODO remove at RubyGems 3
+        nil
+      else
+        unless @others_possible.empty? then
+          others = @others_possible.map { |s| s.full_name }
+          " (others possible: #{others.join ', '})"
+        end
+      end
+
+    '#<%s for %p from %s%s>' % [
+      self.class, @spec, @request, others
+    ]
+  end
+
+  ##
+  # True if the requested gem has already been installed.
+
+  def installed?
+    case @spec
+    when Gem::Resolver::VendorSpecification then
+      true
+    else
+      this_spec = full_spec
+
+      Gem::Specification.any? do |s|
+        s == this_spec
+      end
+    end
+  end
+
+  ##
+  # The name of this activation request's specification
+
+  def name
+    @spec.name
+  end
+
+  ##
+  # Indicate if this activation is one of a set of possible
+  # requests for the same Dependency request.
+
+  def others_possible?
+    case @others_possible
+    when true, false then
+      @others_possible
+    else
+      not @others_possible.empty?
+    end
+  end
+
+  ##
+  # Return the ActivationRequest that contained the dependency
+  # that we were activated for.
+
+  def parent
+    @request.requester
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Activation request', ']' do
+      q.breakable
+      q.pp @spec
+
+      q.breakable
+      q.text ' for '
+      q.pp @request
+
+      case @others_possible
+      when false then
+      when true then
+        q.breakable
+        q.text 'others possible'
+      else
+        unless @others_possible.empty? then
+          q.breakable
+          q.text 'others '
+          q.pp @others_possible.map { |s| s.full_name }
+        end
+      end
+    end
+  end
+
+  ##
+  # The version of this activation request's specification
+
+  def version
+    @spec.version
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/api_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/api_set.rb
new file mode 100644
index 0000000..17d602f
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/api_set.rb
@@ -0,0 +1,125 @@
+##
+# The global rubygems pool, available via the rubygems.org API.
+# Returns instances of APISpecification.
+
+class Gem::Resolver::APISet < Gem::Resolver::Set
+
+  ##
+  # The URI for the dependency API this APISet uses.
+
+  attr_reader :dep_uri # :nodoc:
+
+  ##
+  # The Gem::Source that gems are fetched from
+
+  attr_reader :source
+
+  ##
+  # The corresponding place to fetch gems.
+
+  attr_reader :uri
+
+  ##
+  # Creates a new APISet that will retrieve gems from +uri+ using the RubyGems
+  # API URL +dep_uri+ which is described at
+  # http://guides.rubygems.org/rubygems-org-api
+
+  def initialize dep_uri = 'https://rubygems.org/api/v1/dependencies'
+    super()
+
+    dep_uri = URI dep_uri unless URI === dep_uri # for ruby 1.8
+
+    @dep_uri = dep_uri
+    @uri     = dep_uri + '../..'
+
+    @data   = Hash.new { |h,k| h[k] = [] }
+    @source = Gem::Source.new @uri
+
+    @to_fetch = []
+  end
+
+  ##
+  # Return an array of APISpecification objects matching
+  # DependencyRequest +req+.
+
+  def find_all req
+    res = []
+
+    return res unless @remote
+
+    if @to_fetch.include?(req.name)
+      prefetch_now
+    end
+
+    versions(req.name).each do |ver|
+      if req.dependency.match? req.name, ver[:number]
+        res << Gem::Resolver::APISpecification.new(self, ver)
+      end
+    end
+
+    res
+  end
+
+  ##
+  # A hint run by the resolver to allow the Set to fetch
+  # data for DependencyRequests +reqs+.
+
+  def prefetch reqs
+    return unless @remote
+    names = reqs.map { |r| r.dependency.name }
+    needed = names - @data.keys - @to_fetch
+
+    @to_fetch += needed
+  end
+
+  def prefetch_now # :nodoc:
+    needed, @to_fetch = @to_fetch, []
+
+    uri = @dep_uri + "?gems=#{needed.sort.join ','}"
+    str = Gem::RemoteFetcher.fetcher.fetch_path uri
+
+    loaded = []
+
+    Marshal.load(str).each do |ver|
+      name = ver[:name]
+
+      @data[name] << ver
+      loaded << name
+    end
+
+    (needed - loaded).each do |missing|
+      @data[missing] = []
+    end
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[APISet', ']' do
+      q.breakable
+      q.text "URI: #{@dep_uri}"
+
+      q.breakable
+      q.text 'gem names:'
+      q.pp @data.keys
+    end
+  end
+
+  ##
+  # Return data for all versions of the gem +name+.
+
+  def versions name # :nodoc:
+    if @data.key?(name)
+      return @data[name]
+    end
+
+    uri = @dep_uri + "?gems=#{name}"
+    str = Gem::RemoteFetcher.fetcher.fetch_path uri
+
+    Marshal.load(str).each do |ver|
+      @data[ver[:name]] << ver
+    end
+
+    @data[name]
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/api_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/api_specification.rb
new file mode 100644
index 0000000..4960e66
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/api_specification.rb
@@ -0,0 +1,85 @@
+##
+# Represents a specification retrieved via the rubygems.org API.
+#
+# This is used to avoid loading the full Specification object when all we need
+# is the name, version, and dependencies.
+
+class Gem::Resolver::APISpecification < Gem::Resolver::Specification
+
+  ##
+  # Creates an APISpecification for the given +set+ from the rubygems.org
+  # +api_data+.
+  #
+  # See http://guides.rubygems.org/rubygems-org-api/#misc_methods for the
+  # format of the +api_data+.
+
+  def initialize(set, api_data)
+    super()
+
+    @set = set
+    @name = api_data[:name]
+    @version = Gem::Version.new api_data[:number]
+    @platform = Gem::Platform.new api_data[:platform]
+    @dependencies = api_data[:dependencies].map do |name, ver|
+      Gem::Dependency.new name, ver.split(/\s*,\s*/)
+    end
+  end
+
+  def == other # :nodoc:
+    self.class === other and
+      @set          == other.set and
+      @name         == other.name and
+      @version      == other.version and
+      @platform     == other.platform and
+      @dependencies == other.dependencies
+  end
+
+  def fetch_development_dependencies # :nodoc:
+    spec = source.fetch_spec Gem::NameTuple.new @name, @version, @platform
+
+    @dependencies = spec.dependencies
+  end
+
+  def installable_platform? # :nodoc:
+    Gem::Platform.match @platform
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[APISpecification', ']' do
+      q.breakable
+      q.text "name: #{name}"
+
+      q.breakable
+      q.text "version: #{version}"
+
+      q.breakable
+      q.text "platform: #{platform}"
+
+      q.breakable
+      q.text 'dependencies:'
+      q.breakable
+      q.pp @dependencies
+
+      q.breakable
+      q.text "set uri: #{@set.dep_uri}"
+    end
+  end
+
+  ##
+  # Fetches a Gem::Specification for this APISpecification.
+
+  def spec # :nodoc:
+    @spec ||=
+      begin
+        tuple = Gem::NameTuple.new @name, @version, @platform
+
+        source.fetch_spec tuple
+      end
+  end
+
+  def source # :nodoc:
+    @set.source
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/best_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/best_set.rb
new file mode 100644
index 0000000..7e2d7e2
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/best_set.rb
@@ -0,0 +1,78 @@
+##
+# The BestSet chooses the best available method to query a remote index.
+#
+# It combines IndexSet and APISet
+
+class Gem::Resolver::BestSet < Gem::Resolver::ComposedSet
+
+  ##
+  # Creates a BestSet for the given +sources+ or Gem::sources if none are
+  # specified.  +sources+ must be a Gem::SourceList.
+
+  def initialize sources = Gem.sources
+    super()
+
+    @sources = sources
+  end
+
+  ##
+  # Picks which sets to use for the configured sources.
+
+  def pick_sets # :nodoc:
+    @sources.each_source do |source|
+      @sets << source.dependency_resolver_set
+    end
+  end
+
+  def find_all req # :nodoc:
+    pick_sets if @remote and @sets.empty?
+
+    super
+  rescue Gem::RemoteFetcher::FetchError => e
+    replace_failed_api_set e
+
+    retry
+  end
+
+  def prefetch reqs # :nodoc:
+    pick_sets if @remote and @sets.empty?
+
+    super
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[BestSet', ']' do
+      q.breakable
+      q.text 'sets:'
+
+      q.breakable
+      q.pp @sets
+    end
+  end
+
+  ##
+  # Replaces a failed APISet for the URI in +error+ with an IndexSet.
+  #
+  # If no matching APISet can be found the original +error+ is raised.
+  #
+  # The calling method must retry the exception to repeat the lookup.
+
+  def replace_failed_api_set error # :nodoc:
+    uri = error.uri
+    uri = URI uri unless URI === uri
+    uri.query = nil
+
+    raise error unless api_set = @sets.find { |set|
+      Gem::Resolver::APISet === set and set.dep_uri == uri
+    }
+
+    index_set = Gem::Resolver::IndexSet.new api_set.source
+
+    @sets.map! do |set|
+      next set unless set == api_set
+      index_set
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/composed_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/composed_set.rb
new file mode 100644
index 0000000..5b08f12
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/composed_set.rb
@@ -0,0 +1,66 @@
+##
+# A ComposedSet allows multiple sets to be queried like a single set.
+#
+# To create a composed set with any number of sets use:
+#
+#   Gem::Resolver.compose_sets set1, set2
+#
+# This method will eliminate nesting of composed sets.
+
+class Gem::Resolver::ComposedSet < Gem::Resolver::Set
+
+  attr_reader :sets # :nodoc:
+
+  ##
+  # Creates a new ComposedSet containing +sets+.  Use
+  # Gem::Resolver::compose_sets instead.
+
+  def initialize *sets
+    super()
+
+    @sets = sets
+  end
+
+  ##
+  # When +allow_prerelease+ is set to +true+ prereleases gems are allowed to
+  # match dependencies.
+
+  def prerelease= allow_prerelease
+    super
+
+    sets.each do |set|
+      set.prerelease = allow_prerelease
+    end
+  end
+
+  ##
+  # Sets the remote network access for all composed sets.
+
+  def remote= remote
+    super
+
+    @sets.each { |set| set.remote = remote }
+  end
+
+  def errors
+    @errors + @sets.map { |set| set.errors }.flatten
+  end
+
+  ##
+  # Finds all specs matching +req+ in all sets.
+
+  def find_all req
+    @sets.map do |s|
+      s.find_all req
+    end.flatten
+  end
+
+  ##
+  # Prefetches +reqs+ in all sets.
+
+  def prefetch reqs
+    @sets.each { |s| s.prefetch(reqs) }
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/conflict.rb b/jruby/lib/ruby/shared/rubygems/resolver/conflict.rb
new file mode 100644
index 0000000..902c286
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/conflict.rb
@@ -0,0 +1,160 @@
+##
+# Used internally to indicate that a dependency conflicted
+# with a spec that would be activated.
+
+class Gem::Resolver::Conflict
+
+  ##
+  # The specification that was activated prior to the conflict
+
+  attr_reader :activated
+
+  ##
+  # The dependency that is in conflict with the activated gem.
+
+  attr_reader :dependency
+
+  attr_reader :failed_dep # :nodoc:
+
+  ##
+  # Creates a new resolver conflict when +dependency+ is in conflict with an
+  # already +activated+ specification.
+
+  def initialize(dependency, activated, failed_dep=dependency)
+    @dependency = dependency
+    @activated = activated
+    @failed_dep = failed_dep
+  end
+
+  def == other # :nodoc:
+    self.class === other and
+      @dependency == other.dependency and
+      @activated  == other.activated  and
+      @failed_dep == other.failed_dep
+  end
+
+  ##
+  # A string explanation of the conflict.
+
+  def explain
+    "<Conflict wanted: #{@failed_dep}, had: #{activated.spec.full_name}>"
+  end
+
+  ##
+  # Return the 2 dependency objects that conflicted
+
+  def conflicting_dependencies
+    [@failed_dep.dependency, @activated.request.dependency]
+  end
+
+  ##
+  # Explanation of the conflict used by exceptions to print useful messages
+
+  def explanation
+    activated   = @activated.spec.full_name
+    dependency  = @failed_dep.dependency
+    requirement = dependency.requirement
+    alternates  = dependency.matching_specs.map { |spec| spec.full_name }
+
+    unless alternates.empty? then
+      matching = <<-MATCHING.chomp
+
+  Gems matching %s:
+    %s
+      MATCHING
+
+      matching = matching % [
+        dependency,
+        alternates.join(', '),
+      ]
+    end
+
+    explanation = <<-EXPLANATION
+  Activated %s
+  which does not match conflicting dependency (%s)
+
+  Conflicting dependency chains:
+    %s
+
+  versus:
+    %s
+%s
+    EXPLANATION
+
+    explanation % [
+      activated, requirement,
+      request_path(@activated).reverse.join(", depends on\n    "),
+      request_path(@failed_dep).reverse.join(", depends on\n    "),
+      matching,
+    ]
+  end
+
+  ##
+  # Returns true if the conflicting dependency's name matches +spec+.
+
+  def for_spec?(spec)
+    @dependency.name == spec.name
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Dependency conflict: ', ']' do
+      q.breakable
+
+      q.text 'activated '
+      q.pp @activated
+
+      q.breakable
+      q.text ' dependency '
+      q.pp @dependency
+
+      q.breakable
+      if @dependency == @failed_dep then
+        q.text ' failed'
+      else
+        q.text ' failed dependency '
+        q.pp @failed_dep
+      end
+    end
+  end
+
+  ##
+  # Path of activations from the +current+ list.
+
+  def request_path current
+    path = []
+
+    while current do
+      case current
+      when Gem::Resolver::ActivationRequest then
+        path <<
+          "#{current.request.dependency}, #{current.spec.version} activated"
+
+        current = current.parent
+      when Gem::Resolver::DependencyRequest then
+        path << "#{current.dependency}"
+
+        current = current.requester
+      else
+        raise Gem::Exception, "[BUG] unknown request class #{current.class}"
+      end
+    end
+
+    path = ['user request (gem command or Gemfile)'] if path.empty?
+
+    path
+  end
+
+  ##
+  # Return the Specification that listed the dependency
+
+  def requester
+    @failed_dep.requester
+  end
+
+end
+
+##
+# TODO: Remove in RubyGems 3
+
+Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict # :nodoc:
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/current_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/current_set.rb
new file mode 100644
index 0000000..4e8d340
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/current_set.rb
@@ -0,0 +1,13 @@
+##
+# A set which represents the installed gems. Respects
+# all the normal settings that control where to look
+# for installed gems.
+
+class Gem::Resolver::CurrentSet < Gem::Resolver::Set
+
+  def find_all req
+    req.dependency.matching_specs
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/dependency_request.rb b/jruby/lib/ruby/shared/rubygems/resolver/dependency_request.rb
new file mode 100644
index 0000000..79690be
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/dependency_request.rb
@@ -0,0 +1,116 @@
+##
+# Used Internally. Wraps a Dependency object to also track which spec
+# contained the Dependency.
+
+class Gem::Resolver::DependencyRequest
+
+  ##
+  # The wrapped Gem::Dependency
+
+  attr_reader :dependency
+
+  ##
+  # The request for this dependency.
+
+  attr_reader :requester
+
+  ##
+  # Creates a new DependencyRequest for +dependency+ from +requester+.
+  # +requester may be nil if the request came from a user.
+
+  def initialize dependency, requester
+    @dependency = dependency
+    @requester  = requester
+  end
+
+  def == other # :nodoc:
+    case other
+    when Gem::Dependency
+      @dependency == other
+    when Gem::Resolver::DependencyRequest
+      @dependency == other.dependency && @requester == other.requester
+    else
+      false
+    end
+  end
+
+  ##
+  # Is this dependency a development dependency?
+
+  def development?
+    @dependency.type == :development
+  end
+
+  ##
+  # Does this dependency request match +spec+?
+  #
+  # NOTE:  #match? only matches prerelease versions when #dependency is a
+  # prerelease dependency.
+
+  def match? spec, allow_prerelease = false
+    @dependency.match? spec, nil, allow_prerelease
+  end
+
+  ##
+  # Does this dependency request match +spec+?
+  #
+  # NOTE:  #matches_spec? matches prerelease versions.  See also #match?
+
+  def matches_spec?(spec)
+    @dependency.matches_spec? spec
+  end
+
+  ##
+  # The name of the gem this dependency request is requesting.
+
+  def name
+    @dependency.name
+  end
+
+  ##
+  # Indicate that the request is for a gem explicitly requested by the user
+
+  def explicit?
+    @requester.nil?
+  end
+
+  ##
+  # Indicate that the request is for a gem requested as a dependency of
+  # another gem
+
+  def implicit?
+    !explicit?
+  end
+
+  ##
+  # Return a String indicating who caused this request to be added (only
+  # valid for implicit requests)
+
+  def request_context
+    @requester ? @requester.request : "(unknown)"
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Dependency request ', ']' do
+      q.breakable
+      q.text @dependency.to_s
+
+      q.breakable
+      q.text ' requested by '
+      q.pp @requester
+    end
+  end
+
+  ##
+  # The version requirement for this dependency request
+
+  def requirement
+    @dependency.requirement
+  end
+
+  def to_s # :nodoc:
+    @dependency.to_s
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/git_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/git_set.rb
new file mode 100644
index 0000000..5f1b368
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/git_set.rb
@@ -0,0 +1,122 @@
+##
+# A GitSet represents gems that are sourced from git repositories.
+#
+# This is used for gem dependency file support.
+#
+# Example:
+#
+#   set = Gem::Resolver::GitSet.new
+#   set.add_git_gem 'rake', 'git://example/rake.git', tag: 'rake-10.1.0'
+
+class Gem::Resolver::GitSet < Gem::Resolver::Set
+
+  ##
+  # The root directory for git gems in this set.  This is usually Gem.dir, the
+  # installation directory for regular gems.
+
+  attr_accessor :root_dir
+
+  ##
+  # Contains repositories needing submodules
+
+  attr_reader :need_submodules # :nodoc:
+
+  ##
+  # A Hash containing git gem names for keys and a Hash of repository and
+  # git commit reference as values.
+
+  attr_reader :repositories # :nodoc:
+
+  ##
+  # A hash of gem names to Gem::Resolver::GitSpecifications
+
+  attr_reader :specs # :nodoc:
+
+  def initialize # :nodoc:
+    super()
+
+    @git             = ENV['git'] || 'git'
+    @need_submodules = {}
+    @repositories    = {}
+    @root_dir        = Gem.dir
+    @specs           = {}
+  end
+
+  def add_git_gem name, repository, reference, submodules # :nodoc:
+    @repositories[name] = [repository, reference]
+    @need_submodules[repository] = submodules
+  end
+
+  ##
+  # Adds and returns a GitSpecification with the given +name+ and +version+
+  # which came from a +repository+ at the given +reference+.  If +submodules+
+  # is true they are checked out along with the repository.
+  #
+  # This fills in the prefetch information as enough information about the gem
+  # is present in the arguments.
+
+  def add_git_spec name, version, repository, reference, submodules # :nodoc:
+    add_git_gem name, repository, reference, submodules
+
+    source = Gem::Source::Git.new name, repository, reference
+    source.root_dir = @root_dir
+
+    spec = Gem::Specification.new do |s|
+      s.name    = name
+      s.version = version
+    end
+
+    git_spec = Gem::Resolver::GitSpecification.new self, spec, source
+
+    @specs[spec.name] = git_spec
+
+    git_spec
+  end
+
+  ##
+  # Finds all git gems matching +req+
+
+  def find_all req
+    prefetch nil
+
+    specs.values.select do |spec|
+      req.match? spec
+    end
+  end
+
+  ##
+  # Prefetches specifications from the git repositories in this set.
+
+  def prefetch reqs
+    return unless @specs.empty?
+
+    @repositories.each do |name, (repository, reference)|
+      source = Gem::Source::Git.new name, repository, reference
+      source.root_dir = @root_dir
+      source.remote = @remote
+
+      source.specs.each do |spec|
+        git_spec = Gem::Resolver::GitSpecification.new self, spec, source
+
+        @specs[spec.name] = git_spec
+      end
+    end
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[GitSet', ']' do
+      next if @repositories.empty?
+      q.breakable
+
+      repos = @repositories.map do |name, (repository, reference)|
+        "#{name}: #{repository}@#{reference}"
+      end
+
+      q.seplist repos do |repo|
+        q.text repo
+      end
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/git_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/git_specification.rb
new file mode 100644
index 0000000..55e180e
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/git_specification.rb
@@ -0,0 +1,59 @@
+##
+# A GitSpecification represents a gem that is sourced from a git repository
+# and is being loaded through a gem dependencies file through the +git:+
+# option.
+
+class Gem::Resolver::GitSpecification < Gem::Resolver::SpecSpecification
+
+  def == other # :nodoc:
+    self.class === other and
+      @set  == other.set and
+      @spec == other.spec and
+      @source == other.source
+  end
+
+  def add_dependency dependency # :nodoc:
+    spec.dependencies << dependency
+  end
+
+  ##
+  # Installing a git gem only involves building the extensions and generating
+  # the executables.
+
+  def install options = {}
+    require 'rubygems/installer'
+
+    installer = Gem::Installer.new '', options
+    installer.spec = spec
+
+    yield installer if block_given?
+
+    installer.run_pre_install_hooks
+    installer.build_extensions
+    installer.run_post_build_hooks
+    installer.generate_bin
+    installer.run_post_install_hooks
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[GitSpecification', ']' do
+      q.breakable
+      q.text "name: #{name}"
+
+      q.breakable
+      q.text "version: #{version}"
+
+      q.breakable
+      q.text 'dependencies:'
+      q.breakable
+      q.pp dependencies
+
+      q.breakable
+      q.text "source:"
+      q.breakable
+      q.pp @source
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/index_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/index_set.rb
new file mode 100644
index 0000000..7c56c2b
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/index_set.rb
@@ -0,0 +1,80 @@
+##
+# The global rubygems pool represented via the traditional
+# source index.
+
+class Gem::Resolver::IndexSet < Gem::Resolver::Set
+
+  def initialize source = nil # :nodoc:
+    super()
+
+    @f =
+      if source then
+        sources = Gem::SourceList.from [source]
+
+        Gem::SpecFetcher.new sources
+      else
+        Gem::SpecFetcher.fetcher
+      end
+
+    @all = Hash.new { |h,k| h[k] = [] }
+
+    list, errors = @f.available_specs :complete
+
+    @errors.concat errors
+
+    list.each do |uri, specs|
+      specs.each do |n|
+        @all[n.name] << [uri, n]
+      end
+    end
+
+    @specs = {}
+  end
+
+  ##
+  # Return an array of IndexSpecification objects matching
+  # DependencyRequest +req+.
+
+  def find_all req
+    res = []
+
+    return res unless @remote
+
+    name = req.dependency.name
+
+    @all[name].each do |uri, n|
+      if req.match? n, @prerelease then
+        res << Gem::Resolver::IndexSpecification.new(
+          self, n.name, n.version, uri, n.platform)
+      end
+    end
+
+    res
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[IndexSet', ']' do
+      q.breakable
+      q.text 'sources:'
+      q.breakable
+      q.pp @f.sources
+
+      q.breakable
+      q.text 'specs:'
+
+      q.breakable
+
+      names = @all.values.map do |tuples|
+        tuples.map do |_, tuple|
+          tuple.full_name
+        end
+      end.flatten
+
+      q.seplist names do |name|
+        q.text name
+      end
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/index_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/index_specification.rb
new file mode 100644
index 0000000..56fecb5
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/index_specification.rb
@@ -0,0 +1,69 @@
+##
+# Represents a possible Specification object returned from IndexSet.  Used to
+# delay needed to download full Specification objects when only the +name+
+# and +version+ are needed.
+
+class Gem::Resolver::IndexSpecification < Gem::Resolver::Specification
+
+  ##
+  # An IndexSpecification is created from the index format described in `gem
+  # help generate_index`.
+  #
+  # The +set+ contains other specifications for this (URL) +source+.
+  #
+  # The +name+, +version+ and +platform+ are the name, version and platform of
+  # the gem.
+
+  def initialize set, name, version, source, platform
+    super()
+
+    @set = set
+    @name = name
+    @version = version
+    @source = source
+    @platform = platform.to_s
+
+    @spec = nil
+  end
+
+  ##
+  # The dependencies of the gem for this specification
+
+  def dependencies
+    spec.dependencies
+  end
+
+  def inspect # :nodoc:
+    '#<%s %s source %s>' % [self.class, full_name, @source]
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Index specification', ']' do
+      q.breakable
+      q.text full_name
+
+      unless Gem::Platform::RUBY == @platform then
+        q.breakable
+        q.text @platform.to_s
+      end
+
+      q.breakable
+      q.text 'source '
+      q.pp @source
+    end
+  end
+
+  ##
+  # Fetches a Gem::Specification for this IndexSpecification from the #source.
+
+  def spec # :nodoc:
+    @spec ||=
+      begin
+        tuple = Gem::NameTuple.new @name, @version, @platform
+
+        @source.fetch_spec tuple
+      end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/installed_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/installed_specification.rb
new file mode 100644
index 0000000..2a2b89a
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/installed_specification.rb
@@ -0,0 +1,58 @@
+##
+# An InstalledSpecification represents a gem that is already installed
+# locally.
+
+class Gem::Resolver::InstalledSpecification < Gem::Resolver::SpecSpecification
+
+  def == other # :nodoc:
+    self.class === other and
+      @set  == other.set and
+      @spec == other.spec
+  end
+
+  ##
+  # This is a null install as this specification is already installed.
+  # +options+ are ignored.
+
+  def install options = {}
+    yield nil
+  end
+
+  ##
+  # Returns +true+ if this gem is installable for the current platform.
+
+  def installable_platform?
+    # BACKCOMPAT If the file is coming out of a specified file, then we
+    # ignore the platform. This code can be removed in RG 3.0.
+    return true if @source.kind_of? Gem::Source::SpecificFile
+
+    super
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[InstalledSpecification', ']' do
+      q.breakable
+      q.text "name: #{name}"
+
+      q.breakable
+      q.text "version: #{version}"
+
+      q.breakable
+      q.text "platform: #{platform}"
+
+      q.breakable
+      q.text 'dependencies:'
+      q.breakable
+      q.pp spec.dependencies
+    end
+  end
+
+  ##
+  # The source for this specification
+
+  def source
+    @source ||= Gem::Source::Installed.new
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/installer_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/installer_set.rb
new file mode 100644
index 0000000..a68ff09
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/installer_set.rb
@@ -0,0 +1,224 @@
+##
+# A set of gems for installation sourced from remote sources and local .gem
+# files
+
+class Gem::Resolver::InstallerSet < Gem::Resolver::Set
+
+  ##
+  # List of Gem::Specification objects that must always be installed.
+
+  attr_reader :always_install # :nodoc:
+
+  ##
+  # Only install gems in the always_install list
+
+  attr_accessor :ignore_dependencies # :nodoc:
+
+  ##
+  # Do not look in the installed set when finding specifications.  This is
+  # used by the --install-dir option to `gem install`
+
+  attr_accessor :ignore_installed # :nodoc:
+
+  ##
+  # The remote_set looks up remote gems for installation.
+
+  attr_reader :remote_set # :nodoc:
+
+  ##
+  # Creates a new InstallerSet that will look for gems in +domain+.
+
+  def initialize domain
+    super()
+
+    @domain = domain
+    @remote = consider_remote?
+
+    @f = Gem::SpecFetcher.fetcher
+
+    @always_install      = []
+    @ignore_dependencies = false
+    @ignore_installed    = false
+    @local               = {}
+    @remote_set          = Gem::Resolver::BestSet.new
+    @specs               = {}
+  end
+
+  ##
+  # Looks up the latest specification for +dependency+ and adds it to the
+  # always_install list.
+
+  def add_always_install dependency
+    request = Gem::Resolver::DependencyRequest.new dependency, nil
+
+    found = find_all request
+
+    found.delete_if { |s|
+      s.version.prerelease? and not s.local?
+    } unless dependency.prerelease?
+
+    found = found.select do |s|
+      Gem::Source::SpecificFile === s.source or
+        Gem::Platform::RUBY == s.platform or
+        Gem::Platform.local === s.platform
+    end
+
+    if found.empty? then
+      exc = Gem::UnsatisfiableDependencyError.new request
+      exc.errors = errors
+
+      raise exc
+    end
+
+    newest = found.max_by do |s|
+      [s.version, s.platform == Gem::Platform::RUBY ? -1 : 1]
+    end
+
+    @always_install << newest.spec
+  end
+
+  ##
+  # Adds a local gem requested using +dep_name+ with the given +spec+ that can
+  # be loaded and installed using the +source+.
+
+  def add_local dep_name, spec, source
+    @local[dep_name] = [spec, source]
+  end
+
+  ##
+  # Should local gems should be considered?
+
+  def consider_local? # :nodoc:
+    @domain == :both or @domain == :local
+  end
+
+  ##
+  # Should remote gems should be considered?
+
+  def consider_remote? # :nodoc:
+    @domain == :both or @domain == :remote
+  end
+
+  ##
+  # Errors encountered while resolving gems
+
+  def errors
+    @errors + @remote_set.errors
+  end
+
+  ##
+  # Returns an array of IndexSpecification objects matching DependencyRequest
+  # +req+.
+
+  def find_all req
+    res = []
+
+    dep  = req.dependency
+
+    return res if @ignore_dependencies and
+              @always_install.none? { |spec| dep.match? spec }
+
+    name = dep.name
+
+    dep.matching_specs.each do |gemspec|
+      next if @always_install.any? { |spec| spec.name == gemspec.name }
+
+      res << Gem::Resolver::InstalledSpecification.new(self, gemspec)
+    end unless @ignore_installed
+
+    if consider_local? then
+      matching_local = @local.values.select do |spec, _|
+        req.match? spec
+      end.map do |spec, source|
+        Gem::Resolver::LocalSpecification.new self, spec, source
+      end
+
+      res.concat matching_local
+
+      local_source = Gem::Source::Local.new
+
+      if local_spec = local_source.find_gem(name, dep.requirement) then
+        res << Gem::Resolver::IndexSpecification.new(
+          self, local_spec.name, local_spec.version,
+          local_source, local_spec.platform)
+      end
+    end
+
+    res.delete_if do |spec|
+      spec.version.prerelease? and not dep.prerelease?
+    end
+
+    res.concat @remote_set.find_all req if consider_remote?
+
+    res
+  end
+
+  def prefetch(reqs)
+    @remote_set.prefetch(reqs) if consider_remote?
+  end
+
+  def prerelease= allow_prerelease
+    super
+
+    @remote_set.prerelease = allow_prerelease
+  end
+
+  def inspect # :nodoc:
+    always_install = @always_install.map { |s| s.full_name }
+
+    '#<%s domain: %s specs: %p always install: %p>' % [
+      self.class, @domain, @specs.keys, always_install,
+    ]
+  end
+
+  ##
+  # Called from IndexSpecification to get a true Specification
+  # object.
+
+  def load_spec name, ver, platform, source # :nodoc:
+    key = "#{name}-#{ver}-#{platform}"
+
+    @specs.fetch key do
+      tuple = Gem::NameTuple.new name, ver, platform
+
+      @specs[key] = source.fetch_spec tuple
+    end
+  end
+
+  ##
+  # Has a local gem for +dep_name+ been added to this set?
+
+  def local? dep_name # :nodoc:
+    spec, = @local[dep_name]
+
+    spec
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[InstallerSet', ']' do
+      q.breakable
+      q.text "domain: #{@domain}"
+
+      q.breakable
+      q.text 'specs: '
+      q.pp @specs.keys
+
+      q.breakable
+      q.text 'always install: '
+      q.pp @always_install
+    end
+  end
+
+  def remote= remote # :nodoc:
+    case @domain
+    when :local then
+      @domain = :both if remote
+    when :remote then
+      @domain = nil unless remote
+    when :both then
+      @domain = :local unless remote
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/local_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/local_specification.rb
new file mode 100644
index 0000000..20a283f
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/local_specification.rb
@@ -0,0 +1,41 @@
+##
+# A LocalSpecification comes from a .gem file on the local filesystem.
+
+class Gem::Resolver::LocalSpecification < Gem::Resolver::SpecSpecification
+
+  ##
+  # Returns +true+ if this gem is installable for the current platform.
+
+  def installable_platform?
+    return true if @source.kind_of? Gem::Source::SpecificFile
+
+    super
+  end
+
+  def local? # :nodoc:
+    true
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[LocalSpecification', ']' do
+      q.breakable
+      q.text "name: #{name}"
+
+      q.breakable
+      q.text "version: #{version}"
+
+      q.breakable
+      q.text "platform: #{platform}"
+
+      q.breakable
+      q.text 'dependencies:'
+      q.breakable
+      q.pp dependencies
+
+      q.breakable
+      q.text "source: #{@source.path}"
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/lock_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/lock_set.rb
new file mode 100644
index 0000000..4ede597
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/lock_set.rb
@@ -0,0 +1,84 @@
+##
+# A set of gems from a gem dependencies lockfile.
+
+class Gem::Resolver::LockSet < Gem::Resolver::Set
+
+  attr_reader :specs # :nodoc:
+
+  ##
+  # Creates a new LockSet from the given +sources+
+
+  def initialize sources
+    super()
+
+    @sources = sources.map do |source|
+      Gem::Source::Lock.new source
+    end
+
+    @specs   = []
+  end
+
+  ##
+  # Creates a new IndexSpecification in this set using the given +name+,
+  # +version+ and +platform+.
+  #
+  # The specification's set will be the current set, and the source will be
+  # the current set's source.
+
+  def add name, version, platform # :nodoc:
+    version = Gem::Version.new version
+
+    specs = @sources.map do |source|
+      Gem::Resolver::LockSpecification.new self, name, version, source,
+                                           platform
+    end
+
+    @specs.concat specs
+
+    specs
+  end
+
+  ##
+  # Returns an Array of IndexSpecification objects matching the
+  # DependencyRequest +req+.
+
+  def find_all req
+    @specs.select do |spec|
+      req.match? spec
+    end
+  end
+
+  ##
+  # Loads a Gem::Specification with the given +name+, +version+ and
+  # +platform+.  +source+ is ignored.
+
+  def load_spec name, version, platform, source # :nodoc:
+    dep = Gem::Dependency.new name, version
+
+    found = @specs.find do |spec|
+      dep.matches_spec? spec and spec.platform == platform
+    end
+
+    tuple = Gem::NameTuple.new found.name, found.version, found.platform
+
+    found.source.fetch_spec tuple
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[LockSet', ']' do
+      q.breakable
+      q.text 'source:'
+
+      q.breakable
+      q.pp @source
+
+      q.breakable
+      q.text 'specs:'
+
+      q.breakable
+      q.pp @specs.map { |spec| spec.full_name }
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/lock_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/lock_specification.rb
new file mode 100644
index 0000000..0013171
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/lock_specification.rb
@@ -0,0 +1,84 @@
+##
+# The LockSpecification comes from a lockfile (Gem::RequestSet::Lockfile).
+#
+# A LockSpecification's dependency information is pre-filled from the
+# lockfile.
+
+class Gem::Resolver::LockSpecification < Gem::Resolver::Specification
+
+  def initialize set, name, version, source, platform
+    super()
+
+    @name     = name
+    @platform = platform
+    @set      = set
+    @source   = source
+    @version  = version
+
+    @dependencies = []
+    @spec         = nil
+  end
+
+  ##
+  # This is a null install as a locked specification is considered installed.
+  # +options+ are ignored.
+
+  def install options = {}
+    destination = options[:install_dir] || Gem.dir
+
+    if File.exist? File.join(destination, 'specifications', spec.spec_name) then
+      yield nil
+      return
+    end
+
+    super
+  end
+
+  ##
+  # Adds +dependency+ from the lockfile to this specification
+
+  def add_dependency dependency # :nodoc:
+    @dependencies << dependency
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[LockSpecification', ']' do
+      q.breakable
+      q.text "name: #{@name}"
+
+      q.breakable
+      q.text "version: #{@version}"
+
+      unless @platform == Gem::Platform::RUBY then
+        q.breakable
+        q.text "platform: #{@platform}"
+      end
+
+      unless @dependencies.empty? then
+        q.breakable
+        q.text 'dependencies:'
+        q.breakable
+        q.pp @dependencies
+      end
+    end
+  end
+
+  ##
+  # A specification constructed from the lockfile is returned
+
+  def spec
+    @spec ||= Gem::Specification.find { |spec|
+      spec.name == @name and spec.version == @version
+    }
+
+    @spec ||= Gem::Specification.new do |s|
+      s.name     = @name
+      s.version  = @version
+      s.platform = @platform
+
+      s.dependencies.concat @dependencies
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/requirement_list.rb b/jruby/lib/ruby/shared/rubygems/resolver/requirement_list.rb
new file mode 100644
index 0000000..a6bfaab
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/requirement_list.rb
@@ -0,0 +1,81 @@
+##
+# The RequirementList is used to hold the requirements being considered
+# while resolving a set of gems.
+#
+# The RequirementList acts like a queue where the oldest items are removed
+# first.
+
+class Gem::Resolver::RequirementList
+
+  include Enumerable
+
+  ##
+  # Creates a new RequirementList.
+
+  def initialize
+    @exact = []
+    @list = []
+  end
+
+  def initialize_copy other # :nodoc:
+    @exact = @exact.dup
+    @list = @list.dup
+  end
+
+  ##
+  # Adds Resolver::DependencyRequest +req+ to this requirements list.
+
+  def add(req)
+    if req.requirement.exact?
+      @exact.push req
+    else
+      @list.push req
+    end
+    req
+  end
+
+  ##
+  # Enumerates requirements in the list
+
+  def each # :nodoc:
+    return enum_for __method__ unless block_given?
+
+    @exact.each do |requirement|
+      yield requirement
+    end
+
+    @list.each do |requirement|
+      yield requirement
+    end
+  end
+
+  ##
+  # How many elements are in the list
+
+  def size
+    @exact.size + @list.size
+  end
+
+  ##
+  # Is the list empty?
+
+  def empty?
+    @exact.empty? && @list.empty?
+  end
+
+  ##
+  # Remove the oldest DependencyRequest from the list.
+
+  def remove
+    return @exact.shift unless @exact.empty?
+    @list.shift
+  end
+
+  ##
+  # Returns the oldest five entries from the list.
+
+  def next5
+    x = @exact[0,5]
+    x + @list[0,5 - x.size]
+  end
+end
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/set.rb b/jruby/lib/ruby/shared/rubygems/resolver/set.rb
new file mode 100644
index 0000000..b26dc45
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/set.rb
@@ -0,0 +1,56 @@
+##
+# Resolver sets are used to look up specifications (and their
+# dependencies) used in resolution.  This set is abstract.
+
+class Gem::Resolver::Set
+
+  ##
+  # Set to true to disable network access for this set
+
+  attr_accessor :remote
+
+  ##
+  # Errors encountered when resolving gems
+
+  attr_accessor :errors
+
+  ##
+  # When true, allows matching of requests to prerelease gems.
+
+  attr_accessor :prerelease
+
+  def initialize # :nodoc:
+    @prerelease = false
+    @remote     = true
+    @errors     = []
+  end
+
+  ##
+  # The find_all method must be implemented.  It returns all Resolver
+  # Specification objects matching the given DependencyRequest +req+.
+
+  def find_all req
+    raise NotImplementedError
+  end
+
+  ##
+  # The #prefetch method may be overridden, but this is not necessary.  This
+  # default implementation does nothing, which is suitable for sets where
+  # looking up a specification is cheap (such as installed gems).
+  #
+  # When overridden, the #prefetch method should look up specifications
+  # matching +reqs+.
+
+  def prefetch reqs
+  end
+
+  ##
+  # When true, this set is allowed to access the network when looking up
+  # specifications or dependencies.
+
+  def remote? # :nodoc:
+    @remote
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/spec_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/spec_specification.rb
new file mode 100644
index 0000000..1350e8a
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/spec_specification.rb
@@ -0,0 +1,56 @@
+##
+# The Resolver::SpecSpecification contains common functionality for
+# Resolver specifications that are backed by a Gem::Specification.
+
+class Gem::Resolver::SpecSpecification < Gem::Resolver::Specification
+
+  ##
+  # A SpecSpecification is created for a +set+ for a Gem::Specification in
+  # +spec+.  The +source+ is either where the +spec+ came from, or should be
+  # loaded from.
+
+  def initialize set, spec, source = nil
+    @set    = set
+    @source = source
+    @spec   = spec
+  end
+
+  ##
+  # The dependencies of the gem for this specification
+
+  def dependencies
+    spec.dependencies
+  end
+
+  ##
+  # The name and version of the specification.
+  #
+  # Unlike Gem::Specification#full_name, the platform is not included.
+
+  def full_name
+    "#{spec.name}-#{spec.version}"
+  end
+
+  ##
+  # The name of the gem for this specification
+
+  def name
+    spec.name
+  end
+
+  ##
+  # The platform this gem works on.
+
+  def platform
+    spec.platform
+  end
+
+  ##
+  # The version of the gem for this specification.
+
+  def version
+    spec.version
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/specification.rb
new file mode 100644
index 0000000..4d77293
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/specification.rb
@@ -0,0 +1,110 @@
+##
+# A Resolver::Specification contains a subset of the information
+# contained in a Gem::Specification.  Only the information necessary for
+# dependency resolution in the resolver is included.
+
+class Gem::Resolver::Specification
+
+  ##
+  # The dependencies of the gem for this specification
+
+  attr_reader :dependencies
+
+  ##
+  # The name of the gem for this specification
+
+  attr_reader :name
+
+  ##
+  # The platform this gem works on.
+
+  attr_reader :platform
+
+  ##
+  # The set this specification came from.
+
+  attr_reader :set
+
+  ##
+  # The source for this specification
+
+  attr_reader :source
+
+  ##
+  # The Gem::Specification for this Resolver::Specification.
+  #
+  # Implementers, note that #install updates @spec, so be sure to cache the
+  # Gem::Specification in @spec when overriding.
+
+  attr_reader :spec
+
+  ##
+  # The version of the gem for this specification.
+
+  attr_reader :version
+
+  ##
+  # Sets default instance variables for the specification.
+
+  def initialize
+    @dependencies = nil
+    @name         = nil
+    @platform     = nil
+    @set          = nil
+    @source       = nil
+    @version      = nil
+  end
+
+  ##
+  # Fetches development dependencies if the source does not provide them by
+  # default (see APISpecification).
+
+  def fetch_development_dependencies # :nodoc:
+  end
+
+  ##
+  # The name and version of the specification.
+  #
+  # Unlike Gem::Specification#full_name, the platform is not included.
+
+  def full_name
+    "#{@name}-#{@version}"
+  end
+
+  ##
+  # Installs this specification using the Gem::Installer +options+.  The
+  # install method yields a Gem::Installer instance, which indicates the
+  # gem will be installed, or +nil+, which indicates the gem is already
+  # installed.
+  #
+  # After installation #spec is updated to point to the just-installed
+  # specification.
+
+  def install options = {}
+    require 'rubygems/installer'
+
+    destination = options[:install_dir] || Gem.dir
+
+    Gem.ensure_gem_subdirectories destination
+
+    gem = source.download spec, destination
+
+    installer = Gem::Installer.new gem, options
+
+    yield installer if block_given?
+
+    @spec = installer.install
+  end
+
+  ##
+  # Returns true if this specification is installable on this platform.
+
+  def installable_platform?
+    Gem::Platform.match spec.platform
+  end
+
+  def local? # :nodoc:
+    false
+  end
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/stats.rb b/jruby/lib/ruby/shared/rubygems/resolver/stats.rb
new file mode 100644
index 0000000..c31e5be
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/stats.rb
@@ -0,0 +1,44 @@
+class Gem::Resolver::Stats
+  def initialize
+    @max_depth = 0
+    @max_requirements = 0
+    @requirements = 0
+    @backtracking = 0
+    @iterations = 0
+  end
+
+  def record_depth(stack)
+    if stack.size > @max_depth
+      @max_depth = stack.size
+    end
+  end
+
+  def record_requirements(reqs)
+    if reqs.size > @max_requirements
+      @max_requirements = reqs.size
+    end
+  end
+
+  def requirement!
+    @requirements += 1
+  end
+
+  def backtracking!
+    @backtracking += 1
+  end
+
+  def iteration!
+    @iterations += 1
+  end
+
+  PATTERN = "%20s: %d\n"
+
+  def display
+    $stdout.puts "=== Resolver Statistics ==="
+    $stdout.printf PATTERN, "Max Depth", @max_depth
+    $stdout.printf PATTERN, "Total Requirements", @requirements
+    $stdout.printf PATTERN, "Max Requirements", @max_requirements
+    $stdout.printf PATTERN, "Backtracking #", @backtracking
+    $stdout.printf PATTERN, "Iteration #", @iterations
+  end
+end
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/vendor_set.rb b/jruby/lib/ruby/shared/rubygems/resolver/vendor_set.rb
new file mode 100644
index 0000000..614bd05
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/vendor_set.rb
@@ -0,0 +1,87 @@
+##
+# A VendorSet represents gems that have been unpacked into a specific
+# directory that contains a gemspec.
+#
+# This is used for gem dependency file support.
+#
+# Example:
+#
+#   set = Gem::Resolver::VendorSet.new
+#
+#   set.add_vendor_gem 'rake', 'vendor/rake'
+#
+# The directory vendor/rake must contain an unpacked rake gem along with a
+# rake.gemspec (watching the given name).
+
+class Gem::Resolver::VendorSet < Gem::Resolver::Set
+
+  ##
+  # The specifications for this set.
+
+  attr_reader :specs # :nodoc:
+
+  def initialize # :nodoc:
+    super()
+
+    @directories = {}
+    @specs       = {}
+  end
+
+  ##
+  # Adds a specification to the set with the given +name+ which has been
+  # unpacked into the given +directory+.
+
+  def add_vendor_gem name, directory # :nodoc:
+    gemspec = File.join directory, "#{name}.gemspec"
+
+    spec = Gem::Specification.load gemspec
+
+    raise Gem::GemNotFoundException,
+          "unable to find #{gemspec} for gem #{name}" unless spec
+
+    spec.full_gem_path = File.expand_path directory
+
+    @specs[spec.name]  = spec
+    @directories[spec] = directory
+
+    spec
+  end
+
+  ##
+  # Returns an Array of VendorSpecification objects matching the
+  # DependencyRequest +req+.
+
+  def find_all req
+    @specs.values.select do |spec|
+      req.match? spec
+    end.map do |spec|
+      source = Gem::Source::Vendor.new @directories[spec]
+      Gem::Resolver::VendorSpecification.new self, spec, source
+    end
+  end
+
+  ##
+  # Loads a spec with the given +name+. +version+, +platform+ and +source+ are
+  # ignored.
+
+  def load_spec name, version, platform, source # :nodoc:
+    @specs.fetch name
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[VendorSet', ']' do
+      next if @directories.empty?
+      q.breakable
+
+      dirs = @directories.map do |spec, directory|
+        "#{spec.full_name}: #{directory}"
+      end
+
+      q.seplist dirs do |dir|
+        q.text dir
+      end
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/resolver/vendor_specification.rb b/jruby/lib/ruby/shared/rubygems/resolver/vendor_specification.rb
new file mode 100644
index 0000000..a99b5f3
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/resolver/vendor_specification.rb
@@ -0,0 +1,24 @@
+##
+# A VendorSpecification represents a gem that has been unpacked into a project
+# and is being loaded through a gem dependencies file through the +path:+
+# option.
+
+class Gem::Resolver::VendorSpecification < Gem::Resolver::SpecSpecification
+
+  def == other # :nodoc:
+    self.class === other and
+      @set  == other.set and
+      @spec == other.spec and
+      @source == other.source
+  end
+
+  ##
+  # This is a null install as this gem was unpacked into a directory.
+  # +options+ are ignored.
+
+  def install options = {}
+    yield nil
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/security.rb b/jruby/lib/ruby/shared/rubygems/security.rb
index bfd6fd2..8c5fb7d 100644
--- a/jruby/lib/ruby/shared/rubygems/security.rb
+++ b/jruby/lib/ruby/shared/rubygems/security.rb
@@ -120,11 +120,11 @@ end
 # * HighSecurity - Here's the bugger that got us into this mess.
 #   The HighSecurity policy is identical to the MediumSecurity policy,
 #   except that it does not allow unsigned gems.  A malicious user
-#   doesn't have a whole lot of options here; he can't modify the
-#   package contents without invalidating the signature, and he can't
+#   doesn't have a whole lot of options here; they can't modify the
+#   package contents without invalidating the signature, and they can't
 #   modify or remove signature or the signing certificate chain, or
 #   RubyGems will simply refuse to install the package.  Oh well, maybe
-#   he'll have better luck causing problems for CPAN users instead :).
+#   they'll have better luck causing problems for CPAN users instead :).
 #
 # The reason RubyGems refused to install your shiny new signed gem was because
 # it was from an untrusted source.  Well, your code is infallible (naturally),
diff --git a/jruby/lib/ruby/shared/rubygems/security/policy.rb b/jruby/lib/ruby/shared/rubygems/security/policy.rb
index 7238b2e..b9bcb17 100644
--- a/jruby/lib/ruby/shared/rubygems/security/policy.rb
+++ b/jruby/lib/ruby/shared/rubygems/security/policy.rb
@@ -218,6 +218,7 @@ class Gem::Security::Policy
         # against
       else
         alert_warning "#{full_name} is not signed"
+        return
       end
     end
 
diff --git a/jruby/lib/ruby/shared/rubygems/security/signer.rb b/jruby/lib/ruby/shared/rubygems/security/signer.rb
index bb1eae7..fbee240 100644
--- a/jruby/lib/ruby/shared/rubygems/security/signer.rb
+++ b/jruby/lib/ruby/shared/rubygems/security/signer.rb
@@ -122,7 +122,7 @@ class Gem::Security::Signer
   #   ~/.gem/gem-public_cert.pem.expired.%Y%m%d%H%M%S
   #
   # If the signing certificate can be re-signed the expired certificate will
-  # be saved as ~/.gem/gem-pubilc_cert.pem.expired.%Y%m%d%H%M%S where the
+  # be saved as ~/.gem/gem-public_cert.pem.expired.%Y%m%d%H%M%S where the
   # expiry time (not after) is used for the timestamp.
 
   def re_sign_key # :nodoc:
diff --git a/jruby/lib/ruby/shared/rubygems/security/trust_dir.rb b/jruby/lib/ruby/shared/rubygems/security/trust_dir.rb
index dd51308..76ef89a 100644
--- a/jruby/lib/ruby/shared/rubygems/security/trust_dir.rb
+++ b/jruby/lib/ruby/shared/rubygems/security/trust_dir.rb
@@ -1,10 +1,26 @@
+##
+# The TrustDir manages the trusted certificates for gem signature
+# verification.
+
 class Gem::Security::TrustDir
 
+  ##
+  # Default permissions for the trust directory and its contents
+
   DEFAULT_PERMISSIONS = {
     :trust_dir    => 0700,
     :trusted_cert => 0600,
   }
 
+  ##
+  # The directory where trusted certificates will be stored.
+
+  attr_reader :dir
+
+  ##
+  # Creates a new TrustDir using +dir+ where the directory and file
+  # permissions will be checked according to +permissions+
+
   def initialize dir, permissions = DEFAULT_PERMISSIONS
     @dir = dir
     @permissions = permissions
@@ -12,8 +28,6 @@ class Gem::Security::TrustDir
     @digester = Gem::Security::DIGEST_ALGORITHM
   end
 
-  attr_reader :dir
-
   ##
   # Returns the path to the trusted +certificate+
 
diff --git a/jruby/lib/ruby/shared/rubygems/server.rb b/jruby/lib/ruby/shared/rubygems/server.rb
index 3ca588a..7655be2 100644
--- a/jruby/lib/ruby/shared/rubygems/server.rb
+++ b/jruby/lib/ruby/shared/rubygems/server.rb
@@ -445,7 +445,7 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
     @spec_dirs = @gem_dirs.map { |gem_dir| File.join gem_dir, 'specifications' }
     @spec_dirs.reject! { |spec_dir| !File.directory? spec_dir }
 
-    Gem::Specification.dirs = @gem_dirs
+    reset_gems
 
     @have_rdoc_4_plus = nil
   end
@@ -470,7 +470,7 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
   end
 
   def latest_specs(req, res)
-    Gem::Specification.reset
+    reset_gems
 
     res['content-type'] = 'application/x-gzip'
 
@@ -530,14 +530,44 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
     end
   end
 
+  def prerelease_specs req, res
+    reset_gems
+
+    res['content-type'] = 'application/x-gzip'
+
+    add_date res
+
+    specs = Gem::Specification.select do |spec|
+      spec.version.prerelease?
+    end.sort.map do |spec|
+      platform = spec.original_platform || Gem::Platform::RUBY
+      [spec.name, spec.version, platform]
+    end
+
+    specs = Marshal.dump specs
+
+    if req.path =~ /\.gz$/ then
+      specs = Gem.gzip specs
+      res['content-type'] = 'application/x-gzip'
+    else
+      res['content-type'] = 'application/octet-stream'
+    end
+
+    if req.request_method == 'HEAD' then
+      res['content-length'] = specs.length
+    else
+      res.body << specs
+    end
+  end
+
   def quick(req, res)
-    Gem::Specification.reset
+    reset_gems
 
     res['content-type'] = 'text/plain'
     add_date res
 
     case req.request_uri.path
-    when %r|^/quick/(Marshal.#{Regexp.escape Gem.marshal_version}/)?(.*?)-([0-9.]+)(-.*?)?\.gemspec\.rz$| then
+    when %r|^/quick/(Marshal.#{Regexp.escape Gem.marshal_version}/)?(.*?)-([0-9.]+[^-]*?)(-.*?)?\.gemspec\.rz$| then
       marshal_format, name, version, platform = $1, $2, $3, $4
       specs = Gem::Specification.find_all_by_name name, version
 
@@ -567,7 +597,8 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
   end
 
   def root(req, res)
-    Gem::Specification.reset
+    reset_gems
+
     add_date res
 
     raise WEBrick::HTTPStatus::NotFound, "`#{req.path}' not found." unless
@@ -698,6 +729,13 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
   end
 
   ##
+  # Updates the server to use the latest installed gems.
+
+  def reset_gems # :nodoc:
+    Gem::Specification.dirs = @gem_dirs
+  end
+
+  ##
   # Returns true and prepares http response, if rdoc for the requested gem
   # name pattern was found.
   #
@@ -749,6 +787,11 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
     @server.mount_proc "/latest_specs.#{Gem.marshal_version}.gz",
                        method(:latest_specs)
 
+    @server.mount_proc "/prerelease_specs.#{Gem.marshal_version}",
+                       method(:prerelease_specs)
+    @server.mount_proc "/prerelease_specs.#{Gem.marshal_version}.gz",
+                       method(:prerelease_specs)
+
     @server.mount_proc "/quick/", method(:quick)
 
     @server.mount_proc("/gem-server-rdoc-style.css") do |req, res|
@@ -787,7 +830,7 @@ div.method-source-code pre { color: #ffdead; overflow: hidden; }
   end
 
   def specs(req, res)
-    Gem::Specification.reset
+    reset_gems
 
     add_date res
 
diff --git a/jruby/lib/ruby/shared/rubygems/source.rb b/jruby/lib/ruby/shared/rubygems/source.rb
index f0e2a59..e5995f0 100644
--- a/jruby/lib/ruby/shared/rubygems/source.rb
+++ b/jruby/lib/ruby/shared/rubygems/source.rb
@@ -1,34 +1,62 @@
 require 'uri'
 require 'fileutils'
 
+##
+# A Source knows how to list and fetch gems from a RubyGems marshal index.
+#
+# There are other Source subclasses for installed gems, local gems, the
+# bundler dependency API and so-forth.
+
 class Gem::Source
-  FILES = {
+
+  include Comparable
+
+  FILES = { # :nodoc:
     :released   => 'specs',
     :latest     => 'latest_specs',
     :prerelease => 'prerelease_specs',
   }
 
+  ##
+  # The URI this source will fetch gems from.
+
+  attr_reader :uri
+
+  ##
+  # Creates a new Source which will use the index located at +uri+.
+
   def initialize(uri)
-    unless uri.kind_of? URI
-      uri = URI.parse(uri.to_s)
+    begin
+      unless uri.kind_of? URI
+        uri = URI.parse(uri.to_s)
+      end
+    rescue URI::InvalidURIError
+      raise if Gem::Source == self.class
     end
 
     @uri = uri
     @api_uri = nil
   end
 
-  attr_reader :uri
+  ##
+  # Use an SRV record on the host to look up the true endpoint for the index.
 
-  def api_uri
+  def api_uri # :nodoc:
     require 'rubygems/remote_fetcher'
     @api_uri ||= Gem::RemoteFetcher.fetcher.api_endpoint uri
   end
 
+  ##
+  # Sources are ordered by installation preference.
+
   def <=>(other)
     case other
     when Gem::Source::Installed,
          Gem::Source::Local,
-         Gem::Source::SpecificFile then
+         Gem::Source::Lock,
+         Gem::Source::SpecificFile,
+         Gem::Source::Git,
+         Gem::Source::Vendor then
       -1
     when Gem::Source then
       if !@uri
@@ -44,20 +72,35 @@ class Gem::Source
     end
   end
 
-  include Comparable
+  def == other # :nodoc:
+    self.class === other and @uri == other.uri
+  end
 
-  def ==(other)
-    case other
-    when self.class
-      @uri == other.uri
+  alias_method :eql?, :== # :nodoc:
+
+  ##
+  # Returns a Set that can fetch specifications from this source.
+
+  def dependency_resolver_set # :nodoc:
+    return Gem::Resolver::IndexSet.new self if 'file' == api_uri.scheme
+
+    bundler_api_uri = api_uri + './api/v1/dependencies'
+
+    begin
+      fetcher = Gem::RemoteFetcher.fetcher
+      response = fetcher.fetch_path bundler_api_uri, nil, true
+    rescue Gem::RemoteFetcher::FetchError
+      Gem::Resolver::IndexSet.new self
     else
-      false
+      if response.respond_to? :uri then
+        Gem::Resolver::APISet.new response.uri
+      else
+        Gem::Resolver::APISet.new bundler_api_uri
+      end
     end
   end
 
-  alias_method :eql?, :==
-
-  def hash
+  def hash # :nodoc:
     @uri.hash
   end
 
@@ -67,19 +110,32 @@ class Gem::Source
   def cache_dir(uri)
     # Correct for windows paths
     escaped_path = uri.path.sub(/^\/([a-z]):\//i, '/\\1-/')
+    escaped_path.untaint
+
     File.join Gem.spec_cache_dir, "#{uri.host}%#{uri.port}", File.dirname(escaped_path)
   end
 
+  ##
+  # Returns true when it is possible and safe to update the cache directory.
+
   def update_cache?
-    @update_cache ||= File.stat(Gem.user_home).uid == Process.uid
+    @update_cache ||=
+      begin
+        File.stat(Gem.user_home).uid == Process.uid
+      rescue Errno::ENOENT
+        false
+      end
   end
 
-  def fetch_spec(name)
+  ##
+  # Fetches a specification for the given +name_tuple+.
+
+  def fetch_spec name_tuple
     fetcher = Gem::RemoteFetcher.fetcher
 
-    spec_file_name = name.spec_name
+    spec_file_name = name_tuple.spec_name
 
-    uri = @uri + "#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}"
+    uri = api_uri + "#{Gem::MARSHAL_SPEC_DIR}#{spec_file_name}"
 
     cache_dir = cache_dir uri
 
@@ -123,7 +179,7 @@ class Gem::Source
     file       = FILES[type]
     fetcher    = Gem::RemoteFetcher.fetcher
     file_name  = "#{file}.#{Gem.marshal_version}"
-    spec_path  = @uri + "#{file_name}.gz"
+    spec_path  = api_uri + "#{file_name}.gz"
     cache_dir  = cache_dir spec_path
     local_file = File.join(cache_dir, file_name)
     retried    = false
@@ -145,20 +201,34 @@ class Gem::Source
     end
   end
 
+  ##
+  # Downloads +spec+ and writes it to +dir+.  See also
+  # Gem::RemoteFetcher#download.
+
   def download(spec, dir=Dir.pwd)
     fetcher = Gem::RemoteFetcher.fetcher
-    fetcher.download spec, @uri.to_s, dir
+    fetcher.download spec, api_uri.to_s, dir
   end
 
   def pretty_print q # :nodoc:
     q.group 2, '[Remote:', ']' do
       q.breakable
       q.text @uri.to_s
+
+      if api = api_uri
+        q.breakable
+        q.text 'API URI: '
+        q.text api.to_s
+      end
     end
   end
 
 end
 
+require 'rubygems/source/git'
 require 'rubygems/source/installed'
 require 'rubygems/source/specific_file'
 require 'rubygems/source/local'
+require 'rubygems/source/lock'
+require 'rubygems/source/vendor'
+
diff --git a/jruby/lib/ruby/shared/rubygems/source/git.rb b/jruby/lib/ruby/shared/rubygems/source/git.rb
new file mode 100644
index 0000000..35c2270
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/source/git.rb
@@ -0,0 +1,240 @@
+require 'digest'
+require 'rubygems/util'
+
+##
+# A git gem for use in a gem dependencies file.
+#
+# Example:
+#
+#   source =
+#     Gem::Source::Git.new 'rake', 'git@example:rake.git', 'rake-10.1.0', false
+#
+#   source.specs
+
+class Gem::Source::Git < Gem::Source
+
+  ##
+  # The name of the gem created by this git gem.
+
+  attr_reader :name
+
+  ##
+  # The commit reference used for checking out this git gem.
+
+  attr_reader :reference
+
+  ##
+  # When false the cache for this repository will not be updated.
+
+  attr_accessor :remote
+
+  ##
+  # The git repository this gem is sourced from.
+
+  attr_reader :repository
+
+  ##
+  # The directory for cache and git gem installation
+
+  attr_accessor :root_dir
+
+  ##
+  # Does this repository need submodules checked out too?
+
+  attr_reader :need_submodules
+
+  ##
+  # Creates a new git gem source for a gems from loaded from +repository+ at
+  # the given +reference+.  The +name+ is only used to track the repository
+  # back to a gem dependencies file, it has no real significance as a git
+  # repository may contain multiple gems.  If +submodules+ is true, submodules
+  # will be checked out when the gem is installed.
+
+  def initialize name, repository, reference, submodules = false
+    super repository
+
+    @name            = name
+    @repository      = repository
+    @reference       = reference
+    @need_submodules = submodules
+
+    @remote   = true
+    @root_dir = Gem.dir
+    @git      = ENV['git'] || 'git'
+  end
+
+  def <=> other
+    case other
+    when Gem::Source::Git then
+      0
+    when Gem::Source::Vendor,
+         Gem::Source::Lock then
+      -1
+    when Gem::Source then
+      1
+    else
+      nil
+    end
+  end
+
+  def == other # :nodoc:
+    super and
+      @name            == other.name and
+      @repository      == other.repository and
+      @reference       == other.reference and
+      @need_submodules == other.need_submodules
+  end
+
+  ##
+  # Checks out the files for the repository into the install_dir.
+
+  def checkout # :nodoc:
+    cache
+
+    return false unless File.exist? repo_cache_dir
+
+    unless File.exist? install_dir then
+      system @git, 'clone', '--quiet', '--no-checkout',
+             repo_cache_dir, install_dir
+    end
+
+    Dir.chdir install_dir do
+      system @git, 'fetch', '--quiet', '--force', '--tags', install_dir
+
+      success = system @git, 'reset', '--quiet', '--hard', rev_parse
+
+      success &&=
+        Gem::Util.silent_system @git, 'submodule', 'update',
+               '--quiet', '--init', '--recursive' if @need_submodules
+
+      success
+    end
+  end
+
+  ##
+  # Creates a local cache repository for the git gem.
+
+  def cache # :nodoc:
+    return unless @remote
+
+    if File.exist? repo_cache_dir then
+      Dir.chdir repo_cache_dir do
+        system @git, 'fetch', '--quiet', '--force', '--tags',
+               @repository, 'refs/heads/*:refs/heads/*'
+      end
+    else
+      system @git, 'clone', '--quiet', '--bare', '--no-hardlinks',
+             @repository, repo_cache_dir
+    end
+  end
+
+  ##
+  # Directory where git gems get unpacked and so-forth.
+
+  def base_dir # :nodoc:
+    File.join @root_dir, 'bundler'
+  end
+
+  ##
+  # A short reference for use in git gem directories
+
+  def dir_shortref # :nodoc:
+    rev_parse[0..11]
+  end
+
+  ##
+  # Nothing to download for git gems
+
+  def download full_spec, path # :nodoc:
+  end
+
+  ##
+  # The directory where the git gem will be installed.
+
+  def install_dir # :nodoc:
+    return unless File.exist? repo_cache_dir
+
+    File.join base_dir, 'gems', "#{@name}-#{dir_shortref}"
+  end
+
+  def pretty_print q # :nodoc:
+    q.group 2, '[Git: ', ']' do
+      q.breakable
+      q.text @repository
+
+      q.breakable
+      q.text @reference
+    end
+  end
+
+  ##
+  # The directory where the git gem's repository will be cached.
+
+  def repo_cache_dir # :nodoc:
+    File.join @root_dir, 'cache', 'bundler', 'git', "#{@name}-#{uri_hash}"
+  end
+
+  ##
+  # Converts the git reference for the repository into a commit hash.
+
+  def rev_parse # :nodoc:
+    hash = nil
+
+    Dir.chdir repo_cache_dir do
+      hash = Gem::Util.popen(@git, 'rev-parse', @reference).strip
+    end
+
+    raise Gem::Exception,
+          "unable to find reference #{@reference} in #{@repository}" unless
+            $?.success?
+
+    hash
+  end
+
+  ##
+  # Loads all gemspecs in the repository
+
+  def specs
+    checkout
+
+    return [] unless install_dir
+
+    Dir.chdir install_dir do
+      Dir['{,*,*/*}.gemspec'].map do |spec_file|
+        directory = File.dirname spec_file
+        file      = File.basename spec_file
+
+        Dir.chdir directory do
+          spec = Gem::Specification.load file
+          if spec then
+            spec.base_dir = base_dir
+
+            spec.extension_dir =
+              File.join base_dir, 'extensions', Gem::Platform.local.to_s,
+                Gem.extension_api_version, "#{name}-#{dir_shortref}"
+
+            spec.full_gem_path = File.dirname spec.loaded_from if spec
+          end
+          spec
+        end
+      end.compact
+    end
+  end
+
+  ##
+  # A hash for the git gem based on the git repository URI.
+
+  def uri_hash # :nodoc:
+    normalized =
+      if @repository =~ %r%^\w+://(\w+@)?% then
+        uri = URI(@repository).normalize.to_s.sub %r%/$%,''
+        uri.sub(/\A(\w+)/) { $1.downcase }
+      else
+        @repository
+      end
+
+    Digest::SHA1.hexdigest normalized
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/source/installed.rb b/jruby/lib/ruby/shared/rubygems/source/installed.rb
index 7709778..bd05c75 100644
--- a/jruby/lib/ruby/shared/rubygems/source/installed.rb
+++ b/jruby/lib/ruby/shared/rubygems/source/installed.rb
@@ -1,6 +1,10 @@
+##
+# Represents an installed gem.  This is used for dependency resolution.
+
 class Gem::Source::Installed < Gem::Source
 
-  def initialize
+  def initialize # :nodoc:
+    @uri = nil
   end
 
   ##
@@ -8,6 +12,10 @@ class Gem::Source::Installed < Gem::Source
 
   def <=> other
     case other
+    when Gem::Source::Git,
+         Gem::Source::Lock,
+         Gem::Source::Vendor then
+      -1
     when Gem::Source::Installed then
       0
     when Gem::Source then
@@ -24,5 +32,9 @@ class Gem::Source::Installed < Gem::Source
     nil
   end
 
+  def pretty_print q # :nodoc:
+    q.text '[Installed]'
+  end
+
 end
 
diff --git a/jruby/lib/ruby/shared/rubygems/source/local.rb b/jruby/lib/ruby/shared/rubygems/source/local.rb
index 08d1010..8057921 100644
--- a/jruby/lib/ruby/shared/rubygems/source/local.rb
+++ b/jruby/lib/ruby/shared/rubygems/source/local.rb
@@ -1,5 +1,10 @@
+##
+# The local source finds gems in the current directory for fulfilling
+# dependencies.
+
 class Gem::Source::Local < Gem::Source
-  def initialize
+
+  def initialize # :nodoc:
     @specs   = nil
     @api_uri = nil
     @uri     = nil
@@ -10,7 +15,8 @@ class Gem::Source::Local < Gem::Source
 
   def <=> other
     case other
-    when Gem::Source::Installed then
+    when Gem::Source::Installed,
+         Gem::Source::Lock then
       -1
     when Gem::Source::Local then
       0
@@ -26,7 +32,7 @@ class Gem::Source::Local < Gem::Source
     "#<%s specs: %p>" % [self.class, keys]
   end
 
-  def load_specs(type)
+  def load_specs type # :nodoc:
     names = []
 
     @specs = {}
@@ -68,8 +74,8 @@ class Gem::Source::Local < Gem::Source
     names
   end
 
-  def find_gem(gem_name, version=Gem::Requirement.default,
-               prerelease=false)
+  def find_gem gem_name, version = Gem::Requirement.default, # :nodoc:
+               prerelease = false
     load_specs :complete
 
     found = []
@@ -88,10 +94,10 @@ class Gem::Source::Local < Gem::Source
       end
     end
 
-    found.sort_by { |s| s.version }.last
+    found.max_by { |s| s.version }
   end
 
-  def fetch_spec(name)
+  def fetch_spec name # :nodoc:
     load_specs :complete
 
     if data = @specs[name]
@@ -101,7 +107,7 @@ class Gem::Source::Local < Gem::Source
     end
   end
 
-  def download(spec, cache_dir=nil)
+  def download spec, cache_dir = nil # :nodoc:
     load_specs :complete
 
     @specs.each do |name, data|
diff --git a/jruby/lib/ruby/shared/rubygems/source/lock.rb b/jruby/lib/ruby/shared/rubygems/source/lock.rb
new file mode 100644
index 0000000..2ba7702
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/source/lock.rb
@@ -0,0 +1,48 @@
+##
+# A Lock source wraps an installed gem's source and sorts before other sources
+# during dependency resolution.  This allows RubyGems to prefer gems from
+# dependency lock files.
+
+class Gem::Source::Lock < Gem::Source
+
+  ##
+  # The wrapped Gem::Source
+
+  attr_reader :wrapped
+
+  ##
+  # Creates a new Lock source that wraps +source+ and moves it earlier in the
+  # sort list.
+
+  def initialize source
+    @wrapped = source
+  end
+
+  def <=> other # :nodoc:
+    case other
+    when Gem::Source::Lock then
+      @wrapped <=> other.wrapped
+    when Gem::Source then
+      1
+    else
+      nil
+    end
+  end
+
+  def == other # :nodoc:
+    0 == (self <=> other)
+  end
+
+  ##
+  # Delegates to the wrapped source's fetch_spec method.
+
+  def fetch_spec name_tuple
+    @wrapped.fetch_spec name_tuple
+  end
+
+  def uri # :nodoc:
+    @wrapped.uri
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/source/specific_file.rb b/jruby/lib/ruby/shared/rubygems/source/specific_file.rb
index 8d328b3..250a839 100644
--- a/jruby/lib/ruby/shared/rubygems/source/specific_file.rb
+++ b/jruby/lib/ruby/shared/rubygems/source/specific_file.rb
@@ -1,4 +1,17 @@
+##
+# A source representing a single .gem file.  This is used for installation of
+# local gems.
+
 class Gem::Source::SpecificFile < Gem::Source
+
+  ##
+  # The path to the gem for this specific file.
+
+  attr_reader :path
+
+  ##
+  # Creates a new SpecificFile for the gem in +file+
+
   def initialize(file)
     @uri = nil
     @path = ::File.expand_path(file)
@@ -8,25 +21,28 @@ class Gem::Source::SpecificFile < Gem::Source
     @name = @spec.name_tuple
   end
 
+  ##
+  # The Gem::Specification extracted from this .gem.
+
   attr_reader :spec
 
-  def load_specs(*a)
+  def load_specs *a # :nodoc:
     [@name]
   end
 
-  def fetch_spec(name)
+  def fetch_spec name # :nodoc:
     return @spec if name == @name
     raise Gem::Exception, "Unable to find '#{name}'"
     @spec
   end
 
-  def download(spec, dir=nil)
+  def download spec, dir = nil # :nodoc:
     return @path if spec == @spec
     raise Gem::Exception, "Unable to download '#{spec.full_name}'"
   end
 
   def pretty_print q # :nodoc:
-    q.group 2, '[Local:', ']' do
+    q.group 2, '[SpecificFile:', ']' do
       q.breakable
       q.text @path
     end
diff --git a/jruby/lib/ruby/shared/rubygems/source/vendor.rb b/jruby/lib/ruby/shared/rubygems/source/vendor.rb
new file mode 100644
index 0000000..2d93623
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/source/vendor.rb
@@ -0,0 +1,27 @@
+##
+# This represents a vendored source that is similar to an installed gem.
+
+class Gem::Source::Vendor < Gem::Source::Installed
+
+  ##
+  # Creates a new Vendor source for a gem that was unpacked at +path+.
+
+  def initialize path
+    @uri = path
+  end
+
+  def <=> other
+    case other
+    when Gem::Source::Lock then
+      -1
+    when Gem::Source::Vendor then
+      0
+    when Gem::Source then
+      1
+    else
+      nil
+    end
+  end
+
+end
+
diff --git a/jruby/lib/ruby/shared/rubygems/source_list.rb b/jruby/lib/ruby/shared/rubygems/source_list.rb
index 7bd8ef0..e01f11c 100644
--- a/jruby/lib/ruby/shared/rubygems/source_list.rb
+++ b/jruby/lib/ruby/shared/rubygems/source_list.rb
@@ -1,28 +1,53 @@
 require 'rubygems/source'
 
+##
+# The SourceList represents the sources rubygems has been configured to use.
+# A source may be created from an array of sources:
+#
+#   Gem::SourceList.from %w[https://rubygems.example https://internal.example]
+#
+# Or by adding them:
+#
+#   sources = Gem::SourceList.new
+#   sources.add 'https://rubygems.example'
+#
+# The most common way to get a SourceList is Gem.sources.
+
 class Gem::SourceList
+
+  include Enumerable
+
+  ##
+  # Creates a new SourceList
+
   def initialize
     @sources = []
   end
 
+  ##
+  # The sources in this list
+
   attr_reader :sources
 
+  ##
+  # Creates a new SourceList from an array of sources.
+
   def self.from(ary)
     list = new
 
-    if ary
-      ary.each do |x|
-        list << x
-      end
-    end
+    list.replace ary
 
     return list
   end
 
-  def initialize_copy(other)
+  def initialize_copy(other) # :nodoc:
     @sources = @sources.dup
   end
 
+  ##
+  # Appends +obj+ to the source list which may be a Gem::Source, URI or URI
+  # String.
+
   def <<(obj)
     src = case obj
           when URI
@@ -37,8 +62,12 @@ class Gem::SourceList
     src
   end
 
+  ##
+  # Replaces this SourceList with the sources in +other+  See #<< for
+  # acceptable items in +other+.
+
   def replace(other)
-    @sources.clear
+    clear
 
     other.each do |x|
       self << x
@@ -47,28 +76,58 @@ class Gem::SourceList
     self
   end
 
+  ##
+  # Removes all sources from the SourceList.
+
+  def clear
+    @sources.clear
+  end
+
+  ##
+  # Yields each source URI in the list.
+
   def each
     @sources.each { |s| yield s.uri.to_s }
   end
 
+  ##
+  # Yields each source in the list.
+
   def each_source(&b)
     @sources.each(&b)
   end
 
-  def ==(other)
+  ##
+  # Returns true if there are no sources in this SourceList.
+
+  def empty?
+    @sources.empty?
+  end
+
+  def == other # :nodoc:
     to_a == other
   end
 
+  ##
+  # Returns an Array of source URI Strings.
+
   def to_a
     @sources.map { |x| x.uri.to_s }
   end
 
   alias_method :to_ary, :to_a
 
+  ##
+  # Returns the first source in the list.
+
   def first
     @sources.first
   end
 
+  ##
+  # Returns true if this source list includes +other+ which may be a
+  # Gem::Source or a source URI.
+
   def include?(other)
     if other.kind_of? Gem::Source
       @sources.include? other
@@ -77,11 +136,14 @@ class Gem::SourceList
     end
   end
 
-  def delete(uri)
-    if uri.kind_of? Gem::Source
-      @sources.delete uri
+  ##
+  # Deletes +source+ from the source list which may be a Gem::Source or a URI.
+
+  def delete source
+    if source.kind_of? Gem::Source
+      @sources.delete source
     else
-      @sources.delete_if { |x| x.uri.to_s == uri.to_s }
+      @sources.delete_if { |x| x.uri.to_s == source.to_s }
     end
   end
 end
diff --git a/jruby/lib/ruby/shared/rubygems/spec_fetcher.rb b/jruby/lib/ruby/shared/rubygems/spec_fetcher.rb
index 3ae7afc..4967c4a 100644
--- a/jruby/lib/ruby/shared/rubygems/spec_fetcher.rb
+++ b/jruby/lib/ruby/shared/rubygems/spec_fetcher.rb
@@ -18,6 +18,11 @@ class Gem::SpecFetcher
   attr_reader :latest_specs # :nodoc:
 
   ##
+  # Sources for this SpecFetcher
+
+  attr_reader :sources # :nodoc:
+
+  ##
   # Cache of all released specs
 
   attr_reader :specs # :nodoc:
@@ -29,6 +34,10 @@ class Gem::SpecFetcher
 
   @fetcher = nil
 
+  ##
+  # Default fetcher instance.  Use this instead of ::new to reduce object
+  # allocation.
+
   def self.fetcher
     @fetcher ||= new
   end
@@ -37,8 +46,22 @@ class Gem::SpecFetcher
     @fetcher = fetcher
   end
 
-  def initialize
-    @update_cache = File.stat(Gem.user_home).uid == Process.uid
+  ##
+  # Creates a new SpecFetcher.  Ordinarily you want to use the default fetcher
+  # from Gem::SpecFetcher::fetcher which uses the Gem.sources.
+  #
+  # If you need to retrieve specifications from a different +source+, you can
+  # send it as an argument.
+
+  def initialize sources = nil
+    @sources = sources || Gem.sources
+
+    @update_cache =
+      begin
+        File.stat(Gem.user_home).uid == Process.uid
+      rescue Errno::EACCES, Errno::ENOENT
+        false
+      end
 
     @specs = {}
     @latest_specs = {}
@@ -65,7 +88,11 @@ class Gem::SpecFetcher
     rejected_specs = {}
 
     if dependency.prerelease?
-      type = :complete
+      if dependency.specific?
+        type = :complete
+      else
+        type = :abs_latest
+      end
     elsif dependency.latest_version?
       type = :latest
     else
@@ -159,7 +186,7 @@ class Gem::SpecFetcher
   def suggest_gems_from_name gem_name
     gem_name        = gem_name.downcase.tr('_-', '')
     max             = gem_name.size / 2
-    names           = available_specs(:complete).first.values.flatten(1)
+    names           = available_specs(:latest).first.values.flatten(1)
 
     matches = names.map { |n|
       next unless n.match_platform?
@@ -192,7 +219,7 @@ class Gem::SpecFetcher
     errors = []
     list = {}
 
-    Gem.sources.each_source do |source|
+    @sources.each_source do |source|
       begin
         names = case type
                 when :latest
@@ -205,6 +232,12 @@ class Gem::SpecFetcher
                     tuples_for(source, :released)
 
                   names.sort
+                when :abs_latest
+                  names =
+                    tuples_for(source, :prerelease, true) +
+                    tuples_for(source, :latest)
+
+                  names.sort
                 when :prerelease
                   tuples_for(source, :prerelease)
                 else
@@ -220,19 +253,16 @@ class Gem::SpecFetcher
     [list, errors]
   end
 
-  def tuples_for(source, type, gracefully_ignore=false)
-    cache = @caches[type]
-
-    tuples =
-      begin
-        cache[source.uri] ||=
-          source.load_specs(type).sort_by { |tup| tup.name }
-      rescue Gem::RemoteFetcher::FetchError
-        raise unless gracefully_ignore
-        []
-      end
-
-    tuples
+  ##
+  # Retrieves NameTuples from +source+ of the given +type+ (:prerelease,
+  # etc.).  If +gracefully_ignore+ is true, errors are ignored.
+
+  def tuples_for(source, type, gracefully_ignore=false) # :nodoc:
+    @caches[type][source.uri] ||=
+      source.load_specs(type).sort_by { |tup| tup.name }
+  rescue Gem::RemoteFetcher::FetchError
+    raise unless gracefully_ignore
+    []
   end
 
 end
diff --git a/jruby/lib/ruby/shared/rubygems/specification.rb b/jruby/lib/ruby/shared/rubygems/specification.rb
index 163447c..eb89c4c 100644
--- a/jruby/lib/ruby/shared/rubygems/specification.rb
+++ b/jruby/lib/ruby/shared/rubygems/specification.rb
@@ -12,12 +12,7 @@ require 'rubygems/platform'
 require 'rubygems/deprecate'
 require 'rubygems/basic_specification'
 require 'rubygems/stub_specification'
-
-# :stopdoc:
-# date.rb can't be loaded for `make install` due to miniruby
-# Date is needed for old gems that stored #date as Date instead of Time.
-class Date; end
-# :startdoc:
+require 'rubygems/util/stringio'
 
 ##
 # The Specification class contains the information for a Gem.  Typically
@@ -26,6 +21,7 @@ class Date; end
 #   Gem::Specification.new do |s|
 #     s.name        = 'example'
 #     s.version     = '0.1.0'
+#     s.licenses    = ['MIT']
 #     s.summary     = "This is an example!"
 #     s.description = "Much longer explanation of the example!"
 #     s.authors     = ["Ruby Coder"]
@@ -71,13 +67,13 @@ class Gem::Specification < Gem::BasicSpecification
   #
   # NOTE RubyGems < 1.2 cannot load specification versions > 2.
 
-  CURRENT_SPECIFICATION_VERSION = 4
+  CURRENT_SPECIFICATION_VERSION = 4 # :nodoc:
 
   ##
   # An informal list of changes to the specification.  The highest-valued
   # key should be equal to the CURRENT_SPECIFICATION_VERSION.
 
-  SPECIFICATION_VERSION_HISTORY = {
+  SPECIFICATION_VERSION_HISTORY = { # :nodoc:
     -1 => ['(RubyGems versions up to and including 0.7 did not have versioned specifications)'],
     1  => [
       'Deprecated "test_suite_file" in favor of the new, but equivalent, "test_files"',
@@ -95,12 +91,18 @@ class Gem::Specification < Gem::BasicSpecification
     ]
   }
 
-  MARSHAL_FIELDS = { -1 => 16, 1 => 16, 2 => 16, 3 => 17, 4 => 18 }
+  MARSHAL_FIELDS = { # :nodoc:
+    -1 => 16,
+     1 => 16,
+     2 => 16,
+     3 => 17,
+     4 => 18,
+  }
 
   today = Time.now.utc
-  TODAY = Time.utc(today.year, today.month, today.day)
+  TODAY = Time.utc(today.year, today.month, today.day) # :nodoc:
 
-  LOAD_CACHE = {}
+  LOAD_CACHE = {} # :nodoc:
 
   private_constant :LOAD_CACHE if defined? private_constant
 
@@ -153,7 +155,7 @@ class Gem::Specification < Gem::BasicSpecification
     :version                   => nil,
   }
 
-  Dupable = { }
+  Dupable = { } # :nodoc:
 
   @@default_value.each do |k,v|
     case v
@@ -199,6 +201,8 @@ class Gem::Specification < Gem::BasicSpecification
   # Paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
   # activated.
   #
+  # See also #require_paths
+  #
   # If you have an extension you do not need to add <code>"ext"</code> to the
   # require path, the extension build process will copy the extension files
   # into "lib" for you.
@@ -208,9 +212,11 @@ class Gem::Specification < Gem::BasicSpecification
   # Usage:
   #
   #   # If all library files are in the root directory...
-  #   spec.require_path = '.'
+  #   spec.require_paths = ['.']
 
-  attr_accessor :require_paths
+  def require_paths=(val)
+    @require_paths = Array(val)
+  end
 
   ##
   # The version of RubyGems used to create this gem.
@@ -231,19 +237,41 @@ class Gem::Specification < Gem::BasicSpecification
   attr_reader :summary
 
   ##
+  # Singular writer for #authors
+  #
+  # Usage:
+  #
+  #   spec.author = 'John Jones'
+
+  def author= o
+    self.authors = [o]
+  end
+
+  ##
+  # Sets the list of authors, ensuring it is an array.
+  #
+  # Usage:
+  #
+  #   spec.authors = ['John Jones', 'Mary Smith']
+
+  def authors= value
+    @authors = Array(value).flatten.grep(String)
+  end
+
+  ##
   # The platform this gem runs on.
   #
   # This is usually Gem::Platform::RUBY or Gem::Platform::CURRENT.
   #
   # Most gems contain pure Ruby code; they should simply leave the default
   # value in place.  Some gems contain C (or other) code to be compiled into a
-  # Ruby "extension".  The should leave the default value in place unless
-  # their code will only compile on a certain type of system.  Some gems
-  # consist of pre-compiled code ("binary gems").  It's especially important
-  # that they set the platform attribute appropriately.  A shortcut is to set
-  # the platform to Gem::Platform::CURRENT, which will cause the gem builder
-  # to set the platform to the appropriate value for the system on which the
-  # build is being performed.
+  # Ruby "extension".  The gem should leave the default value in place unless
+  # the code will only compile on a certain type of system.  Some gems consist
+  # of pre-compiled code ("binary gems").  It's especially important that they
+  # set the platform attribute appropriately.  A shortcut is to set the
+  # platform to Gem::Platform::CURRENT, which will cause the gem builder to set
+  # the platform to the appropriate value for the system on which the build is
+  # being performed.
   #
   # If this attribute is set to a non-default value, it will be included in
   # the filename of the gem when it is built such as:
@@ -317,7 +345,7 @@ class Gem::Specification < Gem::BasicSpecification
               add_bindir(@executables),
               @extra_rdoc_files,
               @extensions,
-             ].flatten.uniq.compact
+             ].flatten.uniq.compact.sort
   end
 
   ######################################################################
@@ -341,7 +369,9 @@ class Gem::Specification < Gem::BasicSpecification
   ##
   # A long description of this gem
   #
-  # The description should be more detailed than the summary.
+  # The description should be more detailed than the summary but not
+  # excessively long.  A few paragraphs is a recommended length with no
+  # examples or formatting.
   #
   # Usage:
   #
@@ -381,6 +411,16 @@ class Gem::Specification < Gem::BasicSpecification
   attr_accessor :post_install_message
 
   ##
+  # The version of Ruby required by this gem
+
+  attr_reader :required_ruby_version
+
+  ##
+  # The RubyGems version required by this gem
+
+  attr_reader :required_rubygems_version
+
+  ##
   # The key used to sign this gem.  See Gem::Security for details.
 
   attr_accessor :signing_key
@@ -433,28 +473,6 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # Singular writer for #authors
-  #
-  # Usage:
-  #
-  #   spec.author = 'John Jones'
-
-  def author= o
-    self.authors = [o]
-  end
-
-  ##
-  # Sets the list of authors, ensuring it is an array.
-  #
-  # Usage:
-  #
-  #   spec.authors = ['John Jones', 'Mary Smith']
-
-  def authors= value
-    @authors = Array(value).flatten.grep(String)
-  end
-
-  ##
   # Executables included in the gem.
   #
   # For example, the rake gem has rake as an executable. You dont specify the
@@ -462,6 +480,9 @@ class Gem::Specification < Gem::BasicSpecification
   # found in bindir.  These files must be executable Ruby files.  Files that
   # use bash or other interpreters will not work.
   #
+  # Executables included may only be ruby scripts, not scripts for other
+  # languages or compiled binaries.
+  #
   # Usage:
   #
   #   spec.executables << 'rake'
@@ -504,15 +525,44 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
+  # The version of RubyGems that installed this gem.  Returns
+  # <code>Gem::Version.new(0)</code> for gems installed by versions earlier
+  # than RubyGems 2.2.0.
+
+  def installed_by_version # :nodoc:
+    @installed_by_version ||= Gem::Version.new(0)
+  end
+
+  ##
+  # Sets the version of RubyGems that installed this gem.  See also
+  # #installed_by_version.
+
+  def installed_by_version= version # :nodoc:
+    @installed_by_version = Gem::Version.new version
+  end
+
+  ##
+  # :category: Recommended gemspec attributes
+  #
   # The license for this gem.
   #
-  # The license must be a short name, no more than 64 characters.
+  # The license must be no more than 64 characters.
   #
-  # This should just be the name of your license. The full
-  # text of the license should be inside of the gem when you build it.
+  # This should just be the name of your license. The full text of the license
+  # should be inside of the gem (at the top level) when you build it.
   #
-  # See http://opensource.org/licenses/alphabetical for a list of licenses and
-  # their abbreviations (or short names).
+  # The simplest way, is to specify the standard SPDX ID
+  # https://spdx.org/licenses/ for the license.
+  # Ideally you should pick one that is OSI (Open Source Initiative)
+  # http://opensource.org/licenses/alphabetical approved.
+  #
+  # The most commonly used OSI approved licenses are BSD-3-Clause and MIT.
+  # GitHub also provides a license picker at http://choosealicense.com/.
+  #
+  # You should specify a license for your gem so that people know how they are
+  # permitted to use it, and any restrictions you're placing on it.  Not
+  # specifying a license means all rights are reserved; others have no rights
+  # to use the code for any purpose.
   #
   # You can set multiple licenses with #licenses=
   #
@@ -524,6 +574,7 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
+  # :category: Recommended gemspec attributes
   # The license(s) for the library.
   #
   # Each license must be a short name, no more than 64 characters.
@@ -574,6 +625,13 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
+  # The RubyGems version required by this gem
+
+  def required_rubygems_version= req
+    @required_rubygems_version = Gem::Requirement.create req
+  end
+
+  ##
   # Lists the external (to RubyGems) requirements that must be met for this gem
   # to work.  It's simply information for the user.
   #
@@ -594,7 +652,7 @@ class Gem::Specification < Gem::BasicSpecification
   #   spec.test_files = Dir.glob('test/tc_*.rb')
   #   spec.test_files = ['tests/test-suite.rb']
 
-  def test_files= files
+  def test_files= files # :nodoc:
     @test_files = Array files
   end
 
@@ -628,16 +686,6 @@ class Gem::Specification < Gem::BasicSpecification
   attr_writer :original_platform # :nodoc:
 
   ##
-  # The version of Ruby required by this gem
-
-  attr_reader :required_ruby_version
-
-  ##
-  # The RubyGems version required by this gem
-
-  attr_reader :required_rubygems_version
-
-  ##
   # The rubyforge project this gem lives under.  i.e. RubyGems'
   # rubyforge_project is "rubygems".
   #
@@ -661,8 +709,6 @@ class Gem::Specification < Gem::BasicSpecification
       specs = {}
       Gem.loaded_specs.each_value{|s| specs[s] = true}
       @@all.each{|s| s.activated = true if specs[s]}
-
-      _resort!(@@all)
     end
     @@all
   end
@@ -671,8 +717,7 @@ class Gem::Specification < Gem::BasicSpecification
     LOAD_CACHE.clear
   end
 
-  # :nodoc:
-  def self.each_gemspec(dirs)
+  def self.each_gemspec(dirs) # :nodoc:
     dirs.each do |dir|
       Dir[File.join(dir, "*.gemspec")].each do |path|
         yield path.untaint
@@ -680,16 +725,14 @@ class Gem::Specification < Gem::BasicSpecification
     end
   end
 
-  # :nodoc:
-  def self.each_stub(dirs)
+  def self.each_stub(dirs) # :nodoc:
     each_gemspec(dirs) do |path|
       stub = Gem::StubSpecification.new(path)
       yield stub if stub.valid?
     end
   end
 
-  # :nodoc:
-  def self.each_spec(dirs)
+  def self.each_spec(dirs) # :nodoc:
     each_gemspec(dirs) do |path|
       spec = self.load path
       yield spec if spec
@@ -834,12 +877,8 @@ class Gem::Specification < Gem::BasicSpecification
   # this resets the list of known specs.
 
   def self.dirs= dirs
-    # TODO: find extra calls to dir=
-    # warn "NOTE: dirs= called from #{caller.first} for #{dirs.inspect}"
-
     self.reset
 
-    # ugh
     @@dirs = Array(dirs).map { |dir| File.join dir, "specifications" }
   end
 
@@ -989,8 +1028,8 @@ class Gem::Specification < Gem::BasicSpecification
     file = file.dup.untaint
     return unless File.file?(file)
 
-    spec = LOAD_CACHE[file]
-    return spec if spec
+    _spec = LOAD_CACHE[file]
+    return _spec if _spec
 
     code = if defined? Encoding
              File.read file, :mode => 'r:UTF-8:-'
@@ -1001,15 +1040,15 @@ class Gem::Specification < Gem::BasicSpecification
     code.untaint
 
     begin
-      spec = eval code, binding, file
+      _spec = eval code, binding, file
 
-      if Gem::Specification === spec
-        spec.loaded_from = file.to_s
-        LOAD_CACHE[file] = spec
-        return spec
+      if Gem::Specification === _spec
+        _spec.loaded_from = File.expand_path file.to_s
+        LOAD_CACHE[file] = _spec
+        return _spec
       end
 
-      warn "[#{file}] isn't a Gem::Specification (#{spec.class} instead)."
+      warn "[#{file}] isn't a Gem::Specification (#{_spec.class} instead)."
     rescue SignalException, SystemExit
       raise
     rescue SyntaxError, Exception => e
@@ -1083,9 +1122,6 @@ class Gem::Specification < Gem::BasicSpecification
   # Removes +spec+ from the known specs.
 
   def self.remove_spec spec
-    # TODO: beat on the tests
-    raise "wtf: #{spec.full_name} not in #{all_names.inspect}" unless
-      _all.include? spec
     _all.delete spec
     stubs.delete_if { |s| s.full_name == spec.full_name }
   end
@@ -1235,9 +1271,13 @@ class Gem::Specification < Gem::BasicSpecification
   # there are conflicts upon activation.
 
   def activate
-    raise_if_conflicts
+    other = Gem.loaded_specs[self.name]
+    if other then
+      check_version_conflict other
+      return false
+    end
 
-    return false if Gem.loaded_specs[self.name]
+    raise_if_conflicts
 
     activate_dependencies
     add_self_to_load_path
@@ -1251,7 +1291,7 @@ class Gem::Specification < Gem::BasicSpecification
 
   ##
   # Activate all unambiguously resolved runtime dependencies of this
-  # spec. Add any ambigous dependencies to the unresolved list to be
+  # spec. Add any ambiguous dependencies to the unresolved list to be
   # resolved later, as needed.
 
   def activate_dependencies
@@ -1310,7 +1350,7 @@ class Gem::Specification < Gem::BasicSpecification
                    end
 
     unless dependency.respond_to?(:name) &&
-           dependency.respond_to?(:version_requirements)
+           dependency.respond_to?(:requirement)
       dependency = Gem::Dependency.new(dependency.to_s, requirements, type)
     end
 
@@ -1327,9 +1367,7 @@ class Gem::Specification < Gem::BasicSpecification
   def add_self_to_load_path
     return if default_gem?
 
-    paths = require_paths.map do |path|
-      File.join full_gem_path, path
-    end
+    paths = full_require_paths
 
     # gem directories must come after -I and ENV['RUBYLIB']
     insert_index = Gem.load_path_insert_index
@@ -1380,14 +1418,50 @@ class Gem::Specification < Gem::BasicSpecification
   # Returns the build_args used to install the gem
 
   def build_args
-    if File.exists? build_info_file
-      File.readlines(build_info_file).map { |x| x.strip }
+    if File.exist? build_info_file
+      build_info = File.readlines build_info_file
+      build_info = build_info.map { |x| x.strip }
+      build_info.delete ""
+      build_info
     else
       []
     end
   end
 
   ##
+  # Builds extensions for this platform if the gem has extensions listed and
+  # the gem.build_complete file is missing.
+
+  def build_extensions # :nodoc:
+    return if default_gem?
+    return if extensions.empty?
+    return if installed_by_version < Gem::Version.new('2.2.0.preview.2')
+    return if File.exist? gem_build_complete_path
+    return if !File.writable?(base_dir)
+    return if !File.exist?(File.join(base_dir, 'extensions'))
+
+    begin
+      # We need to require things in $LOAD_PATH without looking for the
+      # extension we are about to build.
+      unresolved_deps = Gem::Specification.unresolved_deps.dup
+      Gem::Specification.unresolved_deps.clear
+
+      require 'rubygems/config_file'
+      require 'rubygems/ext'
+      require 'rubygems/user_interaction'
+
+      ui = Gem::SilentUI.new
+      Gem::DefaultUserInteraction.use_ui ui do
+        builder = Gem::Ext::Builder.new self
+        builder.build_extensions
+      end
+    ensure
+      ui.close if ui
+      Gem::Specification.unresolved_deps.replace unresolved_deps
+    end
+  end
+
+  ##
   # Returns the full path to the build info directory
 
   def build_info_dir
@@ -1403,6 +1477,16 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
+  # Used to detect if the gem is bundled in older version of Ruby, but not
+  # detectable as default gem (see BasicSpecification#default_gem?).
+
+  def bundled_gem_in_old_ruby?
+    !default_gem? &&
+      RUBY_VERSION < "2.0.0" &&
+      summary == "This #{name} is bundled with Ruby"
+  end
+
+  ##
   # Returns the full path to the cache directory containing this
   # spec's cached gem.
 
@@ -1422,13 +1506,12 @@ class Gem::Specification < Gem::BasicSpecification
 
   def conflicts
     conflicts = {}
-    Gem.loaded_specs.values.each do |spec|
-      bad = self.runtime_dependencies.find_all { |dep|
-        spec.name == dep.name and not spec.satisfies_requirement? dep
-      }
-
-      conflicts[spec] = bad unless bad.empty?
-    end
+    self.runtime_dependencies.each { |dep|
+      spec = Gem.loaded_specs[dep.name]
+      if spec and not spec.satisfies_requirement? dep
+        (conflicts[spec] ||= []) << dep
+      end
+    }
     conflicts
   end
 
@@ -1441,10 +1524,16 @@ class Gem::Specification < Gem::BasicSpecification
     @date ||= TODAY
   end
 
-  DateTimeFormat = /\A
-                     (\d{4})-(\d{2})-(\d{2})
-                     (\s+ \d{2}:\d{2}:\d{2}\.\d+ \s* (Z | [-+]\d\d:\d\d) )?
-                   \Z/x
+  DateLike = Object.new # :nodoc:
+  def DateLike.===(obj) # :nodoc:
+    defined?(::Date) and Date === obj
+  end
+
+  DateTimeFormat = # :nodoc:
+    /\A
+     (\d{4})-(\d{2})-(\d{2})
+     (\s+ \d{2}:\d{2}:\d{2}\.\d+ \s* (Z | [-+]\d\d:\d\d) )?
+     \Z/x
 
   ##
   # The date this gem was created
@@ -1469,7 +1558,7 @@ class Gem::Specification < Gem::BasicSpecification
                 raise(Gem::InvalidSpecificationException,
                       "invalid date format in specification: #{date.inspect}")
               end
-            when Time, Date then
+            when Time, DateLike then
               Time.utc(date.year, date.month, date.day)
             else
               TODAY
@@ -1517,7 +1606,6 @@ class Gem::Specification < Gem::BasicSpecification
   #   [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]
 
   def dependent_gems
-    # REFACTOR: out = []; each; out; ? Really? No #collect love?
     out = []
     Gem::Specification.each do |spec|
       spec.dependencies.each do |dep|
@@ -1556,7 +1644,7 @@ class Gem::Specification < Gem::BasicSpecification
 
   ##
   # Returns the full path to this spec's documentation directory.  If +type+
-  # is given it will be appended to the end.  For examlpe:
+  # is given it will be appended to the end.  For example:
   #
   #   spec.doc_dir      # => "/path/to/gem_repo/doc/a-1"
   #
@@ -1677,8 +1765,7 @@ class Gem::Specification < Gem::BasicSpecification
     spec
   end
 
-  # :nodoc:
-  def find_full_gem_path
+  def find_full_gem_path # :nodoc:
     super || File.expand_path(File.join(gems_dir, original_name))
   end
   private :find_full_gem_path
@@ -1688,11 +1775,18 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # Returns the full path to this spec's gem directory.
-  # eg: /usr/local/lib/ruby/1.8/gems/mygem-1.0
+  # The path to the gem.build_complete file within the extension install
+  # directory.
 
-  def gem_dir
-    @gem_dir ||= File.expand_path File.join(gems_dir, full_name)
+  def gem_build_complete_path # :nodoc:
+    File.join extension_dir, 'gem.build_complete'
+  end
+
+  ##
+  # Work around bundler removing my methods
+
+  def gem_dir # :nodoc:
+    super
   end
 
   ##
@@ -1718,7 +1812,7 @@ class Gem::Specification < Gem::BasicSpecification
   ##
   # True if this gem has files in test_files
 
-  def has_unit_tests?
+  def has_unit_tests? # :nodoc:
     not test_files.empty?
   end
 
@@ -1731,6 +1825,7 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   def init_with coder # :nodoc:
+    @installed_by_version ||= nil
     yaml_initialize coder.tag, coder.map
   end
 
@@ -1744,6 +1839,7 @@ class Gem::Specification < Gem::BasicSpecification
     @activated = false
     self.loaded_from = nil
     @original_platform = nil
+    @installed_by_version = nil
 
     @@nil_attributes.each do |key|
       instance_variable_set "@#{key}", nil
@@ -1799,7 +1895,7 @@ class Gem::Specification < Gem::BasicSpecification
 
   private :invalidate_memoized_attributes
 
-  def inspect
+  def inspect # :nodoc:
     if $DEBUG
       super
     else
@@ -1836,7 +1932,7 @@ class Gem::Specification < Gem::BasicSpecification
   # Singular accessor for #licenses
 
   def license
-    val = licenses and val.first
+    licenses.first
   end
 
   ##
@@ -1855,7 +1951,6 @@ class Gem::Specification < Gem::BasicSpecification
     @cache_dir     = nil
     @cache_file    = nil
     @doc_dir       = nil
-    @gem_dir       = nil
     @ri_dir        = nil
     @spec_dir      = nil
     @spec_file     = nil
@@ -1891,6 +1986,19 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
+  # Is this specification missing its extensions?  When this returns true you
+  # probably want to build_extensions
+
+  def missing_extensions?
+    return false if default_gem?
+    return false if extensions.empty?
+    return false if installed_by_version < Gem::Version.new('2.2.0.preview.2')
+    return false if File.exist? gem_build_complete_path
+
+    true
+  end
+
+  ##
   # Normalize the list of files so that:
   # * All file lists have redundancies removed.
   # * Files referenced in the extra_rdoc_files are included in the package
@@ -1947,8 +2055,12 @@ class Gem::Specification < Gem::BasicSpecification
     q.group 2, 'Gem::Specification.new do |s|', 'end' do
       q.breakable
 
-      # REFACTOR: each_attr - use in to_yaml as well
-      @@attributes.each do |attr_name|
+      attributes = @@attributes - [:name, :version]
+      attributes.unshift :installed_by_version
+      attributes.unshift :version
+      attributes.unshift :name
+
+      attributes.each do |attr_name|
         current_value = self.send attr_name
         if current_value != default_value(attr_name) or
            self.class.required_attribute? attr_name then
@@ -1970,34 +2082,34 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # Check the spec for possible conflicts and freak out if there are any.
+  # Raise an exception if the version of this spec conflicts with the one
+  # that is already loaded (+other+)
 
-  def raise_if_conflicts
-    other = Gem.loaded_specs[self.name]
+  def check_version_conflict other # :nodoc:
+    return if self.version == other.version
 
-    if other and self.version != other.version then
-      # This gem is already loaded.  If the currently loaded gem is not in the
-      # list of candidate gems, then we have a version conflict.
+    # This gem is already loaded.  If the currently loaded gem is not in the
+    # list of candidate gems, then we have a version conflict.
 
-      msg = "can't activate #{full_name}, already activated #{other.full_name}"
+    msg = "can't activate #{full_name}, already activated #{other.full_name}"
 
-      e = Gem::LoadError.new msg
-      e.name = self.name
-      # TODO: e.requirement = dep.requirement
+    e = Gem::LoadError.new msg
+    e.name = self.name
+    # TODO: e.requirement = dep.requirement
 
-      raise e
-    end
+    raise e
+  end
 
-    conf = self.conflicts
+  private :check_version_conflict
 
-    unless conf.empty? then
-      y = conf.map { |act,con|
-        "#{act.full_name} conflicts with #{con.join(", ")}"
-      }.join ", "
+  ##
+  # Check the spec for possible conflicts and freak out if there are any.
 
-      # TODO: improve message by saying who activated `con`
+  def raise_if_conflicts # :nodoc:
+    conf = self.conflicts
 
-      raise Gem::LoadError, "Unable to activate #{self.full_name}, because #{y}"
+    unless conf.empty? then
+      raise Gem::ConflictError.new self, conf
     end
   end
 
@@ -2021,14 +2133,7 @@ class Gem::Specification < Gem::BasicSpecification
   # Singular accessor for #require_paths
 
   def require_path= path
-    self.require_paths = [path]
-  end
-
-  ##
-  # The RubyGems version required by this gem
-
-  def required_rubygems_version= req
-    @required_rubygems_version = Gem::Requirement.create req
+    self.require_paths = Array(path)
   end
 
   ##
@@ -2063,7 +2168,7 @@ class Gem::Specification < Gem::BasicSpecification
       seg = obj.keys.sort.map { |k| "#{k.to_s.dump} => #{obj[k].to_s.dump}" }
       "{ #{seg.join(', ')} }"
     when Gem::Version      then obj.to_s.dump
-    when Date              then obj.strftime('%Y-%m-%d').dump
+    when DateLike          then obj.strftime('%Y-%m-%d').dump
     when Time              then obj.strftime('%Y-%m-%d').dump
     when Numeric           then obj.inspect
     when true, false, nil  then obj.inspect
@@ -2109,10 +2214,10 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   ##
-  # Used by Gem::DependencyResolver to order Gem::Specification objects
+  # Used by Gem::Resolver to order Gem::Specification objects
 
   def source # :nodoc:
-    self
+    Gem::Source::Installed.new
   end
 
   ##
@@ -2151,14 +2256,14 @@ class Gem::Specification < Gem::BasicSpecification
   ##
   # Singular accessor for #test_files
 
-  def test_file
+  def test_file # :nodoc:
     val = test_files and val.first
   end
 
   ##
   # Singular mutator for #test_files
 
-  def test_file= file
+  def test_file= file # :nodoc:
     self.test_files = [file]
   end
 
@@ -2166,7 +2271,7 @@ class Gem::Specification < Gem::BasicSpecification
   # Test files included in this gem.  You cannot append to this accessor, you
   # must assign to it.
 
-  def test_files
+  def test_files # :nodoc:
     # Handle the possibility that we have @test_suite_file but not
     # @test_files.  This will happen when an old gem is loaded via
     # YAML.
@@ -2185,16 +2290,14 @@ class Gem::Specification < Gem::BasicSpecification
   # Returns a Ruby code representation of this specification, such that it can
   # be eval'ed and reconstruct the same specification later.  Attributes that
   # still have their default values are omitted.
-  #
-  # REFACTOR: This, plus stuff like #ruby_code and #pretty_print, should
-  # probably be extracted out into some sort of separate class. SRP, do you
-  # speak it!??!
 
   def to_ruby
     mark_version
     result = []
     result << "# -*- encoding: utf-8 -*-"
-    result << "#{Gem::StubSpecification::PREFIX}#{name} #{version} #{platform} #{require_paths.join("\0")}"
+    result << "#{Gem::StubSpecification::PREFIX}#{name} #{version} #{platform} #{raw_require_paths.join("\0")}"
+    result << "#{Gem::StubSpecification::PREFIX}#{extensions.join "\0"}" unless
+      extensions.empty?
     result << nil
     result << "Gem::Specification.new do |s|"
 
@@ -2209,11 +2312,13 @@ class Gem::Specification < Gem::BasicSpecification
     if metadata and !metadata.empty?
       result << "  s.metadata = #{ruby_code metadata} if s.respond_to? :metadata="
     end
+    result << "  s.require_paths = #{ruby_code raw_require_paths}"
 
     handled = [
       :dependencies,
       :name,
       :platform,
+      :require_paths,
       :required_rubygems_version,
       :specification_version,
       :version,
@@ -2231,6 +2336,11 @@ class Gem::Specification < Gem::BasicSpecification
       end
     end
 
+    if @installed_by_version then
+      result << nil
+      result << "  s.installed_by_version = \"#{Gem::VERSION}\" if s.respond_to? :installed_by_version"
+    end
+
     unless dependencies.empty? then
       result << nil
       result << "  if s.respond_to? :specification_version then"
@@ -2290,7 +2400,8 @@ class Gem::Specification < Gem::BasicSpecification
   end
 
   def to_yaml(opts = {}) # :nodoc:
-    if YAML.const_defined?(:ENGINE) && !YAML::ENGINE.syck? then
+    if (YAML.const_defined?(:ENGINE) && !YAML::ENGINE.syck?) ||
+        (defined?(Psych) && YAML == Psych) then
       # Because the user can switch the YAML engine behind our
       # back, we have to check again here to make sure that our
       # psych code was properly loaded, and load it if not.
@@ -2302,7 +2413,7 @@ class Gem::Specification < Gem::BasicSpecification
       builder << self
       ast = builder.tree
 
-      io = StringIO.new
+      io = Gem::StringSink.new
       io.set_encoding Encoding::UTF_8 if Object.const_defined? :Encoding
 
       Psych::Visitors::Emitter.new(io).accept(ast)
@@ -2340,12 +2451,13 @@ class Gem::Specification < Gem::BasicSpecification
   # checks..
 
   def validate packaging = true
+    @warnings = 0
     require 'rubygems/user_interaction'
     extend Gem::UserInteraction
     normalize
 
-    nil_attributes = self.class.non_nil_attributes.find_all do |name|
-      instance_variable_get("@#{name}").nil?
+    nil_attributes = self.class.non_nil_attributes.find_all do |attrname|
+      instance_variable_get("@#{attrname}").nil?
     end
 
     unless nil_attributes.empty? then
@@ -2370,7 +2482,7 @@ class Gem::Specification < Gem::BasicSpecification
             "invalid value for attribute name: \"#{name.inspect}\""
     end
 
-    if require_paths.empty? then
+    if raw_require_paths.empty? then
       raise Gem::InvalidSpecificationException,
             'specification must have at least one require_path'
     end
@@ -2388,6 +2500,11 @@ class Gem::Specification < Gem::BasicSpecification
             "[\"#{non_files.join "\", \""}\"] are not files"
     end
 
+    if files.include? file_name then
+      raise Gem::InvalidSpecificationException,
+            "#{full_name} contains itself (#{file_name}), check your files list"
+    end
+
     unless specification_version.is_a?(Fixnum)
       raise Gem::InvalidSpecificationException,
             'specification_version must be a Fixnum (did you mean version?)'
@@ -2415,7 +2532,6 @@ class Gem::Specification < Gem::BasicSpecification
       end
     end
 
-    # FIX: uhhhh single element array.each?
     [:authors].each do |field|
       val = self.send field
       raise Gem::InvalidSpecificationException, "#{field} may not be empty" if
@@ -2458,16 +2574,15 @@ class Gem::Specification < Gem::BasicSpecification
       end
     }
 
-    alert_warning <<-warning if licenses.empty?
-licenses is empty.  Use a license abbreviation from:
-  http://opensource.org/licenses/alphabetical
+    warning <<-warning if licenses.empty?
+licenses is empty, but is recommended.  Use a license abbreviation from:
+http://opensource.org/licenses/alphabetical
     warning
 
     validate_permissions
 
     # reject lazy developers:
 
-    # FIX: Doesn't this just evaluate to "FIXME" or "TODO"?
     lazy = '"FIxxxXME" or "TOxxxDO"'.gsub(/xxx/, '')
 
     unless authors.grep(/FI XME|TO DO/x).empty? then
@@ -2496,33 +2611,99 @@ licenses is empty.  Use a license abbreviation from:
 
     %w[author description email homepage summary].each do |attribute|
       value = self.send attribute
-      alert_warning "no #{attribute} specified" if value.nil? or value.empty?
+      warning "no #{attribute} specified" if value.nil? or value.empty?
     end
 
     if description == summary then
-      alert_warning 'description and summary are identical'
+      warning 'description and summary are identical'
     end
 
     # TODO: raise at some given date
-    alert_warning "deprecated autorequire specified" if autorequire
+    warning "deprecated autorequire specified" if autorequire
 
     executables.each do |executable|
       executable_path = File.join(bindir, executable)
       shebang = File.read(executable_path, 2) == '#!'
 
-      alert_warning "#{executable_path} is missing #! line" unless shebang
+      warning "#{executable_path} is missing #! line" unless shebang
+    end
+
+    validate_dependencies
+
+    true
+  ensure
+    if $! or @warnings > 0 then
+      alert_warning "See http://guides.rubygems.org/specification-reference/ for help"
     end
+  end
+
+  ##
+  # Checks that dependencies use requirements as we recommend.  Warnings are
+  # issued when dependencies are open-ended or overly strict for semantic
+  # versioning.
+
+  def validate_dependencies # :nodoc:
+    seen = {}
 
     dependencies.each do |dep|
+      if prev = seen[dep.name] then
+        raise Gem::InvalidSpecificationException, <<-MESSAGE
+duplicate dependency on #{dep}, (#{prev.requirement}) use:
+    add_runtime_dependency '#{dep.name}', '#{dep.requirement}', '#{prev.requirement}'
+        MESSAGE
+      end
+
+      seen[dep.name] = dep
+
       prerelease_dep = dep.requirements_list.any? do |req|
         Gem::Requirement.new(req).prerelease?
       end
 
-      alert_warning "prerelease dependency on #{dep} is not recommended" if
+      warning "prerelease dependency on #{dep} is not recommended" if
         prerelease_dep
-    end
 
-    true
+      overly_strict = dep.requirement.requirements.length == 1 &&
+        dep.requirement.requirements.any? do |op, version|
+          op == '~>' and
+            not version.prerelease? and
+            version.segments.length > 2 and
+            version.segments.first != 0
+        end
+
+      if overly_strict then
+        _, dep_version = dep.requirement.requirements.first
+
+        base = dep_version.segments.first 2
+
+        warning <<-WARNING
+pessimistic dependency on #{dep} may be overly strict
+  if #{dep.name} is semantically versioned, use:
+    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}', '>= #{dep_version}'
+        WARNING
+      end
+
+      open_ended = dep.requirement.requirements.all? do |op, version|
+        not version.prerelease? and (op == '>' or op == '>=')
+      end
+
+      if open_ended then
+        op, dep_version = dep.requirement.requirements.first
+
+        base = dep_version.segments.first 2
+
+        bugfix = if op == '>' then
+                   ", '> #{dep_version}'"
+                 elsif op == '>=' and base != dep_version.segments then
+                   ", '>= #{dep_version}'"
+                 end
+
+        warning <<-WARNING
+open-ended dependency on #{dep} is not recommended
+  if #{dep.name} is semantically versioned, use:
+    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}'#{bugfix}
+        WARNING
+      end
+    end
   end
 
   ##
@@ -2533,13 +2714,13 @@ licenses is empty.  Use a license abbreviation from:
 
     files.each do |file|
       next if File.stat(file).mode & 0444 == 0444
-      alert_warning "#{file} is not world-readable"
+      warning "#{file} is not world-readable"
     end
 
     executables.each do |name|
       exec = File.join @bindir, name
       next if File.stat(exec).executable?
-      alert_warning "#{exec} is not executable"
+      warning "#{exec} is not executable"
     end
   end
 
@@ -2556,7 +2737,10 @@ licenses is empty.  Use a license abbreviation from:
     return @version
   end
 
-  # FIX: have this handle the platform/new_platform/original_platform bullshit
+  def stubbed?
+    false
+  end
+
   def yaml_initialize(tag, vals) # :nodoc:
     vals.each do |ivar, val|
       case ivar
@@ -2590,6 +2774,14 @@ licenses is empty.  Use a license abbreviation from:
 
       instance_variable_set "@#{attribute}", value
     end
+
+    @installed_by_version ||= nil
+  end
+
+  def warning statement # :nodoc:
+    @warnings += 1
+
+    alert_warning statement
   end
 
   extend Gem::Deprecate
diff --git a/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot-2048.pem b/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot-2048.pem
new file mode 100644
index 0000000..20585f1
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot-2048.pem
@@ -0,0 +1,25 @@
+-----BEGIN CERTIFICATE-----
+MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU
+MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs
+IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290
+MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux
+FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h
+bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v
+dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt
+H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9
+uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX
+mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX
+a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN
+E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0
+WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD
+VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0
+Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU
+cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx
+IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN
+AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH
+YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5
+6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC
+Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX
+c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a
+mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=
+-----END CERTIFICATE-----
diff --git a/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot.pem b/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot.pem
index 580158f..6fbdf52 100644
--- a/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot.pem
+++ b/jruby/lib/ruby/shared/rubygems/ssl_certs/AddTrustExternalCARoot.pem
@@ -1,90 +1,32 @@
-This CA certificate is for verifying HTTPS connection to;
-  - https://rubygems.org/ (obtained by RubyGems team)
-
-Certificate:
-    Data:
-        Version: 3 (0x2)
-        Serial Number: 1 (0x1)
-    Signature Algorithm: sha1WithRSAEncryption
-        Issuer: C=SE, O=AddTrust AB, OU=AddTrust External TTP Network, CN=AddTrust External CA Root
-        Validity
-            Not Before: May 30 10:48:38 2000 GMT
-            Not After : May 30 10:48:38 2020 GMT
-        Subject: C=SE, O=AddTrust AB, OU=AddTrust External TTP Network, CN=AddTrust External CA Root
-        Subject Public Key Info:
-            Public Key Algorithm: rsaEncryption
-                Public-Key: (2048 bit)
-                Modulus:
-                    00:b7:f7:1a:33:e6:f2:00:04:2d:39:e0:4e:5b:ed:
-                    1f:bc:6c:0f:cd:b5:fa:23:b6:ce:de:9b:11:33:97:
-                    a4:29:4c:7d:93:9f:bd:4a:bc:93:ed:03:1a:e3:8f:
-                    cf:e5:6d:50:5a:d6:97:29:94:5a:80:b0:49:7a:db:
-                    2e:95:fd:b8:ca:bf:37:38:2d:1e:3e:91:41:ad:70:
-                    56:c7:f0:4f:3f:e8:32:9e:74:ca:c8:90:54:e9:c6:
-                    5f:0f:78:9d:9a:40:3c:0e:ac:61:aa:5e:14:8f:9e:
-                    87:a1:6a:50:dc:d7:9a:4e:af:05:b3:a6:71:94:9c:
-                    71:b3:50:60:0a:c7:13:9d:38:07:86:02:a8:e9:a8:
-                    69:26:18:90:ab:4c:b0:4f:23:ab:3a:4f:84:d8:df:
-                    ce:9f:e1:69:6f:bb:d7:42:d7:6b:44:e4:c7:ad:ee:
-                    6d:41:5f:72:5a:71:08:37:b3:79:65:a4:59:a0:94:
-                    37:f7:00:2f:0d:c2:92:72:da:d0:38:72:db:14:a8:
-                    45:c4:5d:2a:7d:b7:b4:d6:c4:ee:ac:cd:13:44:b7:
-                    c9:2b:dd:43:00:25:fa:61:b9:69:6a:58:23:11:b7:
-                    a7:33:8f:56:75:59:f5:cd:29:d7:46:b7:0a:2b:65:
-                    b6:d3:42:6f:15:b2:b8:7b:fb:ef:e9:5d:53:d5:34:
-                    5a:27
-                Exponent: 65537 (0x10001)
-        X509v3 extensions:
-            X509v3 Subject Key Identifier: 
-                AD:BD:98:7A:34:B4:26:F7:FA:C4:26:54:EF:03:BD:E0:24:CB:54:1A
-            X509v3 Key Usage: 
-                Certificate Sign, CRL Sign
-            X509v3 Basic Constraints: critical
-                CA:TRUE
-            X509v3 Authority Key Identifier: 
-                keyid:AD:BD:98:7A:34:B4:26:F7:FA:C4:26:54:EF:03:BD:E0:24:CB:54:1A
-                DirName:/C=SE/O=AddTrust AB/OU=AddTrust External TTP Network/CN=AddTrust External CA Root
-                serial:01
-
-    Signature Algorithm: sha1WithRSAEncryption
-         b0:9b:e0:85:25:c2:d6:23:e2:0f:96:06:92:9d:41:98:9c:d9:
-         84:79:81:d9:1e:5b:14:07:23:36:65:8f:b0:d8:77:bb:ac:41:
-         6c:47:60:83:51:b0:f9:32:3d:e7:fc:f6:26:13:c7:80:16:a5:
-         bf:5a:fc:87:cf:78:79:89:21:9a:e2:4c:07:0a:86:35:bc:f2:
-         de:51:c4:d2:96:b7:dc:7e:4e:ee:70:fd:1c:39:eb:0c:02:51:
-         14:2d:8e:bd:16:e0:c1:df:46:75:e7:24:ad:ec:f4:42:b4:85:
-         93:70:10:67:ba:9d:06:35:4a:18:d3:2b:7a:cc:51:42:a1:7a:
-         63:d1:e6:bb:a1:c5:2b:c2:36:be:13:0d:e6:bd:63:7e:79:7b:
-         a7:09:0d:40:ab:6a:dd:8f:8a:c3:f6:f6:8c:1a:42:05:51:d4:
-         45:f5:9f:a7:62:21:68:15:20:43:3c:99:e7:7c:bd:24:d8:a9:
-         91:17:73:88:3f:56:1b:31:38:18:b4:71:0f:9a:cd:c8:0e:9e:
-         8e:2e:1b:e1:8c:98:83:cb:1f:31:f1:44:4c:c6:04:73:49:76:
-         60:0f:c7:f8:bd:17:80:6b:2e:e9:cc:4c:0e:5a:9a:79:0f:20:
-         0a:2e:d5:9e:63:26:1e:55:92:94:d8:82:17:5a:7b:d0:bc:c7:
-         8f:4e:86:04
-
 -----BEGIN CERTIFICATE-----
-MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU
-MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs
-IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290
-MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux
-FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h
-bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v
-dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt
-H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9
-uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX
-mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX
-a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN
-E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0
-WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD
-VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0
-Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU
-cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx
-IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN
-AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH
-YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5
-6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC
-Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX
-c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a
-mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=
+MIIFdDCCBFygAwIBAgIQJ2buVutJ846r13Ci/ITeIjANBgkqhkiG9w0BAQwFADBv
+MQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFk
+ZFRydXN0IEV4dGVybmFsIFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBF
+eHRlcm5hbCBDQSBSb290MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFow
+gYUxCzAJBgNVBAYTAkdCMRswGQYDVQQIExJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAO
+BgNVBAcTB1NhbGZvcmQxGjAYBgNVBAoTEUNPTU9ETyBDQSBMaW1pdGVkMSswKQYD
+VQQDEyJDT01PRE8gUlNBIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIICIjANBgkq
+hkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAkehUktIKVrGsDSTdxc9EZ3SZKzejfSNw
+AHG8U9/E+ioSj0t/EFa9n3Byt2F/yUsPF6c947AEYe7/EZfH9IY+Cvo+XPmT5jR6
+2RRr55yzhaCCenavcZDX7P0N+pxs+t+wgvQUfvm+xKYvT3+Zf7X8Z0NyvQwA1onr
+ayzT7Y+YHBSrfuXjbvzYqOSSJNpDa2K4Vf3qwbxstovzDo2a5JtsaZn4eEgwRdWt
+4Q08RWD8MpZRJ7xnw8outmvqRsfHIKCxH2XeSAi6pE6p8oNGN4Tr6MyBSENnTnIq
+m1y9TBsoilwie7SrmNnu4FGDwwlGTm0+mfqVF9p8M1dBPI1R7Qu2XK8sYxrfV8g/
+vOldxJuvRZnio1oktLqpVj3Pb6r/SVi+8Kj/9Lit6Tf7urj0Czr56ENCHonYhMsT
+8dm74YlguIwoVqwUHZwK53Hrzw7dPamWoUi9PPevtQ0iTMARgexWO/bTouJbt7IE
+IlKVgJNp6I5MZfGRAy1wdALqi2cVKWlSArvX31BqVUa/oKMoYX9w0MOiqiwhqkfO
+KJwGRXa/ghgntNWutMtQ5mv0TIZxMOmm3xaG4Nj/QN370EKIf6MzOi5cHkERgWPO
+GHFrK+ymircxXDpqR+DDeVnWIBqv8mqYqnK8V0rSS527EPywTEHl7R09XiidnMy/
+s1Hap0flhFMCAwEAAaOB9DCB8TAfBgNVHSMEGDAWgBStvZh6NLQm9/rEJlTvA73g
+JMtUGjAdBgNVHQ4EFgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQD
+AgGGMA8GA1UdEwEB/wQFMAMBAf8wEQYDVR0gBAowCDAGBgRVHSAAMEQGA1UdHwQ9
+MDswOaA3oDWGM2h0dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9BZGRUcnVzdEV4dGVy
+bmFsQ0FSb290LmNybDA1BggrBgEFBQcBAQQpMCcwJQYIKwYBBQUHMAGGGWh0dHA6
+Ly9vY3NwLnVzZXJ0cnVzdC5jb20wDQYJKoZIhvcNAQEMBQADggEBAGS/g/FfmoXQ
+zbihKVcN6Fr30ek+8nYEbvFScLsePP9NDXRqzIGCJdPDoCpdTPW6i6FtxFQJdcfj
+Jw5dhHk3QBN39bSsHNA7qxcS1u80GH4r6XnTq1dFDK8o+tDb5VCViLvfhVdpfZLY
+Uspzgb8c8+a4bmYRBbMelC1/kZWSWfFMzqORcUx8Rww7Cxn2obFshj5cqsQugsv5
+B5a6SE2Q8pTIqXOi6wZ7I53eovNNVZ96YUWYGGjHXkBrI/V5eu+MtWuLt29G9Hvx
+PUsE2JOAWVrgQSQdso8VYFhH2+9uRv0V9dlfmrPb2LjkQLPNlzmuhbsdjrzch5vR
+pu/xO28QOG8=
 -----END CERTIFICATE-----
diff --git a/jruby/lib/ruby/shared/rubygems/ssl_certs/DigiCertHighAssuranceEVRootCA.pem b/jruby/lib/ruby/shared/rubygems/ssl_certs/DigiCertHighAssuranceEVRootCA.pem
new file mode 100644
index 0000000..9e6810a
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/ssl_certs/DigiCertHighAssuranceEVRootCA.pem
@@ -0,0 +1,23 @@
+-----BEGIN CERTIFICATE-----
+MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j
+ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL
+MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3
+LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug
+RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm
++9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW
+PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM
+xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB
+Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3
+hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg
+EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF
+MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA
+FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec
+nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z
+eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF
+hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2
+Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe
+vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep
++OkuE6N36B9K
+-----END CERTIFICATE-----
diff --git a/jruby/lib/ruby/shared/rubygems/stub_specification.rb b/jruby/lib/ruby/shared/rubygems/stub_specification.rb
index 08102b4..b184d29 100644
--- a/jruby/lib/ruby/shared/rubygems/stub_specification.rb
+++ b/jruby/lib/ruby/shared/rubygems/stub_specification.rb
@@ -41,6 +41,8 @@ class Gem::StubSpecification < Gem::BasicSpecification
   def initialize(filename)
     self.loaded_from = filename
     @data            = nil
+    @extensions      = nil
+    @name            = nil
     @spec            = nil
   end
 
@@ -48,8 +50,18 @@ class Gem::StubSpecification < Gem::BasicSpecification
   # True when this gem has been activated
 
   def activated?
-    loaded = Gem.loaded_specs[name]
-    loaded && loaded.version == version
+    @activated ||=
+    begin
+      loaded = Gem.loaded_specs[name]
+      loaded && loaded.version == version
+    end
+  end
+
+  def build_extensions # :nodoc:
+    return if default_gem?
+    return if extensions.empty?
+
+    to_spec.build_extensions
   end
 
   ##
@@ -58,11 +70,18 @@ class Gem::StubSpecification < Gem::BasicSpecification
 
   def data
     unless @data
+      @extensions = []
+
       open loaded_from, OPEN_MODE do |file|
         begin
           file.readline # discard encoding line
           stubline = file.readline.chomp
-          @data = StubLine.new(stubline) if stubline.start_with?(PREFIX)
+          if stubline.start_with?(PREFIX) then
+            @data = StubLine.new stubline
+
+            @extensions = $'.split "\0" if
+              /\A#{PREFIX}/ =~ file.readline.chomp
+          end
         rescue EOFError
         end
       end
@@ -74,6 +93,45 @@ class Gem::StubSpecification < Gem::BasicSpecification
   private :data
 
   ##
+  # Extensions for this gem
+
+  def extensions
+    return @extensions if @extensions
+
+    data # load
+
+    @extensions
+  end
+
+  ##
+  # If a gem has a stub specification it doesn't need to bother with
+  # compatibility with original_name gems.  It was installed with the
+  # normalized name.
+
+  def find_full_gem_path # :nodoc:
+    path = File.expand_path File.join gems_dir, full_name
+    path.untaint
+    path
+  end
+
+  ##
+  # Full paths in the gem to add to <code>$LOAD_PATH</code> when this gem is
+  # activated.
+
+  def full_require_paths
+    @require_paths ||= data.require_paths
+
+    super
+  end
+
+  def missing_extensions?
+    return false if default_gem?
+    return false if extensions.empty?
+
+    to_spec.missing_extensions?
+  end
+
+  ##
   # Name of the gem
 
   def name
@@ -92,13 +150,24 @@ class Gem::StubSpecification < Gem::BasicSpecification
 
   def require_paths
     @require_paths ||= data.require_paths
+
+    super
   end
 
   ##
   # The full Gem::Specification for this gem, loaded from evalling its gemspec
 
   def to_spec
+    @spec ||= if @data then
+                Gem.loaded_specs.values.find { |spec|
+                  spec.name == name and spec.version == version
+                }
+              end
+
     @spec ||= Gem::Specification.load(loaded_from)
+    @spec.ignored = @ignored if instance_variable_defined? :@ignored
+
+    @spec
   end
 
   ##
@@ -116,5 +185,12 @@ class Gem::StubSpecification < Gem::BasicSpecification
     @version ||= data.version
   end
 
+  ##
+  # Is there a stub line present for this StubSpecification?
+
+  def stubbed?
+    data.is_a? StubLine
+  end
+
 end
 
diff --git a/jruby/lib/ruby/shared/rubygems/syck_hack.rb b/jruby/lib/ruby/shared/rubygems/syck_hack.rb
index 5356aa0..92179ab 100644
--- a/jruby/lib/ruby/shared/rubygems/syck_hack.rb
+++ b/jruby/lib/ruby/shared/rubygems/syck_hack.rb
@@ -10,9 +10,9 @@
 # class no matter if the full yaml library has loaded or not.
 #
 
-module YAML
+module YAML # :nodoc:
   # In newer 1.9.2, there is a Syck toplevel constant instead of it
-  # being underneith YAML. If so, reference it back under YAML as
+  # being underneath YAML. If so, reference it back under YAML as
   # well.
   if defined? ::Syck
     # for tests that change YAML::ENGINE
@@ -29,7 +29,7 @@ module YAML
   # loaded, so lets define a stub for DefaultKey.
   elsif !defined? YAML::Syck
     module Syck
-      class DefaultKey
+      class DefaultKey # :nodoc:
       end
     end
   end
diff --git a/jruby/lib/ruby/shared/rubygems/test_case.rb b/jruby/lib/ruby/shared/rubygems/test_case.rb
index d6c1a36..6d01517 100644
--- a/jruby/lib/ruby/shared/rubygems/test_case.rb
+++ b/jruby/lib/ruby/shared/rubygems/test_case.rb
@@ -2,7 +2,7 @@
 
 begin
   gem 'minitest', '~> 4.0'
-rescue NoMethodError
+rescue NoMethodError, Gem::LoadError
   # for ruby tests
 end
 
@@ -24,17 +24,19 @@ unless Gem::Dependency.new('rdoc', '>= 3.10').matching_specs.empty?
   gem 'json'
 end
 
-require 'rubygems/deprecate'
 require 'minitest/autorun'
+
+require 'rubygems/deprecate'
+
 require 'fileutils'
+require 'pathname'
+require 'pp'
+require 'rubygems/package'
+require 'shellwords'
 require 'tmpdir'
 require 'uri'
-require 'rubygems/package'
-require 'rubygems/test_utilities'
-require 'pp'
 require 'zlib'
-require 'pathname'
-require 'shellwords'
+
 Gem.load_yaml
 
 require 'rubygems/mock_gem_ui'
@@ -84,6 +86,12 @@ end
 
 class Gem::TestCase < MiniTest::Unit::TestCase
 
+  attr_accessor :fetcher # :nodoc:
+
+  attr_accessor :gem_repo # :nodoc:
+
+  attr_accessor :uri # :nodoc:
+
   def assert_activate expected, *specs
     specs.each do |spec|
       case spec
@@ -107,6 +115,23 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     assert File.exist?(path), msg
   end
 
+  ##
+  # Sets the ENABLE_SHARED entry in RbConfig::CONFIG to +value+ and restores
+  # the original value when the block ends
+
+  def enable_shared value
+    enable_shared = RbConfig::CONFIG['ENABLE_SHARED']
+    RbConfig::CONFIG['ENABLE_SHARED'] = value
+
+    yield
+  ensure
+    if enable_shared then
+      RbConfig::CONFIG['enable_shared'] = enable_shared
+    else
+      RbConfig::CONFIG.delete 'enable_shared'
+    end
+  end
+
   # TODO: move to minitest
   def refute_path_exists path, msg = nil
     msg = message(msg) { "Expected path '#{path}' to not exist" }
@@ -193,11 +218,15 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   def setup
     super
 
-    @orig_gem_home = ENV['GEM_HOME']
-    @orig_gem_path = ENV['GEM_PATH']
+    @orig_gem_home   = ENV['GEM_HOME']
+    @orig_gem_path   = ENV['GEM_PATH']
+    @orig_gem_vendor = ENV['GEM_VENDOR']
+
+    ENV['GEM_VENDOR'] = nil
 
     @current_dir = Dir.pwd
-    @ui = Gem::MockGemUi.new
+    @fetcher     = nil
+    @ui          = Gem::MockGemUi.new
 
     tmpdir = File.expand_path Dir.tmpdir
     tmpdir.untaint
@@ -231,6 +260,8 @@ class Gem::TestCase < MiniTest::Unit::TestCase
                    ruby
                  end
 
+    @git = ENV['GIT'] || 'git'
+
     Gem.ensure_gem_subdirectories @gemhome
 
     @orig_LOAD_PATH = $LOAD_PATH.dup
@@ -241,6 +272,8 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     @orig_ENV_HOME = ENV['HOME']
     ENV['HOME'] = @userhome
     Gem.instance_variable_set :@user_home, nil
+    Gem.send :remove_instance_variable, :@ruby_version if
+      Gem.instance_variables.include? :@ruby_version
 
     FileUtils.mkdir_p @gemhome
     FileUtils.mkdir_p @userhome
@@ -281,10 +314,10 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
     Gem.searcher = nil
     Gem::SpecFetcher.fetcher = nil
-    @orig_BASERUBY = Gem::ConfigMap[:BASERUBY]
-    Gem::ConfigMap[:BASERUBY] = Gem::ConfigMap[:ruby_install_name]
+    @orig_BASERUBY = RbConfig::CONFIG['BASERUBY']
+    RbConfig::CONFIG['BASERUBY'] = RbConfig::CONFIG['ruby_install_name']
 
-    @orig_arch = Gem::ConfigMap[:arch]
+    @orig_arch = RbConfig::CONFIG['arch']
 
     if win_platform?
       util_set_arch 'i386-mswin32'
@@ -302,8 +335,12 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   def teardown
     $LOAD_PATH.replace @orig_LOAD_PATH if @orig_LOAD_PATH
 
-    Gem::ConfigMap[:BASERUBY] = @orig_BASERUBY
-    Gem::ConfigMap[:arch] = @orig_arch
+    if @orig_BASERUBY
+      RbConfig::CONFIG['BASERUBY'] = @orig_BASERUBY
+    else
+      RbConfig::CONFIG.delete('BASERUBY')
+    end
+    RbConfig::CONFIG['arch'] = @orig_arch
 
     if defined? Gem::RemoteFetcher then
       Gem::RemoteFetcher.fetcher = nil
@@ -313,8 +350,9 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
     FileUtils.rm_rf @tempdir unless ENV['KEEP_FILES']
 
-    ENV['GEM_HOME'] = @orig_gem_home
-    ENV['GEM_PATH'] = @orig_gem_path
+    ENV['GEM_HOME']   = @orig_gem_home
+    ENV['GEM_PATH']   = @orig_gem_path
+    ENV['GEM_VENDOR'] = @orig_gem_vendor
 
     Gem.ruby = @orig_ruby if @orig_ruby
 
@@ -369,6 +407,64 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   ##
+  # A git_gem is used with a gem dependencies file.  The gem created here
+  # has no files, just a gem specification for the given +name+ and +version+.
+  #
+  # Yields the +specification+ to the block, if given
+
+  def git_gem name = 'a', version = 1
+    have_git?
+
+    directory = File.join 'git', name
+    directory = File.expand_path directory
+
+    git_spec = Gem::Specification.new name, version do |specification|
+      yield specification if block_given?
+    end
+
+    FileUtils.mkdir_p directory
+
+    gemspec = "#{name}.gemspec"
+
+    open File.join(directory, gemspec), 'w' do |io|
+      io.write git_spec.to_ruby
+    end
+
+    head = nil
+
+    Dir.chdir directory do
+      unless File.exist? '.git' then
+        system @git, 'init', '--quiet'
+        system @git, 'config', 'user.name',  'RubyGems Tests'
+        system @git, 'config', 'user.email', 'rubygems@example'
+      end
+
+      system @git, 'add', gemspec
+      system @git, 'commit', '-a', '-m', 'a non-empty commit message', '--quiet'
+      head = Gem::Util.popen('git', 'rev-parse', 'master').strip
+    end
+
+    return name, git_spec.version, directory, head
+  end
+
+  ##
+  # Skips this test unless you have a git executable
+
+  def have_git?
+    return if in_path? @git
+
+    skip 'cannot find git executable, use GIT environment variable to set'
+  end
+
+  def in_path? executable # :nodoc:
+    return true if %r%\A([A-Z]:|/)% =~ executable and File.exist? executable
+
+    ENV['PATH'].split(File::PATH_SEPARATOR).any? do |directory|
+      File.exist? File.join directory, executable
+    end
+  end
+
+  ##
   # Builds and installs the Gem::Specification +spec+
 
   def install_gem spec, options = {}
@@ -376,7 +472,7 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
     gem = File.join @tempdir, "gems", "#{spec.full_name}.gem"
 
-    unless File.exists? gem
+    unless File.exist? gem then
       use_ui Gem::MockGemUi.new do
         Dir.chdir @tempdir do
           Gem::Package.build spec
@@ -501,28 +597,11 @@ class Gem::TestCase < MiniTest::Unit::TestCase
     return spec
   end
 
-  def quick_spec name, version = '2'
-    # TODO: deprecate
-    require 'rubygems/specification'
-
-    spec = Gem::Specification.new do |s|
-      s.platform    = Gem::Platform::RUBY
-      s.name        = name
-      s.version     = version
-      s.author      = 'A User'
-      s.email       = 'example@example.com'
-      s.homepage    = 'http://example.com'
-      s.summary     = "this is a summary"
-      s.description = "This is a test description"
-
-      yield(s) if block_given?
-    end
-
-    spec.loaded_from = spec.spec_file
-
-    Gem::Specification.add_spec spec
+  ##
+  # TODO:  remove in RubyGems 3.0
 
-    return spec
+  def quick_spec name, version = '2' # :nodoc:
+    util_spec name, version
   end
 
   ##
@@ -559,7 +638,9 @@ class Gem::TestCase < MiniTest::Unit::TestCase
 
   def util_clear_gems
     FileUtils.rm_rf File.join(@gemhome, "gems") # TODO: use Gem::Dirs
+    FileUtils.mkdir File.join(@gemhome, "gems")
     FileUtils.rm_rf File.join(@gemhome, "specifications")
+    FileUtils.mkdir File.join(@gemhome, "specifications")
     Gem::Specification.reset
   end
 
@@ -610,10 +691,11 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   ##
-  # Create a new spec (or gem if passed an array of files) and set it
-  # up properly. Use this instead of util_spec and util_gem.
+  # new_spec is deprecated as it is never used.
+  #
+  # TODO:  remove in RubyGems 3.0
 
-  def new_spec name, version, deps = nil, *files
+  def new_spec name, version, deps = nil, *files # :nodoc:
     require 'rubygems/specification'
 
     spec = Gem::Specification.new do |s|
@@ -654,7 +736,8 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   def new_default_spec(name, version, deps = nil, *files)
-    spec = new_spec(name, version, deps)
+    spec = util_spec name, version, deps
+
     spec.loaded_from = File.join(@default_spec_dir, spec.spec_name)
     spec.files = files
 
@@ -672,24 +755,38 @@ class Gem::TestCase < MiniTest::Unit::TestCase
   end
 
   ##
-  # Creates a spec with +name+, +version+ and +deps+.
+  # Creates a spec with +name+, +version+.  +deps+ can specify the dependency
+  # or a +block+ can be given for full customization of the specification.
 
-  def util_spec(name, version, deps = nil, &block)
-    # TODO: deprecate
-    raise "deps or block, not both" if deps and block
+  def util_spec name, version = 2, deps = nil # :yields: specification
+    raise "deps or block, not both" if deps and block_given?
+
+    spec = Gem::Specification.new do |s|
+      s.platform    = Gem::Platform::RUBY
+      s.name        = name
+      s.version     = version
+      s.author      = 'A User'
+      s.email       = 'example@example.com'
+      s.homepage    = 'http://example.com'
+      s.summary     = "this is a summary"
+      s.description = "This is a test description"
+
+      yield s if block_given?
+    end
 
     if deps then
-      block = proc do |s|
-        # Since Hash#each is unordered in 1.8, sort
-        # the keys and iterate that way so the tests are
-        # deteriminstic on all implementations.
-        deps.keys.sort.each do |n|
-          s.add_dependency n, (deps[n] || '>= 0')
-        end
+      # Since Hash#each is unordered in 1.8, sort the keys and iterate that
+      # way so the tests are deterministic on all implementations.
+      deps.keys.sort.each do |n|
+        spec.add_dependency n, (deps[n] || '>= 0')
       end
     end
 
-    quick_spec(name, version, &block)
+    spec.loaded_from = spec.spec_file
+
+    Gem::Specification.add_spec spec
+
+    return spec
   end
 
   ##
@@ -826,7 +923,7 @@ Also, a list:
   # Set the platform to +arch+
 
   def util_set_arch(arch)
-    Gem::ConfigMap[:arch] = arch
+    RbConfig::CONFIG['arch'] = arch
     platform = Gem::Platform.new arch
 
     Gem.instance_variable_set :@platforms, nil
@@ -898,14 +995,35 @@ Also, a list:
       spec_fetcher.prerelease_specs[@uri] << spec.name_tuple
     end
 
-    v = Gem.marshal_version
+    # HACK for test_download_to_cache
+    unless Gem::RemoteFetcher === @fetcher then
+      v = Gem.marshal_version
+
+      specs = all.map { |spec| spec.name_tuple }
+      s_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic specs
+
+      latest_specs = Gem::Specification.latest_specs.map do |spec|
+        spec.name_tuple
+      end
+
+      l_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic latest_specs
 
-    Gem::Specification.each do |spec|
-      path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
-      data = Marshal.dump spec
-      data_deflate = Zlib::Deflate.deflate data
-      @fetcher.data[path] = data_deflate
-    end unless Gem::RemoteFetcher === @fetcher # HACK for test_download_to_cache
+      prerelease_specs = prerelease.map { |spec| spec.name_tuple }
+      p_zip = util_gzip Marshal.dump Gem::NameTuple.to_basic prerelease_specs
+
+      @fetcher.data["#{@gem_repo}specs.#{v}.gz"]            = s_zip
+      @fetcher.data["#{@gem_repo}latest_specs.#{v}.gz"]     = l_zip
+      @fetcher.data["#{@gem_repo}prerelease_specs.#{v}.gz"] = p_zip
+
+      v = Gem.marshal_version
+
+      Gem::Specification.each do |spec|
+        path = "#{@gem_repo}quick/Marshal.#{v}/#{spec.original_name}.gemspec.rz"
+        data = Marshal.dump spec
+        data_deflate = Zlib::Deflate.deflate data
+        @fetcher.data[path] = data_deflate
+      end
+    end
 
     nil # force errors
   end
@@ -917,6 +1035,37 @@ Also, a list:
     Zlib::Deflate.deflate data
   end
 
+  def util_set_RUBY_VERSION(version, patchlevel = nil, revision = nil)
+    if Gem.instance_variables.include? :@ruby_version or
+       Gem.instance_variables.include? '@ruby_version' then
+      Gem.send :remove_instance_variable, :@ruby_version
+    end
+
+    @RUBY_VERSION    = RUBY_VERSION
+    @RUBY_PATCHLEVEL = RUBY_PATCHLEVEL if defined?(RUBY_PATCHLEVEL)
+    @RUBY_REVISION   = RUBY_REVISION   if defined?(RUBY_REVISION)
+
+    Object.send :remove_const, :RUBY_VERSION
+    Object.send :remove_const, :RUBY_PATCHLEVEL if defined?(RUBY_PATCHLEVEL)
+    Object.send :remove_const, :RUBY_REVISION   if defined?(RUBY_REVISION)
+
+    Object.const_set :RUBY_VERSION,    version
+    Object.const_set :RUBY_PATCHLEVEL, patchlevel if patchlevel
+    Object.const_set :RUBY_REVISION,   revision   if revision
+  end
+
+  def util_restore_RUBY_VERSION
+    Object.send :remove_const, :RUBY_VERSION
+    Object.send :remove_const, :RUBY_PATCHLEVEL if defined?(RUBY_PATCHLEVEL)
+    Object.send :remove_const, :RUBY_REVISION   if defined?(RUBY_REVISION)
+
+    Object.const_set :RUBY_VERSION,    @RUBY_VERSION
+    Object.const_set :RUBY_PATCHLEVEL, @RUBY_PATCHLEVEL if
+      defined?(@RUBY_PATCHLEVEL)
+    Object.const_set :RUBY_REVISION,   @RUBY_REVISION   if
+      defined?(@RUBY_REVISION)
+  end
+
   ##
   # Is this test being run on a Windows platform?
 
@@ -1056,21 +1205,23 @@ Also, a list:
   end
 
   ##
-  # Constructs a Gem::DependencyResolver::DependencyRequest from a
+  # Constructs a Gem::Resolver::DependencyRequest from a
   # Gem::Dependency +dep+, a +from_name+ and +from_version+ requesting the
   # dependency and a +parent+ DependencyRequest
 
   def dependency_request dep, from_name, from_version, parent = nil
     remote = Gem::Source.new @uri
 
-    parent ||= Gem::DependencyResolver::DependencyRequest.new \
-      dep, nil
+    unless parent then
+      parent_dep = dep from_name, from_version
+      parent = Gem::Resolver::DependencyRequest.new parent_dep, nil
+    end
 
-    spec = Gem::DependencyResolver::IndexSpecification.new \
+    spec = Gem::Resolver::IndexSpecification.new \
       nil, from_name, from_version, remote, Gem::Platform::RUBY
-    activation = Gem::DependencyResolver::ActivationRequest.new spec, parent
+    activation = Gem::Resolver::ActivationRequest.new spec, parent
 
-    Gem::DependencyResolver::DependencyRequest.new dep, activation
+    Gem::Resolver::DependencyRequest.new dep, activation
   end
 
   ##
@@ -1089,31 +1240,109 @@ Also, a list:
   end
 
   ##
+  # Creates a SpecFetcher pre-filled with the gems or specs defined in the
+  # block.
+  #
+  # Yields a +fetcher+ object that responds to +spec+ and +gem+.  +spec+ adds
+  # a specification to the SpecFetcher while +gem+ adds both a specification
+  # and the gem data to the RemoteFetcher so the built gem can be downloaded.
+  #
+  # If only the a-3 gem is supposed to be downloaded you can save setup
+  # time by creating only specs for the other versions:
+  #
+  #   spec_fetcher do |fetcher|
+  #     fetcher.spec 'a', 1
+  #     fetcher.spec 'a', 2, 'b' => 3 # dependency on b = 3
+  #     fetcher.gem 'a', 3 do |spec|
+  #       # spec is a Gem::Specification
+  #       # ...
+  #     end
+  #   end
+
+  def spec_fetcher repository = @gem_repo
+    Gem::TestCase::SpecFetcherSetup.declare self, repository do |spec_fetcher_setup|
+      yield spec_fetcher_setup if block_given?
+    end
+  end
+
+  ##
   # Construct a new Gem::Version.
 
   def v string
     Gem::Version.create string
   end
 
-  class StaticSet
+  ##
+  # A vendor_gem is used with a gem dependencies file.  The gem created here
+  # has no files, just a gem specification for the given +name+ and +version+.
+  #
+  # Yields the +specification+ to the block, if given
+
+  def vendor_gem name = 'a', version = 1
+    directory = File.join 'vendor', name
+
+    vendor_spec = Gem::Specification.new name, version do |specification|
+      yield specification if block_given?
+    end
+
+    FileUtils.mkdir_p directory
+
+    open File.join(directory, "#{name}.gemspec"), 'w' do |io|
+      io.write vendor_spec.to_ruby
+    end
+
+    return name, vendor_spec.version, directory
+  end
+
+  ##
+  # The StaticSet is a static set of gem specifications used for testing only.
+  # It is available by requiring Gem::TestCase.
+
+  class StaticSet < Gem::Resolver::Set
+
+    ##
+    # A StaticSet ignores remote because it has a fixed set of gems.
+
+    attr_accessor :remote
+
+    ##
+    # Creates a new StaticSet for the given +specs+
+
     def initialize(specs)
+      super()
+
       @specs = specs
+
+      @remote = true
     end
 
+    ##
+    # Adds +spec+ to this set.
+
     def add spec
       @specs << spec
     end
 
+    ##
+    # Finds +dep+ in this set.
+
     def find_spec(dep)
       @specs.reverse_each do |s|
         return s if dep.matches_spec? s
       end
     end
 
+    ##
+    # Finds all gems matching +dep+ in this set.
+
     def find_all(dep)
-      @specs.find_all { |s| dep.matches_spec? s }
+      @specs.find_all { |s| dep.match? s, @prerelease }
     end
 
+    ##
+    # Loads a Gem::Specification from this set which has the given +name+,
+    # version +ver+, +platform+.  The +source+ is ignored.
+
     def load_spec name, ver, platform, source
       dep = Gem::Dependency.new name, ver
       spec = find_spec dep
@@ -1123,7 +1352,7 @@ Also, a list:
       end
     end
 
-    def prefetch(reqs)
+    def prefetch reqs # :nodoc:
     end
   end
 
@@ -1196,3 +1425,23 @@ Also, a list:
   end if defined?(OpenSSL::SSL)
 
 end
+
+# require dependencies that are not discoverable once GEM_HOME and GEM_PATH
+# are wiped
+begin
+  gem 'rake'
+rescue Gem::LoadError
+end
+
+require 'rake/packagetask'
+
+begin
+  gem 'rdoc'
+  require 'rdoc'
+rescue LoadError, Gem::LoadError
+end
+
+require 'rubygems/test_utilities'
+ENV['GEM_HOME'] = Dir.mktmpdir "home"
+ENV['GEM_PATH'] = Dir.mktmpdir "path"
+Gem.clear_paths
diff --git a/jruby/lib/ruby/shared/rubygems/test_utilities.rb b/jruby/lib/ruby/shared/rubygems/test_utilities.rb
index eed42f5..25786e6 100644
--- a/jruby/lib/ruby/shared/rubygems/test_utilities.rb
+++ b/jruby/lib/ruby/shared/rubygems/test_utilities.rb
@@ -38,6 +38,8 @@ class Gem::FakeFetcher
   end
 
   def find_data(path)
+    return File.read path.path if URI === path and 'file' == path.scheme
+
     if URI === path and "URI::#{path.scheme.upcase}" != path.class.name then
       raise ArgumentError,
         "mismatch for scheme #{path.scheme} and class #{path.class}"
@@ -101,6 +103,24 @@ class Gem::FakeFetcher
     response
   end
 
+  def pretty_print q # :nodoc:
+    q.group 2, '[FakeFetcher', ']' do
+      q.breakable
+      q.text 'URIs:'
+
+      q.breakable
+      q.pp @data.keys
+
+      unless @api_endpoints.empty? then
+        q.breakable
+        q.text 'API endpoints:'
+
+        q.breakable
+        q.pp @api_endpoints.keys
+      end
+    end
+  end
+
   def fetch_size(path)
     path = path.to_s
     @paths << path
@@ -160,6 +180,179 @@ end
 # :startdoc:
 
 ##
+# The SpecFetcherSetup allows easy setup of a remote source in RubyGems tests:
+#
+#   spec_fetcher do |f|
+#     f.gem  'a', 1
+#     f.spec 'a', 2
+#     f.gem  'b', 1' 'a' => '~> 1.0'
+#     f.clear
+#   end
+#
+# The above declaration creates two gems, a-1 and b-1, with a dependency from
+# b to a.  The declaration creates an additional spec a-2, but no gem for it
+# (so it cannot be installed).
+#
+# After the gems are created they are removed from Gem.dir.
+
+class Gem::TestCase::SpecFetcherSetup
+
+  ##
+  # Executes a SpecFetcher setup block.  Yields an instance then creates the
+  # gems and specifications defined in the instance.
+
+  def self.declare test, repository
+    setup = new test, repository
+
+    yield setup
+
+    setup.execute
+  end
+
+  def initialize test, repository # :nodoc:
+    @test       = test
+    @repository = repository
+
+    @gems       = {}
+    @installed  = []
+    @operations = []
+  end
+
+  ##
+  # Removes any created gems or specifications from Gem.dir (the default
+  # install location).
+
+  def clear
+    @operations << [:clear]
+  end
+
+  ##
+  # Returns a Hash of created Specification full names and the corresponding
+  # Specification.
+
+  def created_specs
+    created = {}
+
+    @gems.keys.each do |spec|
+      created[spec.full_name] = spec
+    end
+
+    created
+  end
+
+  ##
+  # Creates any defined gems or specifications
+
+  def execute # :nodoc:
+    execute_operations
+
+    setup_fetcher
+
+    created_specs
+  end
+
+  def execute_operations # :nodoc:
+    @operations.each do |operation, *arguments|
+      case operation
+      when :clear then
+        @test.util_clear_gems
+        @installed.clear
+      when :gem then
+        spec, gem = @test.util_gem(*arguments, &arguments.pop)
+
+        write_spec spec
+
+        @gems[spec] = gem
+        @installed << spec
+      when :spec then
+        spec = @test.util_spec(*arguments, &arguments.pop)
+
+        write_spec spec
+
+        @gems[spec] = nil
+        @installed << spec
+      end
+    end
+  end
+
+  ##
+  # Creates a gem with +name+, +version+ and +deps+.  The created gem can be
+  # downloaded and installed.
+  #
+  # The specification will be yielded before gem creation for customization,
+  # but only the block or the dependencies may be set, not both.
+
+  def gem name, version, dependencies = nil, &block
+    @operations << [:gem, name, version, dependencies, block]
+  end
+
+  ##
+  # Creates a legacy platform spec with the name 'pl' and version 1
+
+  def legacy_platform
+    spec 'pl', 1 do |s|
+      s.platform = Gem::Platform.new 'i386-linux'
+      s.instance_variable_set :@original_platform, 'i386-linux'
+    end
+  end
+
+  def setup_fetcher # :nodoc:
+    require 'zlib'
+    require 'socket'
+    require 'rubygems/remote_fetcher'
+
+    unless @test.fetcher then
+      @test.fetcher = Gem::FakeFetcher.new
+      Gem::RemoteFetcher.fetcher = @test.fetcher
+    end
+
+    Gem::Specification.reset
+
+    begin
+      gem_repo, @test.gem_repo = @test.gem_repo, @repository
+      @test.uri = URI @repository
+
+      @test.util_setup_spec_fetcher(*@gems.keys)
+    ensure
+      @test.gem_repo = gem_repo
+      @test.uri = URI gem_repo
+    end
+
+    # This works around util_setup_spec_fetcher adding all created gems to the
+    # installed set.
+    Gem::Specification.reset
+    Gem::Specification.add_specs(*@installed)
+
+    @gems.each do |spec, gem|
+      next unless gem
+
+      @test.fetcher.data["#{@repository}gems/#{spec.file_name}"] =
+        Gem.read_binary(gem)
+
+      FileUtils.cp gem, spec.cache_file
+    end
+  end
+
+  ##
+  # Creates a spec with +name+, +version+ and +deps+.  The created gem can be
+  # downloaded and installed.
+  #
+  # The specification will be yielded before creation for customization,
+  # but only the block or the dependencies may be set, not both.
+
+  def spec name, version, dependencies = nil, &block
+    @operations << [:spec, name, version, dependencies, block]
+  end
+
+  def write_spec spec # :nodoc:
+    open spec.spec_file, 'w' do |io|
+      io.write spec.to_ruby_for_cache
+    end
+  end
+
+end
+
+##
 # A StringIO duck-typed class that uses Tempfile instead of String as the
 # backing store.
 #
@@ -168,6 +361,10 @@ end
 # This class was added to flush out problems in Rubinius' IO implementation.
 
 class TempIO < Tempfile
+
+  ##
+  # Creates a new TempIO that will be initialized to contain +string+.
+
   def initialize(string = '')
     super "TempIO"
     binmode
@@ -175,6 +372,9 @@ class TempIO < Tempfile
     rewind
   end
 
+  ##
+  # The content of the TempIO as a String.
+
   def string
     flush
     Gem.read_binary path
diff --git a/jruby/lib/ruby/shared/rubygems/text.rb b/jruby/lib/ruby/shared/rubygems/text.rb
index 793cd95..5c9287a 100644
--- a/jruby/lib/ruby/shared/rubygems/text.rb
+++ b/jruby/lib/ruby/shared/rubygems/text.rb
@@ -26,6 +26,16 @@ module Gem::Text
     result.join("\n").gsub(/^/, " " * indent)
   end
 
+  def min3 a, b, c # :nodoc:
+    if a < b && a < c then
+      a
+    elsif b < c then
+      b
+    else
+      c
+    end
+  end
+
   # This code is based directly on the Text gem implementation
   # Returns a value representing the "cost" of transforming str1 into str2
   def levenshtein_distance str1, str2
@@ -42,16 +52,16 @@ module Gem::Text
     d = (0..m).to_a
     x = nil
 
-    n.times do |i|
+    str1.each_char.each_with_index do |char1,i|
       e = i+1
 
-      m.times do |j|
-        cost = (s[i] == t[j]) ? 0 : 1
-        x = [
+      str2.each_char.each_with_index do |char2,j|
+        cost = (char1 == char2) ? 0 : 1
+        x = min3(
              d[j+1] + 1, # insertion
              e + 1,      # deletion
              d[j] + cost # substitution
-            ].min
+            )
         d[j] = e
         e = x
       end
diff --git a/jruby/lib/ruby/shared/rubygems/uninstaller.rb b/jruby/lib/ruby/shared/rubygems/uninstaller.rb
index 143ab6d..2a6edc6 100644
--- a/jruby/lib/ruby/shared/rubygems/uninstaller.rb
+++ b/jruby/lib/ruby/shared/rubygems/uninstaller.rb
@@ -96,6 +96,8 @@ class Gem::Uninstaller
         (@user_install and spec.base_dir == Gem.user_dir)
     end
 
+    list.sort!
+
     if list.empty? then
       if other_repo_specs.empty?
         if default_specs.empty?
@@ -120,7 +122,8 @@ class Gem::Uninstaller
       remove_all list
 
     elsif list.size > 1 then
-      gem_names = list.collect {|gem| gem.full_name} + ["All versions"]
+      gem_names = list.map { |gem| gem.full_name }
+      gem_names << "All versions"
 
       say
       _, index = choose_from_list "Select gem to uninstall:", gem_names
@@ -237,7 +240,7 @@ class Gem::Uninstaller
     unless path_ok?(@gem_home, spec) or
            (@user_install and path_ok?(Gem.user_dir, spec)) then
       e = Gem::GemNotInHomeException.new \
-            "Gem is not installed in directory #{@gem_home}"
+            "Gem '#{spec.full_name}' is not installed in directory #{@gem_home}"
       e.spec = spec
 
       raise e
@@ -247,13 +250,10 @@ class Gem::Uninstaller
       File.writable?(spec.base_dir)
 
     FileUtils.rm_rf spec.full_gem_path
+    FileUtils.rm_rf spec.extension_dir
 
-    # TODO: should this be moved to spec?... I vote eww (also exists in docmgr)
-    old_platform_name = [spec.name,
-                         spec.version,
-                         spec.original_platform].join '-'
-
-    gemspec = spec.spec_file
+    old_platform_name = spec.original_name
+    gemspec           = spec.spec_file
 
     unless File.exist? gemspec then
       gemspec = File.join(File.dirname(gemspec), "#{old_platform_name}.gemspec")
@@ -284,18 +284,30 @@ class Gem::Uninstaller
     full_path == spec.full_gem_path || original_path == spec.full_gem_path
   end
 
-  def dependencies_ok?(spec)
+  ##
+  # Returns true if it is OK to remove +spec+ or this is a forced
+  # uninstallation.
+
+  def dependencies_ok? spec # :nodoc:
     return true if @force_ignore
 
     deplist = Gem::DependencyList.from_specs
     deplist.ok_to_remove?(spec.full_name, @check_dev)
   end
 
-  def abort_on_dependent?
+  ##
+  # Should the uninstallation abort if a dependency will go unsatisfied?
+  #
+  # See ::new.
+
+  def abort_on_dependent? # :nodoc:
     @abort_on_dependent
   end
 
-  def ask_if_ok(spec)
+  ##
+  # Asks if it is OK to remove +spec+.  Returns true if it is OK.
+
+  def ask_if_ok spec # :nodoc:
     msg = ['']
     msg << 'You have requested to uninstall the gem:'
     msg << "\t#{spec.full_name}"
@@ -316,7 +328,10 @@ class Gem::Uninstaller
     return ask_yes_no(msg.join("\n"), false)
   end
 
-  def formatted_program_filename(filename)
+  ##
+  # Returns the formatted version of the executable +filename+
+
+  def formatted_program_filename filename # :nodoc:
     # TODO perhaps the installer should leave a small manifest
     # of what it did for us to find rather than trying to recreate
     # it again.
diff --git a/jruby/lib/ruby/shared/rubygems/uri_formatter.rb b/jruby/lib/ruby/shared/rubygems/uri_formatter.rb
index 935d9b5..68aacc6 100644
--- a/jruby/lib/ruby/shared/rubygems/uri_formatter.rb
+++ b/jruby/lib/ruby/shared/rubygems/uri_formatter.rb
@@ -1,13 +1,30 @@
 require 'cgi'
 require 'uri'
 
+##
+# The UriFormatter handles URIs from user-input and escaping.
+#
+#   uf = Gem::UriFormatter.new 'example.com'
+#
+#   p uf.normalize #=> 'http://example.com'
+
 class Gem::UriFormatter
+
+  ##
+  # The URI to be formatted.
+
   attr_reader :uri
 
+  ##
+  # Creates a new URI formatter for +uri+.
+
   def initialize uri
     @uri = uri
   end
 
+  ##
+  # Escapes the #uri for use as a CGI parameter
+
   def escape
     return unless @uri
     CGI.escape @uri
@@ -20,6 +37,9 @@ class Gem::UriFormatter
     (@uri =~ /^(https?|ftp|file):/i) ? @uri : "http://#{@uri}"
   end
 
+  ##
+  # Unescapes the #uri which came from a CGI parameter
+
   def unescape
     return unless @uri
     CGI.unescape @uri
diff --git a/jruby/lib/ruby/shared/rubygems/user_interaction.rb b/jruby/lib/ruby/shared/rubygems/user_interaction.rb
index 0974476..78d3790 100644
--- a/jruby/lib/ruby/shared/rubygems/user_interaction.rb
+++ b/jruby/lib/ruby/shared/rubygems/user_interaction.rb
@@ -4,6 +4,11 @@
 # See LICENSE.txt for permissions.
 #++
 
+begin
+  require 'io/console'
+rescue LoadError
+end
+
 ##
 # Module that defines the default UserInteraction.  Any class including this
 # module will have access to the +ui+ method that returns the default UI.
@@ -66,9 +71,13 @@ module Gem::DefaultUserInteraction
 end
 
 ##
-# Make the default UI accessible without the "ui." prefix.  Classes
-# including this module may use the interaction methods on the default UI
-# directly.  Classes may also reference the ui and ui= methods.
+# UserInteraction allows RubyGems to interact with the user through standard
+# methods that can be replaced with more-specific UI methods for different
+# displays.
+#
+# Since UserInteraction dispatches to a concrete UI class you may need to
+# reference other classes for specific behavior such as Gem::ConsoleUI or
+# Gem::SilentUI.
 #
 # Example:
 #
@@ -84,40 +93,77 @@ module Gem::UserInteraction
 
   include Gem::DefaultUserInteraction
 
-  def alert(*args)
-    ui.alert(*args)
+  ##
+  # Displays an alert +statement+.  Asks a +question+ if given.
+
+  def alert statement, question = nil
+    ui.alert statement, question
   end
 
-  def alert_error(*args)
-    ui.alert_error(*args)
+  ##
+  # Displays an error +statement+ to the error output location.  Asks a
+  # +question+ if given.
+
+  def alert_error statement, question = nil
+    ui.alert_error statement, question
   end
 
-  def alert_warning(*args)
-    ui.alert_warning(*args)
+  ##
+  # Displays a warning +statement+ to the warning output location.  Asks a
+  # +question+ if given.
+
+  def alert_warning statement, question = nil
+    ui.alert_warning statement, question
   end
 
-  def ask(*args)
-    ui.ask(*args)
+  ##
+  # Asks a +question+ and returns the answer.
+
+  def ask question
+    ui.ask question
+  end
+
+  ##
+  # Asks for a password with a +prompt+
+
+  def ask_for_password prompt
+    ui.ask_for_password prompt
   end
 
-  def ask_for_password(*args)
-    ui.ask_for_password(*args)
+  ##
+  # Asks a yes or no +question+.  Returns true for yes, false for no.
+
+  def ask_yes_no question, default = nil
+    ui.ask_yes_no question, default
   end
 
-  def ask_yes_no(*args)
-    ui.ask_yes_no(*args)
+  ##
+  # Asks the user to answer +question+ with an answer from the given +list+.
+
+  def choose_from_list question, list
+    ui.choose_from_list question, list
   end
 
-  def choose_from_list(*args)
-    ui.choose_from_list(*args)
+  ##
+  # Displays the given +statement+ on the standard output (or equivalent).
+
+  def say statement = ''
+    ui.say statement
   end
 
-  def say(*args)
-    ui.say(*args)
+  ##
+  # Terminates the RubyGems process with the given +exit_code+
+
+  def terminate_interaction exit_code = 0
+    ui.terminate_interaction exit_code
   end
 
-  def terminate_interaction(*args)
-    ui.terminate_interaction(*args)
+  ##
+  # Calls +say+ with +msg+ or the results of the block if really_verbose
+  # is true.
+
+  def verbose msg = nil
+    say(msg || yield) if Gem.configuration.really_verbose
   end
 end
 
@@ -126,7 +172,26 @@ end
 
 class Gem::StreamUI
 
-  attr_reader :ins, :outs, :errs
+  ##
+  # The input stream
+
+  attr_reader :ins
+
+  ##
+  # The output stream
+
+  attr_reader :outs
+
+  ##
+  # The error stream
+
+  attr_reader :errs
+
+  ##
+  # Creates a new StreamUI wrapping +in_stream+ for user input, +out_stream+
+  # for standard output, +err_stream+ for error output.  If +usetty+ is true
+  # then special operations (like asking for passwords) will use the TTY
+  # commands to disable character echo.
 
   def initialize(in_stream, out_stream, err_stream=STDERR, usetty=true)
     @ins = in_stream
@@ -135,6 +200,9 @@ class Gem::StreamUI
     @usetty = usetty
   end
 
+  ##
+  # Returns true if TTY methods should be used on this StreamUI.
+
   def tty?
     if RUBY_VERSION < '1.9.3' and RUBY_PLATFORM =~ /mingw|mswin/ then
       @usetty
@@ -228,43 +296,28 @@ class Gem::StreamUI
     result
   end
 
-  if RUBY_VERSION > '1.9.2' then
-    ##
-    # Ask for a password. Does not echo response to terminal.
-
-    def ask_for_password(question)
-      return nil if not tty?
-
-      require 'io/console'
-
-      @outs.print(question + "  ")
-      @outs.flush
+  ##
+  # Ask for a password. Does not echo response to terminal.
 
-      password = @ins.noecho {@ins.gets}
-      password.chomp! if password
-      password
-    end
-  else
-    ##
-    # Ask for a password. Does not echo response to terminal.
+  def ask_for_password(question)
+    return nil if not tty?
 
-    def ask_for_password(question)
-      return nil if not tty?
+    @outs.print(question, "  ")
+    @outs.flush
 
-      @outs.print(question + "  ")
-      @outs.flush
+    password = _gets_noecho
+    @outs.puts
+    password.chomp! if password
+    password
+  end
 
-      Gem.win_platform? ? ask_for_password_on_windows : ask_for_password_on_unix
+  if IO.method_defined?(:noecho) then
+    def _gets_noecho
+      @ins.noecho {@ins.gets}
     end
-
-    ##
-    # Asks for a password that works on windows. Ripped from the Heroku gem.
-
-    def ask_for_password_on_windows
-      return nil if not tty?
-
+  elsif Gem.win_platform?
+    def _gets_noecho
       require "Win32API"
-      char = nil
       password = ''
 
       while char = Win32API.new("crtdll", "_getch", [ ], "L").Call do
@@ -275,22 +328,16 @@ class Gem::StreamUI
           password << char.chr
         end
       end
-
-      puts
       password
     end
-
-    ##
-    # Asks for a password that works on unix
-
-    def ask_for_password_on_unix
-      return nil if not tty?
-
+  else
+    def _gets_noecho
       system "stty -echo"
-      password = @ins.gets
-      password.chomp! if password
-      system "stty echo"
-      password
+      begin
+        @ins.gets
+      ensure
+        system "stty echo"
+      end
     end
   end
 
@@ -310,8 +357,7 @@ class Gem::StreamUI
   end
 
   ##
-  # Display a warning in a location expected to get error messages.  Will
-  # ask +question+ if it is not nil.
+  # Display a warning on stderr.  Will ask +question+ if it is not nil.
 
   def alert_warning(statement, question=nil)
     @errs.puts "WARNING:  #{statement}"
@@ -339,17 +385,17 @@ class Gem::StreamUI
   # handlers that might have been defined.
 
   def terminate_interaction(status = 0)
+    close
     raise Gem::SystemExitException, status
   end
 
+  def close
+  end
+
   ##
   # Return a progress reporter object chosen from the current verbosity.
 
   def progress_reporter(*args)
-    if self.kind_of?(Gem::SilentUI)
-      return SilentProgressReporter.new(@outs, *args)
-    end
-
     case Gem.configuration.verbose
     when nil, false
       SilentProgressReporter.new(@outs, *args)
@@ -364,14 +410,29 @@ class Gem::StreamUI
   # An absolutely silent progress reporter.
 
   class SilentProgressReporter
+
+    ##
+    # The count of items is never updated for the silent progress reporter.
+
     attr_reader :count
 
+    ##
+    # Creates a silent progress reporter that ignores all input arguments.
+
     def initialize(out_stream, size, initial_message, terminal_message = nil)
     end
 
+    ##
+    # Does not print +message+ when updated as this object has taken a vow of
+    # silence.
+
     def updated(message)
     end
 
+    ##
+    # Does not print anything when complete as this object has taken a vow of
+    # silence.
+
     def done
     end
   end
@@ -383,8 +444,16 @@ class Gem::StreamUI
 
     include Gem::DefaultUserInteraction
 
+    ##
+    # The number of progress items counted so far.
+
     attr_reader :count
 
+    ##
+    # Creates a new progress reporter that will write to +out_stream+ for
+    # +size+ items.  Shows the given +initial_message+ when progress starts
+    # and the +terminal_message+ when it is complete.
+
     def initialize(out_stream, size, initial_message,
                    terminal_message = "complete")
       @out = out_stream
@@ -420,8 +489,16 @@ class Gem::StreamUI
 
     include Gem::DefaultUserInteraction
 
+    ##
+    # The number of progress items counted so far.
+
     attr_reader :count
 
+    ##
+    # Creates a new progress reporter that will write to +out_stream+ for
+    # +size+ items.  Shows the given +initial_message+ when progress starts
+    # and the +terminal_message+ when it is complete.
+
     def initialize(out_stream, size, initial_message,
                    terminal_message = 'complete')
       @out = out_stream
@@ -452,10 +529,6 @@ class Gem::StreamUI
   # Return a download reporter object chosen from the current verbosity
 
   def download_reporter(*args)
-    if self.kind_of?(Gem::SilentUI)
-      return SilentDownloadReporter.new(@outs, *args)
-    end
-
     case Gem.configuration.verbose
     when nil, false
       SilentDownloadReporter.new(@outs, *args)
@@ -468,15 +541,30 @@ class Gem::StreamUI
   # An absolutely silent download reporter.
 
   class SilentDownloadReporter
+
+    ##
+    # The silent download reporter ignores all arguments
+
     def initialize(out_stream, *args)
     end
 
+    ##
+    # The silent download reporter does not display +filename+ or care about
+    # +filesize+ because it is silent.
+
     def fetch(filename, filesize)
     end
 
+    ##
+    # Nothing can update the silent download reporter.
+
     def update(current)
     end
 
+    ##
+    # The silent download reporter won't tell you when the download is done.
+    # Because it is silent.
+
     def done
     end
   end
@@ -485,13 +573,35 @@ class Gem::StreamUI
   # A progress reporter that prints out messages about the current progress.
 
   class VerboseDownloadReporter
-    attr_reader :file_name, :total_bytes, :progress
+
+    ##
+    # The current file name being displayed
+
+    attr_reader :file_name
+
+    ##
+    # The total bytes in the file
+
+    attr_reader :total_bytes
+
+    ##
+    # The current progress (0 to 100)
+
+    attr_reader :progress
+
+    ##
+    # Creates a new verbose download reporter that will display on
+    # +out_stream+.  The other arguments are ignored.
 
     def initialize(out_stream, *args)
       @out = out_stream
       @progress = 0
     end
 
+    ##
+    # Tells the download reporter that the +file_name+ is being fetched and
+    # contains +total_bytes+.
+
     def fetch(file_name, total_bytes)
       @file_name = file_name
       @total_bytes = total_bytes.to_i
@@ -500,6 +610,9 @@ class Gem::StreamUI
       update_display(false)
     end
 
+    ##
+    # Updates the verbose download reporter for the given number of +bytes+.
+
     def update(bytes)
       new_progress = if @units == 'B' then
                        bytes
@@ -513,6 +626,9 @@ class Gem::StreamUI
       update_display
     end
 
+    ##
+    # Indicates the download is complete.
+
     def done
       @progress = 100 if @units == '%'
       update_display(true, true)
@@ -520,7 +636,7 @@ class Gem::StreamUI
 
     private
 
-    def update_display(show_progress = true, new_line = false)
+    def update_display(show_progress = true, new_line = false) # :nodoc:
       return unless @out.tty?
 
       if show_progress then
@@ -538,6 +654,11 @@ end
 # STDOUT, and STDERR.
 
 class Gem::ConsoleUI < Gem::StreamUI
+
+  ##
+  # The Console UI has no arguments as it defaults to reading input from
+  # stdin, output to stdout and warnings or errors to stderr.
+
   def initialize
     super STDIN, STDOUT, STDERR, true
   end
@@ -547,6 +668,10 @@ end
 # SilentUI is a UI choice that is absolutely silent.
 
 class Gem::SilentUI < Gem::StreamUI
+
+  ##
+  # The SilentUI has no arguments as it does not use any stream.
+
   def initialize
     reader, writer = nil, nil
 
@@ -561,11 +686,17 @@ class Gem::SilentUI < Gem::StreamUI
     super reader, writer, writer, false
   end
 
-  def download_reporter(*args)
+  def close
+    super
+    @ins.close
+    @outs.close
+  end
+
+  def download_reporter(*args) # :nodoc:
     SilentDownloadReporter.new(@outs, *args)
   end
 
-  def progress_reporter(*args)
+  def progress_reporter(*args) # :nodoc:
     SilentProgressReporter.new(@outs, *args)
   end
 end
diff --git a/jruby/lib/ruby/shared/rubygems/util.rb b/jruby/lib/ruby/shared/rubygems/util.rb
new file mode 100644
index 0000000..cd0af4d
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/util.rb
@@ -0,0 +1,134 @@
+##
+# This module contains various utility methods as module methods.
+
+module Gem::Util
+
+  @silent_mutex = nil
+
+  ##
+  # Zlib::GzipReader wrapper that unzips +data+.
+
+  def self.gunzip(data)
+    require 'zlib'
+    require 'rubygems/util/stringio'
+    data = Gem::StringSource.new data
+
+    unzipped = Zlib::GzipReader.new(data).read
+    unzipped.force_encoding Encoding::BINARY if Object.const_defined? :Encoding
+    unzipped
+  end
+
+  ##
+  # Zlib::GzipWriter wrapper that zips +data+.
+
+  def self.gzip(data)
+    require 'zlib'
+    require 'rubygems/util/stringio'
+    zipped = Gem::StringSink.new
+    zipped.set_encoding Encoding::BINARY if Object.const_defined? :Encoding
+
+    Zlib::GzipWriter.wrap zipped do |io| io.write data end
+
+    zipped.string
+  end
+
+  ##
+  # A Zlib::Inflate#inflate wrapper
+
+  def self.inflate(data)
+    require 'zlib'
+    Zlib::Inflate.inflate data
+  end
+
+  ##
+  # This calls IO.popen where it accepts an array for a +command+ (Ruby 1.9+)
+  # and implements an IO.popen-like behavior where it does not accept an array
+  # for a command.
+
+  def self.popen *command
+    IO.popen command, &:read
+  rescue TypeError # ruby 1.8 only supports string command
+    r, w = IO.pipe
+
+    pid = fork do
+      STDIN.close
+      STDOUT.reopen w
+
+      exec(*command)
+    end
+
+    w.close
+
+    begin
+      return r.read
+    ensure
+      Process.wait pid
+    end
+  end
+
+  NULL_DEVICE = defined?(IO::NULL) ? IO::NULL : Gem.win_platform? ? 'NUL' : '/dev/null'
+
+  ##
+  # Invokes system, but silences all output.
+
+  def self.silent_system *command
+    opt = {:out => NULL_DEVICE, :err => [:child, :out]}
+    if Hash === command.last
+      opt.update(command.last)
+      cmds = command[0...-1]
+    else
+      cmds = command.dup
+    end
+    return system(*(cmds << opt))
+  rescue TypeError
+    require 'thread'
+
+    @silent_mutex ||= Mutex.new
+
+    null_device = NULL_DEVICE
+
+    @silent_mutex.synchronize do
+      begin
+        stdout = STDOUT.dup
+        stderr = STDERR.dup
+
+        STDOUT.reopen null_device, 'w'
+        STDERR.reopen null_device, 'w'
+
+        return system(*command)
+      ensure
+        STDOUT.reopen stdout
+        STDERR.reopen stderr
+        stdout.close
+        stderr.close
+      end
+    end
+  end
+
+  ##
+  # Enumerates the parents of +directory+.
+
+  def self.traverse_parents directory
+    return enum_for __method__, directory unless block_given?
+
+    here = File.expand_path directory
+    start = here
+
+    Dir.chdir start
+
+    begin
+      loop do
+        yield here
+
+        Dir.chdir '..'
+
+        return if Dir.pwd == here # toplevel
+
+        here = Dir.pwd
+      end
+    ensure
+      Dir.chdir start
+    end
+  end
+
+end
diff --git a/jruby/lib/ruby/shared/rubygems/util/list.rb b/jruby/lib/ruby/shared/rubygems/util/list.rb
index 9f540ad..9bc11fe 100644
--- a/jruby/lib/ruby/shared/rubygems/util/list.rb
+++ b/jruby/lib/ruby/shared/rubygems/util/list.rb
@@ -36,6 +36,10 @@ module Gem
       List.new value, self
     end
 
+    def pretty_print q # :nodoc:
+      q.pp to_a
+    end
+
     def self.prepend(list, value)
       return List.new(value) unless list
       List.new value, list
diff --git a/jruby/lib/ruby/shared/rubygems/util/stringio.rb b/jruby/lib/ruby/shared/rubygems/util/stringio.rb
new file mode 100644
index 0000000..2ea6961
--- /dev/null
+++ b/jruby/lib/ruby/shared/rubygems/util/stringio.rb
@@ -0,0 +1,34 @@
+class Gem::StringSink
+  def initialize
+    @string = ""
+  end
+
+  attr_reader :string
+
+  def write(s)
+    @string += s
+    s.size
+  end
+
+  def set_encoding(enc)
+    @string.force_encoding enc
+  end
+end
+
+class Gem::StringSource
+  def initialize(str)
+    @string = str.dup
+  end
+
+  def read(count=nil)
+    if count
+      @string.slice!(0,count)
+    else
+      s = @string
+      @string = ""
+      s
+    end
+  end
+
+  alias_method :readpartial, :read
+end
diff --git a/jruby/lib/ruby/shared/rubygems/validator.rb b/jruby/lib/ruby/shared/rubygems/validator.rb
index e5183d4..6992af1 100644
--- a/jruby/lib/ruby/shared/rubygems/validator.rb
+++ b/jruby/lib/ruby/shared/rubygems/validator.rb
@@ -14,7 +14,7 @@ class Gem::Validator
 
   include Gem::UserInteraction
 
-  def initialize
+  def initialize # :nodoc:
     require 'find'
   end
 
@@ -57,8 +57,11 @@ class Gem::Validator
 
   public
 
+  ##
+  # Describes a problem with a file in a gem.
+
   ErrorData = Struct.new :path, :problem do
-    def <=> other
+    def <=> other # :nodoc:
       return nil unless self.class === other
 
       [path, problem] <=> [other.path, other.problem]
@@ -83,6 +86,7 @@ class Gem::Validator
 
     Gem::Specification.each do |spec|
       next unless gems.include? spec.name unless gems.empty?
+      next if spec.default_gem?
 
       gem_name      = spec.file_name
       gem_path      = spec.cache_file
diff --git a/jruby/lib/ruby/shared/rubygems/version.rb b/jruby/lib/ruby/shared/rubygems/version.rb
index 2ee887e..8335ebe 100644
--- a/jruby/lib/ruby/shared/rubygems/version.rb
+++ b/jruby/lib/ruby/shared/rubygems/version.rb
@@ -22,6 +22,11 @@
 # 3. 1.0.a.2
 # 4. 0.9
 #
+# If you want to specify a version restriction that includes both prereleases
+# and regular releases of the 1.x series this is the best way:
+#
+#   s.add_dependency 'example', '>= 1.0.0.a', '< 2.0.0'
+#
 # == How Software Changes
 #
 # Users expect to be able to specify a version constraint that gives them
@@ -81,8 +86,8 @@
 #
 # * Any "public" release of a gem should have a different version.  Normally
 #   that means incrementing the build number.  This means a developer can
-#   generate builds all day long for himself, but as soon as he/she makes a
-#   public release, the version must be updated.
+#   generate builds all day long, but as soon as they make a public release,
+#   the version must be updated.
 #
 # === Examples
 #
@@ -99,26 +104,25 @@
 # Version 1.1.1:: Fixed a bug in the linked list implementation.
 # Version 1.1.2:: Fixed a bug introduced in the last fix.
 #
-# Client A needs a stack with basic push/pop capability.  He writes to the
-# original interface (no <tt>top</tt>), so his version constraint looks
-# like:
+# Client A needs a stack with basic push/pop capability.  They write to the
+# original interface (no <tt>top</tt>), so their version constraint looks like:
 #
 #   gem 'stack', '~> 0.0'
 #
 # Essentially, any version is OK with Client A.  An incompatible change to
-# the library will cause him grief, but he is willing to take the chance (we
-# call Client A optimistic).
+# the library will cause them grief, but they are willing to take the chance
+# (we call Client A optimistic).
 #
-# Client B is just like Client A except for two things: (1) He uses the
-# <tt>depth</tt> method and (2) he is worried about future
-# incompatibilities, so he writes his version constraint like this:
+# Client B is just like Client A except for two things: (1) They use the
+# <tt>depth</tt> method and (2) they are worried about future
+# incompatibilities, so they write their version constraint like this:
 #
 #   gem 'stack', '~> 0.1'
 #
 # The <tt>depth</tt> method was introduced in version 0.1.0, so that version
 # or anything later is fine, as long as the version stays below version 1.0
 # where incompatibilities are introduced.  We call Client B pessimistic
-# because he is worried about incompatible future changes (it is OK to be
+# because they are worried about incompatible future changes (it is OK to be
 # pessimistic!).
 #
 # == Preventing Version Catastrophe:
@@ -139,14 +143,16 @@
 #   "~> 3.0.0"    3.0.0 ... 3.1
 #   "~> 3.5"      3.5   ... 4.0
 #   "~> 3.5.0"    3.5.0 ... 3.6
+#   "~> 3"        3.0   ... 4.0
+#
+# For the last example, single-digit versions are automatically extended with
+# a zero to give a sensible result.
 
 class Gem::Version
   autoload :Requirement, 'rubygems/requirement'
 
   include Comparable
 
-  # FIX: These are only used once, in .correct?. Do they deserve to be
-  # constants?
   VERSION_PATTERN = '[0-9]+(?>\.[0-9a-zA-Z]+)*(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?' # :nodoc:
   ANCHORED_VERSION_PATTERN = /\A\s*(#{VERSION_PATTERN})?\s*\z/ # :nodoc:
 
@@ -174,10 +180,8 @@ class Gem::Version
   #   ver2 = Version.create(ver1)       # -> (ver1)
   #   ver3 = Version.create(nil)        # -> nil
 
-  # REFACTOR: There's no real reason this should be separate from #initialize.
-
   def self.create input
-    if input.respond_to? :version then
+    if self === input then # check yourself before you wreck yourself
       input
     elsif input.nil? then
       nil
@@ -188,7 +192,9 @@ class Gem::Version
 
   @@all = {}
 
-  def self.new version
+  def self.new version # :nodoc:
+    return super unless Gem::Version == self
+
     @@all[version] ||= super
   end
 
@@ -255,17 +261,17 @@ class Gem::Version
     initialize array[0]
   end
 
-  def yaml_initialize(tag, map)
+  def yaml_initialize(tag, map) # :nodoc:
     @version = map['version']
     @segments = nil
     @hash = nil
   end
 
-  def to_yaml_properties
+  def to_yaml_properties # :nodoc:
     ["@version"]
   end
 
-  def encode_with coder
+  def encode_with coder # :nodoc:
     coder.add 'version', @version
   end
 
-- 
2.2.1
